[["0", {"page_content": "module.exports = {\n  parser: '@typescript-eslint/parser', // Specifies the ESLint parser\n  extends: [\n    'plugin:@typescript-eslint/recommended', // Uses the recommended rules from the @typescript-eslint/eslint-plugin\n    'plugin:react/recommended',\n    'plugin:react-hooks/recommended',\n    'plugin:prettier/recommended',\n  ],\n  parserOptions: {\n    ecmaVersion: 2018, // Allows for the parsing of modern ECMAScript features\n    sourceType: 'module', // Allows for the use of imports\n  },\n  rules: {\n    // Place to specify ESLint rules. Can be used to overwrite rules specified from the extended configs\n    '@typescript-eslint/explicit-function-return-type': 'off',\n    '@typescript-eslint/explicit-module-boundary-types': 'off',\n    'react/react-in-jsx-scope': 'off',\n    'react/prop-types': 'off',\n    '@typescript-eslint/no-explicit-any': 'off',\n    'prettier/prettier': [\n      'error',\n      {\n        endOfLine: 'auto',\n      },\n    ],\n  },\n  // \"overrides\": [\n  //   {", "metadata": {"source": "autodoc/.eslintrc.cjs"}, "type": "Document"}], ["1", {"page_content": "'error',\n      {\n        endOfLine: 'auto',\n      },\n    ],\n  },\n  // \"overrides\": [\n  //   {\n  //     \"files\": [],\n  //     \"rules\": {\n  // \"@typescript-eslint/no-unused-vars\": \"off\"\n  //     }\n  //   }\n  // ],\n  settings: {\n    react: {\n      version: 'detect',\n    },\n  },\n};", "metadata": {"source": "autodoc/.eslintrc.cjs"}, "type": "Document"}], ["2", {"page_content": "import path from 'node:path';\nimport os from 'node:os';\n\nexport const userConfigFileName = 'autodoc.user.json';\n\nexport const userConfigFilePath = path.resolve(\n  os.homedir(),\n  './.config/autodoc/',\n  userConfigFileName,\n);", "metadata": {"source": "autodoc/src/const.ts"}, "type": "Document"}], ["3", {"page_content": "import ora from 'ora';\n\nconst spinner = ora({\n  // make a singleton so we don't ever have 2 spinners\n  spinner: 'dots',\n});\n\nexport const updateSpinnerText = (message: string) => {\n  if (spinner.isSpinning) {\n    spinner.text = message;\n    return;\n  }\n  spinner.start(message);\n};\n\nexport const stopSpinner = () => {\n  if (spinner.isSpinning) {\n    spinner.stop();\n  }\n};\n\nexport const spinnerError = (message?: string) => {\n  if (spinner.isSpinning) {\n    spinner.fail(message);\n  }\n};\nexport const spinnerSuccess = (message?: string) => {\n  if (spinner.isSpinning) {\n    spinner.succeed(message);\n  }\n};\nexport const spinnerInfo = (message: string) => {\n  spinner.info(message);\n};", "metadata": {"source": "autodoc/src/cli/spinner.ts"}, "type": "Document"}], ["4", {"page_content": "export function getFileName(\n  input: string,\n  delimiter = '.',\n  extension = '.md',\n): string {\n  const lastDelimiterIndex = input.lastIndexOf(delimiter);\n  if (lastDelimiterIndex === -1) {\n    // delimiter not found in string\n    return input + extension;\n  } else {\n    return input.slice(0, lastDelimiterIndex) + extension;\n  }\n}\n\nexport const githubFileUrl = (\n  githubRoot: string,\n  inputRoot: string,\n  filePath: string,\n  linkHosted: boolean,\n): string => {\n  if (linkHosted) {\n    return `${githubRoot}/${filePath.substring(inputRoot.length - 1)}`;\n  } else {\n    return `${githubRoot}/blob/master/${filePath.substring(\n      inputRoot.length - 1,\n    )}`;\n  }\n};", "metadata": {"source": "autodoc/src/cli/utils/FileUtil.ts"}, "type": "Document"}], ["5", {"page_content": "export const githubFolderUrl = (\n  githubRoot: string,\n  inputRoot: string,\n  folderPath: string,\n  linkHosted: boolean,\n): string => {\n  if (linkHosted) {\n    return `${githubRoot}/${folderPath.substring(inputRoot.length - 1)}`;\n  } else {\n    return `${githubRoot}/tree/master/${folderPath.substring(\n      inputRoot.length - 1,\n    )}`;\n  }\n};", "metadata": {"source": "autodoc/src/cli/utils/FileUtil.ts"}, "type": "Document"}], ["6", {"page_content": "export class APIRateLimit {\n  private queue: (() => void)[] = [];\n  private inProgress = 0;\n\n  constructor(private maxConcurrentCalls: number = 50) {}\n\n  async callApi<T>(apiFunction: () => Promise<T>): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const executeCall = async () => {\n        this.inProgress++;\n        try {\n          const result = await apiFunction();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.inProgress--;\n          this.dequeueAndExecute();\n        }\n      };\n\n      this.queue.push(executeCall);\n\n      // Trigger the dequeue and execute operation when there are available slots for concurrent calls\n      if (this.inProgress < this.maxConcurrentCalls) {\n        this.dequeueAndExecute();\n      }\n    });\n  }", "metadata": {"source": "autodoc/src/cli/utils/APIRateLimit.ts"}, "type": "Document"}], ["7", {"page_content": "private dequeueAndExecute() {\n    while (this.queue.length > 0 && this.inProgress < this.maxConcurrentCalls) {\n      const nextCall = this.queue.shift();\n      if (nextCall) {\n        nextCall();\n      }\n    }\n  }\n}", "metadata": {"source": "autodoc/src/cli/utils/APIRateLimit.ts"}, "type": "Document"}], ["8", {"page_content": "import fs from 'node:fs/promises';\nimport path from 'path';\nimport minimatch from 'minimatch';\nimport { isText } from 'istextorbinary';\nimport { TraverseFileSystemParams } from '../../types.js';\n\nexport const traverseFileSystem = async (\n  params: TraverseFileSystemParams,\n): Promise<void> => {\n  try {\n    const {\n      inputPath,\n      projectName,\n      processFile,\n      processFolder,\n      ignore,\n      filePrompt,\n      folderPrompt,\n      contentType,\n      targetAudience,\n      linkHosted,\n    } = params;\n\n    try {\n      await fs.access(inputPath);\n    } catch (error) {\n      console.error('The provided folder path does not exist.');\n      return;\n    }\n\n    const shouldIgnore = (fileName: string): boolean => {\n      return ignore.some((pattern) => minimatch(fileName, pattern));\n    };\n\n    const dfs = async (currentPath: string): Promise<void> => {\n      const contents = (await fs.readdir(currentPath)).filter(\n        (fileName) => !shouldIgnore(fileName),\n      );", "metadata": {"source": "autodoc/src/cli/utils/traverseFileSystem.ts"}, "type": "Document"}], ["9", {"page_content": "await Promise.all(\n        contents.map(async (folderName) => {\n          const folderPath = path.join(currentPath, folderName);\n          const entryStats = await fs.stat(folderPath);\n\n          if (entryStats.isDirectory()) {\n            await dfs(folderPath);\n\n            await processFolder?.({\n              inputPath,\n              folderName,\n              folderPath,\n              projectName,\n              shouldIgnore,\n              folderPrompt,\n              contentType,\n              targetAudience,\n              linkHosted,\n            });\n          }\n        }),\n      );\n\n      await Promise.all(\n        contents.map(async (fileName) => {\n          const filePath = path.join(currentPath, fileName);\n          const entryStats = await fs.stat(filePath);\n\n          if (!entryStats.isFile()) {\n            return;\n          }\n\n          const buffer = await fs.readFile(filePath);", "metadata": {"source": "autodoc/src/cli/utils/traverseFileSystem.ts"}, "type": "Document"}], ["10", {"page_content": "const buffer = await fs.readFile(filePath);\n\n          if (isText(fileName, buffer)) {\n            await processFile?.({\n              fileName,\n              filePath,\n              projectName,\n              filePrompt,\n              contentType,\n              targetAudience,\n              linkHosted,\n            });\n          }\n        }),\n      );\n    };\n\n    await dfs(inputPath);\n  } catch (e: any) {\n    console.error(`Error during traversal: ${e.message}`);\n    throw e;\n  }\n};", "metadata": {"source": "autodoc/src/cli/utils/traverseFileSystem.ts"}, "type": "Document"}], ["11", {"page_content": "import { OpenAIChat } from 'langchain/llms';\nimport { LLMModelDetails, LLMModels } from '../../types.js';", "metadata": {"source": "autodoc/src/cli/utils/LLMUtil.ts"}, "type": "Document"}], ["12", {"page_content": "export const models: Record<LLMModels, LLMModelDetails> = {\n  [LLMModels.GPT3]: {\n    name: LLMModels.GPT3,\n    inputCostPer1KTokens: 0.0015,\n    outputCostPer1KTokens: 0.002,\n    maxLength: 3050,\n    llm: new OpenAIChat({\n      temperature: 0.1,\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      modelName: LLMModels.GPT3,\n    }),\n    inputTokens: 0,\n    outputTokens: 0,\n    succeeded: 0,\n    failed: 0,\n    total: 0,\n  },\n  [LLMModels.GPT4]: {\n    name: LLMModels.GPT4,\n    inputCostPer1KTokens: 0.03,\n    outputCostPer1KTokens: 0.06,\n    maxLength: 8192,\n    llm: new OpenAIChat({\n      temperature: 0.1,\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      modelName: LLMModels.GPT4,\n    }),\n    inputTokens: 0,\n    outputTokens: 0,\n    succeeded: 0,\n    failed: 0,\n    total: 0,\n  },\n  [LLMModels.GPT432k]: {\n    name: LLMModels.GPT432k,\n    inputCostPer1KTokens: 0.06,\n    outputCostPer1KTokens: 0.12,\n    maxLength: 32768,\n    llm: new OpenAIChat({\n      temperature: 0.1,", "metadata": {"source": "autodoc/src/cli/utils/LLMUtil.ts"}, "type": "Document"}], ["13", {"page_content": "maxLength: 32768,\n    llm: new OpenAIChat({\n      temperature: 0.1,\n      openAIApiKey: process.env.OPENAI_API_KEY,\n      modelName: LLMModels.GPT4,\n    }),\n    inputTokens: 0,\n    outputTokens: 0,\n    succeeded: 0,\n    failed: 0,\n    total: 0,\n  },\n};", "metadata": {"source": "autodoc/src/cli/utils/LLMUtil.ts"}, "type": "Document"}], ["14", {"page_content": "export const printModelDetails = (models: LLMModelDetails[]): void => {\n  const output = models.map((model) => {\n    return {\n      Model: model.name,\n      'File Count': model.total,\n      Succeeded: model.succeeded,\n      Failed: model.failed,\n      Tokens: model.inputTokens + model.outputTokens,\n      Cost:\n        (model.inputTokens / 1000) * model.inputCostPer1KTokens +\n        (model.outputTokens / 1000) * model.outputCostPer1KTokens,\n    };\n  });\n\n  const totals = output.reduce(\n    (cur: any, next) => {\n      return {\n        ...cur,\n        'File Count': cur['File Count'] + next['File Count'],\n        Succeeded: cur.Succeeded + next.Succeeded,\n        Failed: cur.Failed + next.Failed,\n        Tokens: cur.Tokens + next.Tokens,\n        Cost: cur.Cost + next.Cost,\n      };\n    },\n    {\n      Model: 'Total',\n      'File Count': 0,\n      Succeeded: 0,\n      Failed: 0,\n      Tokens: 0,\n      Cost: 0,\n    },\n  );\n\n  const all = [...output, totals];\n  console.table(all);\n};", "metadata": {"source": "autodoc/src/cli/utils/LLMUtil.ts"}, "type": "Document"}], ["15", {"page_content": "const all = [...output, totals];\n  console.table(all);\n};\n\nexport const totalIndexCostEstimate = (models: LLMModelDetails[]): number => {\n  const totalCost = models.reduce((cur, model) => {\n    return (\n      cur +\n      (model.inputTokens / 1000) * model.inputCostPer1KTokens +\n      (model.outputTokens / 1000) * model.outputCostPer1KTokens\n    );\n  }, 0);\n\n  return totalCost;\n};", "metadata": {"source": "autodoc/src/cli/utils/LLMUtil.ts"}, "type": "Document"}], ["16", {"page_content": "export async function wait(timeoutMs: number, value: any = null): Promise<any> {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(value), timeoutMs);\n  });\n}\n\nexport async function forTrue(fn: () => boolean) {\n  const count = 0;\n  return new Promise((resolve, reject) => {\n    if (fn()) {\n      resolve(true);\n      return;\n    }\n\n    const interval = setInterval(() => {\n      if (fn()) {\n        clearInterval(interval);\n        resolve(true);\n        return;\n      }\n      if (count >= 200) reject();\n    }, 50);\n  });\n}", "metadata": {"source": "autodoc/src/cli/utils/WaitUtil.ts"}, "type": "Document"}], ["17", {"page_content": "import chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { AutodocRepoConfig, LLMModels, Priority } from '../../../types.js';", "metadata": {"source": "autodoc/src/cli/commands/init/index.ts"}, "type": "Document"}], ["18", {"page_content": "export const makeConfigTemplate = (\n  config?: AutodocRepoConfig,\n): AutodocRepoConfig => {\n  return {\n    name: config?.name ?? '',\n    repositoryUrl: config?.repositoryUrl ?? '',\n    root: '.',\n    output: './.autodoc',\n    llms:\n      config?.llms?.length ?? 0 > 0\n        ? (config as AutodocRepoConfig).llms\n        : [LLMModels.GPT3],\n    priority: Priority.COST,\n    maxConcurrentCalls: 25,\n    addQuestions: true,\n    ignore: [\n      '.*',\n      '*package-lock.json',\n      '*package.json',\n      'node_modules',\n      '*dist*',\n      '*build*',\n      '*test*',\n      '*.svg',\n      '*.md',\n      '*.mdx',\n      '*.toml',\n      '*autodoc*',\n    ],\n    filePrompt:\n      config?.filePrompt ??\n      'Write a detailed technical explanation of what this code does. \\n\\\n      Focus on the high-level purpose of the code and how it may be used in the larger project.\\n\\\n      Include code examples where appropriate. Keep you response between 100 and 300 words. \\n\\", "metadata": {"source": "autodoc/src/cli/commands/init/index.ts"}, "type": "Document"}], ["19", {"page_content": "Include code examples where appropriate. Keep you response between 100 and 300 words. \\n\\\n      DO NOT RETURN MORE THAN 300 WORDS.\\n\\\n      Output should be in markdown format.\\n\\\n      Do not just list the methods and classes in this file.',\n    folderPrompt:\n      config?.folderPrompt ??\n      'Write a technical explanation of what the code in this folder does\\n\\\n      and how it might fit into the larger project or work with other parts of the project.\\n\\\n      Give examples of how this code might be used. Include code examples where appropriate.\\n\\\n      Be concise. Include any information that may be relevant to a developer who is curious about this code.\\n\\\n      Keep you response under 400 words. Output should be in markdown format.\\n\\\n      Do not just list the files and folders in this folder.',\n    chatPrompt: '',\n    contentType: 'code',\n    targetAudience: 'smart developer',\n    linkHosted: false,\n  };\n};", "metadata": {"source": "autodoc/src/cli/commands/init/index.ts"}, "type": "Document"}], ["20", {"page_content": "export const init = async (\n  config: AutodocRepoConfig = makeConfigTemplate(),\n) => {\n  const configPath = path.join(config.root, 'autodoc.config.json');\n\n  if (fs.existsSync(configPath)) {\n    const questions = [\n      {\n        type: 'confirm',\n        name: 'continue',\n        message:\n          'An autodoc.config.json file already exists in this location. The existing configuration will be overwritten. Do you want to continue? ',\n        default: false,\n      },\n    ];\n\n    const answers = await inquirer.prompt(questions);\n    if (!answers.continue) {\n      process.exit(0);\n    }\n  }", "metadata": {"source": "autodoc/src/cli/commands/init/index.ts"}, "type": "Document"}], ["21", {"page_content": "const questions = [\n    {\n      type: 'input',\n      name: 'name',\n      message: chalk.yellow(`Enter the name of your repository:`),\n      default: config.name,\n    },\n    {\n      type: 'input',\n      name: 'repositoryUrl',\n      message: chalk.yellow(`Enter the GitHub URL of your repository:`),\n      default: config.repositoryUrl,\n    },\n    {\n      type: 'list',\n      name: 'llms',\n      message: chalk.yellow(\n        `Select which LLMs you have access to (use GPT-3.5 Turbo if you aren't sure):`,\n      ),\n      default: 0,\n      choices: [\n        {\n          name: 'GPT-3.5 Turbo',\n          value: [LLMModels.GPT3],\n        },\n        {\n          name: 'GPT-3.5 Turbo, GPT-4 8K (Early Access)',\n          value: [LLMModels.GPT3, LLMModels.GPT4],\n        },\n        {\n          name: 'GPT-3.5 Turbo, GPT-4 8K (Early Access), GPT-4 32K (Early Access)',\n          value: [LLMModels.GPT3, LLMModels.GPT4, LLMModels.GPT432k],\n        },\n      ],\n    },\n    {\n      type: 'input',", "metadata": {"source": "autodoc/src/cli/commands/init/index.ts"}, "type": "Document"}], ["22", {"page_content": "},\n      ],\n    },\n    {\n      type: 'input',\n      name: 'filePrompt',\n      message: chalk.yellow(\n        `Enter the prompt you want to use for generating file-level documentation:`,\n      ),\n      default: config.filePrompt,\n    },\n    {\n      type: 'input',\n      name: 'folderPrompt',\n      message: chalk.yellow(\n        `Enter the prompt you want to use for generating folder-level documentation:`,\n      ),\n      default: config.folderPrompt,\n    },\n  ];", "metadata": {"source": "autodoc/src/cli/commands/init/index.ts"}, "type": "Document"}], ["23", {"page_content": "const { name, repositoryUrl, llms, filePrompt, folderPrompt } =\n    await inquirer.prompt(questions);\n\n  const newConfig = makeConfigTemplate({\n    ...config,\n    name,\n    repositoryUrl,\n    llms,\n    filePrompt,\n    folderPrompt,\n  });\n\n  fs.writeFileSync(\n    path.join(newConfig.root, 'autodoc.config.json'),\n    JSON.stringify(newConfig, null, 2),\n    'utf-8',\n  );\n\n  console.log(\n    chalk.green('Autodoc initialized. Run `doc index` to get started.'),\n  );\n};", "metadata": {"source": "autodoc/src/cli/commands/init/index.ts"}, "type": "Document"}], ["24", {"page_content": "import { OpenAIChat } from 'langchain/llms';\nimport { LLMChain, ChatVectorDBQAChain, loadQAChain } from 'langchain/chains';\nimport { PromptTemplate } from 'langchain/prompts';\nimport { HNSWLib } from '../../../langchain/hnswlib.js';\nimport { LLMModels } from '../../../types.js';\n\nconst CONDENSE_PROMPT =\n  PromptTemplate.fromTemplate(`Given the following conversation and a follow up question, rephrase the follow up question to be a standalone question.\n\nChat History:\n{chat_history}\nFollow Up Input: {question}\nStandalone question:`);", "metadata": {"source": "autodoc/src/cli/commands/query/createChatChain.ts"}, "type": "Document"}], ["25", {"page_content": "// eslint-disable-next-line prettier/prettier\nconst makeQAPrompt = (projectName: string, repositoryUrl: string, contentType: string, chatPrompt: string, targetAudience: string) =>\n  PromptTemplate.fromTemplate(\n    `You are an AI assistant for a software project called ${projectName}. You are trained on all the ${contentType} that makes up this project.\n  The ${contentType} for the project is located at ${repositoryUrl}.\nYou are given the following extracted parts of a technical summary of files in a ${contentType} and a question. \nProvide a conversational answer with hyperlinks back to GitHub.\nYou should only use hyperlinks that are explicitly listed in the context. Do NOT make up a hyperlink that is not listed.\nInclude lots of ${contentType} examples and links to the ${contentType} examples, where appropriate.\nAssume the reader is a ${targetAudience} but is not deeply familiar with ${projectName}.", "metadata": {"source": "autodoc/src/cli/commands/query/createChatChain.ts"}, "type": "Document"}], ["26", {"page_content": "Assume the reader is a ${targetAudience} but is not deeply familiar with ${projectName}.\nAssume the reader does not know anything about how the project is strucuted or which folders/files are provided in the context.\nDo not reference the context in your answer. Instead use the context to inform your answer.\nIf you don't know the answer, just say \"Hmm, I'm not sure.\" Don't try to make up an answer.\nIf the question is not about the ${projectName}, politely inform them that you are tuned to only answer questions about the ${projectName}.\nYour answer should be at least 100 words and no more than 300 words.\nDo not include information that is not directly relevant to the question, even if the context includes it.\nAlways include a list of reference links to GitHub from the context. Links should ONLY come from the context.", "metadata": {"source": "autodoc/src/cli/commands/query/createChatChain.ts"}, "type": "Document"}], ["27", {"page_content": "${\n  chatPrompt.length > 0\n    ? `Here are some additional instructions for answering questions about ${contentType}:\\n${chatPrompt}`\n    : ''\n}\n\nQuestion: {question}\n\nContext:\n{context}\n\n\nAnswer in Markdown:`,\n  );\n\nexport const makeChain = (\n  projectName: string,\n  repositoryUrl: string,\n  contentType: string,\n  chatPrompt: string,\n  targetAudience: string,\n  vectorstore: HNSWLib,\n  llms: LLMModels[],\n  onTokenStream?: (token: string) => void,\n) => {\n  /**\n   * GPT-4 or GPT-3\n   */\n  const llm = llms?.[1] ?? llms[0];\n  const questionGenerator = new LLMChain({\n    llm: new OpenAIChat({ temperature: 0.1, modelName: llm }),\n    prompt: CONDENSE_PROMPT,\n  });", "metadata": {"source": "autodoc/src/cli/commands/query/createChatChain.ts"}, "type": "Document"}], ["28", {"page_content": "// eslint-disable-next-line prettier/prettier\n  const QA_PROMPT = makeQAPrompt(projectName, repositoryUrl, contentType, chatPrompt, targetAudience);\n  const docChain = loadQAChain(\n    new OpenAIChat({\n      temperature: 0.2,\n      frequencyPenalty: 0,\n      presencePenalty: 0,\n      modelName: llm,\n      streaming: Boolean(onTokenStream),\n      callbackManager: {\n        handleLLMNewToken: onTokenStream,\n        handleLLMStart: () => null,\n        handleLLMEnd: () => null,\n      } as any,\n    }),\n    { prompt: QA_PROMPT },\n  );\n\n  return new ChatVectorDBQAChain({\n    vectorstore,\n    combineDocumentsChain: docChain,\n    questionGeneratorChain: questionGenerator,\n  });\n};", "metadata": {"source": "autodoc/src/cli/commands/query/createChatChain.ts"}, "type": "Document"}], ["29", {"page_content": "import chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport { marked } from 'marked';\nimport TerminalRenderer from 'marked-terminal';\nimport { OpenAIEmbeddings } from 'langchain/embeddings';\nimport path from 'path';\nimport { HNSWLib } from '../../../langchain/hnswlib.js';\nimport { AutodocRepoConfig, AutodocUserConfig } from '../../../types.js';\nimport { makeChain } from './createChatChain.js';\nimport { stopSpinner, updateSpinnerText } from '../../spinner.js';\n\nconst chatHistory: [string, string][] = [];\n\nmarked.setOptions({\n  // Define custom renderer\n  renderer: new TerminalRenderer(),\n});\n\nconst displayWelcomeMessage = (projectName: string) => {\n  console.log(chalk.bold.blue(`Welcome to the ${projectName} chatbot.`));\n  console.log(\n    `Ask any questions related to the ${projectName} codebase, and I'll try to help. Type 'exit' to quit.\\n`,\n  );\n};\n\nconst clearScreenAndMoveCursorToTop = () => {\n  process.stdout.write('\\x1B[2J\\x1B[0f');\n};", "metadata": {"source": "autodoc/src/cli/commands/query/index.ts"}, "type": "Document"}], ["30", {"page_content": "const clearScreenAndMoveCursorToTop = () => {\n  process.stdout.write('\\x1B[2J\\x1B[0f');\n};\n\nexport const query = async (\n  { name, repositoryUrl, output, contentType, chatPrompt, targetAudience}: AutodocRepoConfig,\n  { llms }: AutodocUserConfig,\n) => {\n  const data = path.join(output, 'docs', 'data/');\n  const vectorStore = await HNSWLib.load(data, new OpenAIEmbeddings());\n  const chain = makeChain(\n    name,\n    repositoryUrl,\n    contentType,\n    chatPrompt,\n    targetAudience,\n    vectorStore,\n    llms,\n    (token: string) => {\n      stopSpinner();\n      process.stdout.write(token);\n    },\n  );\n\n  clearScreenAndMoveCursorToTop();\n  displayWelcomeMessage(name);\n\n  const getQuestion = async () => {\n    const { question } = await inquirer.prompt([\n      {\n        type: 'input',\n        name: 'question',\n        message: chalk.yellow(`How can I help with ${name}?\\n`),\n      },\n    ]);\n\n    return question;\n  };\n\n  let question = await getQuestion();", "metadata": {"source": "autodoc/src/cli/commands/query/index.ts"}, "type": "Document"}], ["31", {"page_content": "return question;\n  };\n\n  let question = await getQuestion();\n\n  while (question !== 'exit') {\n    updateSpinnerText('Thinking...');\n    try {\n      const { text } = await chain.call({\n        question,\n        chat_history: chatHistory,\n      });\n\n      chatHistory.push([question, text]);\n\n      console.log('\\n\\nMarkdown:\\n');\n      console.log(marked(text));\n\n      question = await getQuestion();\n    } catch (error: any) {\n      console.log(chalk.red(`Something went wrong: ${error.message}`));\n      question = await getQuestion();\n    }\n  }\n};", "metadata": {"source": "autodoc/src/cli/commands/query/index.ts"}, "type": "Document"}], ["32", {"page_content": "import path from 'path';\nimport { AutodocRepoConfig } from '../../../types.js';\nimport { spinnerSuccess, updateSpinnerText } from '../../spinner.js';\nimport { convertJsonToMarkdown } from './convertJsonToMarkdown.js';\nimport { createVectorStore } from './createVectorStore.js';\nimport { processRepository } from './processRepository.js';\n\nexport const index = async ({\n  name,\n  repositoryUrl,\n  root,\n  output,\n  llms,\n  priority,\n  maxConcurrentCalls,\n  addQuestions,\n  ignore,\n  filePrompt,\n  folderPrompt,\n  chatPrompt,\n  contentType,\n  targetAudience,\n  linkHosted,\n}: AutodocRepoConfig) => {\n  const json = path.join(output, 'docs', 'json/');\n  const markdown = path.join(output, 'docs', 'markdown/');\n  const data = path.join(output, 'docs', 'data/');\n\n  /**\n   * Traverse the repository, call LLMS for each file,\n   * and create JSON files with the results.\n   */", "metadata": {"source": "autodoc/src/cli/commands/index/index.ts"}, "type": "Document"}], ["33", {"page_content": "updateSpinnerText('Processing repository...');\n  await processRepository({\n    name,\n    repositoryUrl,\n    root,\n    output: json,\n    llms,\n    priority,\n    maxConcurrentCalls,\n    addQuestions,\n    ignore,\n    filePrompt,\n    folderPrompt,\n    chatPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  });\n  updateSpinnerText('Processing repository...');\n  spinnerSuccess();\n\n  /**\n   * Create markdown files from JSON files\n   */\n  updateSpinnerText('Creating markdown files...');\n  await convertJsonToMarkdown({\n    name,\n    repositoryUrl,\n    root: json,\n    output: markdown,\n    llms,\n    priority,\n    maxConcurrentCalls,\n    addQuestions,\n    ignore,\n    filePrompt,\n    folderPrompt,\n    chatPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  });\n  spinnerSuccess();", "metadata": {"source": "autodoc/src/cli/commands/index/index.ts"}, "type": "Document"}], ["34", {"page_content": "updateSpinnerText('Create vector files...');\n  await createVectorStore({\n    name,\n    repositoryUrl,\n    root: markdown,\n    output: data,\n    llms,\n    priority,\n    maxConcurrentCalls,\n    addQuestions,\n    ignore,\n    filePrompt,\n    folderPrompt,\n    chatPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  });\n  spinnerSuccess();\n};\n\nexport default {\n  index,\n};", "metadata": {"source": "autodoc/src/cli/commands/index/index.ts"}, "type": "Document"}], ["35", {"page_content": "import fs from 'node:fs/promises';\nimport path from 'path';\nimport {\n  AutodocRepoConfig,\n  FileSummary,\n  FolderSummary,\n  ProcessFile,\n} from '../../../types';\nimport { traverseFileSystem } from '../../utils/traverseFileSystem.js';\nimport { spinnerSuccess, updateSpinnerText } from '../../spinner.js';\nimport { getFileName } from '../../utils/FileUtil.js';\n\nexport const convertJsonToMarkdown = async ({\n  name: projectName,\n  root: inputRoot,\n  output: outputRoot,\n  filePrompt: filePrompt,\n  folderPrompt: folderPrompt,\n  contentType: contentType,\n  targetAudience: targetAudience,\n  linkHosted: linkHosted,\n}: AutodocRepoConfig) => {\n  /**\n   * Count the number of files in the project\n   */\n  let files = 0;\n  await traverseFileSystem({\n    inputPath: inputRoot,\n    projectName,\n    processFile: () => {\n      files++;\n      return Promise.resolve();\n    },\n    ignore: [],\n    filePrompt,\n    folderPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  });", "metadata": {"source": "autodoc/src/cli/commands/index/convertJsonToMarkdown.ts"}, "type": "Document"}], ["36", {"page_content": "/**\n   * Create markdown files for each code file in the project\n   */\n\n  const processFile: ProcessFile = async ({\n    fileName,\n    filePath,\n  }): Promise<void> => {\n    const content = await fs.readFile(filePath, 'utf-8');\n\n    // TODO: Handle error\n    if (!content) return;\n\n    const markdownFilePath = path\n      .join(outputRoot, filePath)\n      .replace(inputRoot, '');\n\n    /**\n     * Create the output directory if it doesn't exist\n     */\n    try {\n      await fs.mkdir(markdownFilePath.replace(fileName, ''), {\n        recursive: true,\n      });\n    } catch (error) {\n      console.error(error);\n      return;\n    }\n\n    const { url, summary, questions } =\n      fileName === 'summary.json'\n        ? (JSON.parse(content) as FolderSummary)\n        : (JSON.parse(content) as FileSummary);", "metadata": {"source": "autodoc/src/cli/commands/index/convertJsonToMarkdown.ts"}, "type": "Document"}], ["37", {"page_content": "/**\n     * Only include the file if it has a summary\n     */\n    const markdown =\n      summary.length > 0\n        ? `[View code on GitHub](${url})\\n\\n${summary}\\n${\n            questions ? '## Questions: \\n ' + questions : ''\n          }`\n        : '';\n\n    const outputPath = getFileName(markdownFilePath, '.', '.md');\n    await fs.writeFile(outputPath, markdown, 'utf-8');\n  };\n\n  updateSpinnerText(`Creating ${files} markdown files...`);\n  await traverseFileSystem({\n    inputPath: inputRoot,\n    projectName,\n    processFile,\n    ignore: [],\n    filePrompt,\n    folderPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  });\n  spinnerSuccess(`Created ${files} markdown files...`);\n};", "metadata": {"source": "autodoc/src/cli/commands/index/convertJsonToMarkdown.ts"}, "type": "Document"}], ["38", {"page_content": "import fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { Md5 } from 'ts-md5';\nimport { OpenAIChat } from 'langchain/llms';\nimport { encoding_for_model } from '@dqbd/tiktoken';\nimport { APIRateLimit } from '../../utils/APIRateLimit.js';\nimport {\n  createCodeFileSummary,\n  createCodeQuestions,\n  folderSummaryPrompt,\n} from './prompts.js';\nimport {\n  AutodocRepoConfig,\n  FileSummary,\n  FolderSummary,\n  LLMModelDetails,\n  LLMModels,\n  ProcessFile,\n  ProcessFolder,\n} from '../../../types.js';\nimport { traverseFileSystem } from '../../utils/traverseFileSystem.js';\nimport {\n  spinnerSuccess,\n  stopSpinner,\n  updateSpinnerText,\n} from '../../spinner.js';\nimport {\n  getFileName,\n  githubFileUrl,\n  githubFolderUrl,\n} from '../../utils/FileUtil.js';\nimport { models } from '../../utils/LLMUtil.js';\nimport { selectModel } from './selectModel.js';", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["39", {"page_content": "export const processRepository = async (\n  {\n    name: projectName,\n    repositoryUrl,\n    root: inputRoot,\n    output: outputRoot,\n    llms,\n    priority,\n    maxConcurrentCalls,\n    addQuestions,\n    ignore,\n    filePrompt,\n    folderPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  }: AutodocRepoConfig,\n  dryRun?: boolean,\n) => {\n  const rateLimit = new APIRateLimit(maxConcurrentCalls);\n\n  const callLLM = async (\n    prompt: string,\n    model: OpenAIChat,\n  ): Promise<string> => {\n    return rateLimit.callApi(() => model.call(prompt));\n  };\n\n  const isModel = (model: LLMModelDetails | null): model is LLMModelDetails =>\n    model !== null;\n\n  const processFile: ProcessFile = async ({\n    fileName,\n    filePath,\n    projectName,\n    contentType,\n    filePrompt,\n    targetAudience,\n    linkHosted,\n  }): Promise<void> => {\n    const content = await fs.readFile(filePath, 'utf-8');", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["40", {"page_content": "/**\n     * Calculate the checksum of the file content\n     */\n    const newChecksum = await calculateChecksum([content]);\n\n    /**\n     * if an existing .json file exists,\n     * it will check the checksums and decide if a reindex is needed\n     */\n    const reindex = await shouldReindex(\n      path.join(outputRoot, filePath.substring(0, filePath.lastIndexOf('\\\\'))),\n      fileName.replace(/\\.[^/.]+$/, '.json'),\n      newChecksum,\n    );\n    if (!reindex) {\n      return;\n    }\n\n    const markdownFilePath = path.join(outputRoot, filePath);\n    const url = githubFileUrl(repositoryUrl, inputRoot, filePath, linkHosted);\n\n    const summaryPrompt = createCodeFileSummary(\n      projectName,\n      projectName,\n      content,\n      contentType,\n      filePrompt,\n    );\n    const questionsPrompt = createCodeQuestions(\n      projectName,\n      projectName,\n      content,\n      contentType,\n      targetAudience,\n    );", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["41", {"page_content": "const prompts = addQuestions\n      ? [summaryPrompt, questionsPrompt]\n      : [summaryPrompt];\n\n    const model = selectModel(prompts, llms, models, priority);\n\n    if (!isModel(model)) {\n      // console.log(`Skipped ${filePath} | Length ${max}`);\n      return;\n    }\n\n    const encoding = encoding_for_model(model.name);\n    const summaryLength = encoding.encode(summaryPrompt).length;\n    const questionLength = encoding.encode(questionsPrompt).length;\n\n    try {\n      if (!dryRun) {\n        /** Call LLM */\n        const response = await Promise.all(\n          prompts.map(async (prompt) => callLLM(prompt, model.llm)),\n        );\n\n        /**\n         * Create file and save to disk\n         */\n        const file: FileSummary = {\n          fileName,\n          filePath,\n          url,\n          summary: response[0],\n          questions: addQuestions ? response[1] : '',\n          checksum: newChecksum,\n        };", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["42", {"page_content": "const outputPath = getFileName(markdownFilePath, '.', '.json');\n        const content =\n          file.summary.length > 0 ? JSON.stringify(file, null, 2) : '';\n\n        /**\n         * Create the output directory if it doesn't exist\n         */\n        try {\n          await fs.mkdir(markdownFilePath.replace(fileName, ''), {\n            recursive: true,\n          });\n          await fs.writeFile(outputPath, content, 'utf-8');\n        } catch (error) {\n          console.error(error);\n          return;\n        }\n\n        // console.log(`File: ${fileName} => ${outputPath}`);\n      }\n\n      /**\n       * Track usage for end of run summary\n       */\n      model.inputTokens += summaryLength;\n      if (addQuestions) model.inputTokens += questionLength;\n      model.total++;\n      model.outputTokens += 1000;\n      model.succeeded++;\n    } catch (e) {\n      console.log(e);\n      console.error(`Failed to get summary for file ${fileName}`);\n      model.failed++;\n    }\n  };", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["43", {"page_content": "const processFolder: ProcessFolder = async ({\n    folderName,\n    folderPath,\n    projectName,\n    contentType,\n    folderPrompt,\n    shouldIgnore,\n    linkHosted,\n  }): Promise<void> => {\n    /**\n     * For now we don't care about folders\n     *\n     * TODO: Add support for folders during estimation\n     */\n    if (dryRun) return;\n\n    const contents = (await fs.readdir(folderPath)).filter(\n      (fileName) => !shouldIgnore(fileName),\n    );\n\n    /**\n     * Get the checksum of the folder\n     */\n    const newChecksum = await calculateChecksum(contents);\n\n    /**\n     * If an existing summary.json file exists,\n     * it will check the checksums and decide if a reindex is needed\n     */\n    const reindex = await shouldReindex(\n      folderPath,\n      'summary.json',\n      newChecksum,\n    );\n    if (!reindex) {\n      return;\n    }", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["44", {"page_content": "// eslint-disable-next-line prettier/prettier\n    const url = githubFolderUrl(\n      repositoryUrl,\n      inputRoot,\n      folderPath,\n      linkHosted,\n    );\n    const allFiles: (FileSummary | null)[] = await Promise.all(\n      contents.map(async (fileName) => {\n        const entryPath = path.join(folderPath, fileName);\n        const entryStats = await fs.stat(entryPath);\n\n        if (entryStats.isFile() && fileName !== 'summary.json') {\n          const file = await fs.readFile(entryPath, 'utf8');\n          return file.length > 0 ? JSON.parse(file) : null;\n        }\n\n        return null;\n      }),\n    );\n\n    try {\n      const files = allFiles.filter(\n        (file): file is FileSummary => file !== null,\n      );\n      const allFolders: (FolderSummary | null)[] = await Promise.all(\n        contents.map(async (fileName) => {\n          const entryPath = path.join(folderPath, fileName);\n          const entryStats = await fs.stat(entryPath);", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["45", {"page_content": "if (entryStats.isDirectory()) {\n            try {\n              const summaryFilePath = path.resolve(entryPath, 'summary.json');\n              const file = await fs.readFile(summaryFilePath, 'utf8');\n              return JSON.parse(file);\n            } catch (e) {\n              console.log(`Skipped: ${folderPath}`);\n              return null;\n            }\n          }\n\n          return null;\n        }),\n      );\n\n      const folders = allFolders.filter(\n        (folder): folder is FolderSummary => folder !== null,\n      );\n\n      const summaryPrompt = folderSummaryPrompt(\n        folderPath,\n        projectName,\n        files,\n        folders,\n        contentType,\n        folderPrompt,\n      );\n\n      const model = selectModel([summaryPrompt], llms, models, priority);\n\n      if (!isModel(model)) {\n        // console.log(`Skipped ${filePath} | Length ${max}`);\n        return;\n      }\n\n      const summary = await callLLM(summaryPrompt, model.llm);", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["46", {"page_content": "const summary = await callLLM(summaryPrompt, model.llm);\n\n      const folderSummary: FolderSummary = {\n        folderName,\n        folderPath,\n        url,\n        files,\n        folders: folders.filter(Boolean),\n        summary,\n        questions: '',\n        checksum: newChecksum,\n      };\n\n      const outputPath = path.join(folderPath, 'summary.json');\n      await fs.writeFile(\n        outputPath,\n        JSON.stringify(folderSummary, null, 2),\n        'utf-8',\n      );\n\n      // console.log(`Folder: ${folderName} => ${outputPath}`);\n    } catch (e) {\n      console.log(e);\n      console.log(`Failed to get summary for folder: ${folderPath}`);\n    }\n  };\n\n  /**\n   * Get the number of files and folders in the project\n   */\n\n  const filesAndFolders = async (): Promise<{\n    files: number;\n    folders: number;\n  }> => {\n    let files = 0;\n    let folders = 0;", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["47", {"page_content": "await Promise.all([\n      traverseFileSystem({\n        inputPath: inputRoot,\n        projectName,\n        processFile: () => {\n          files++;\n          return Promise.resolve();\n        },\n        ignore,\n        filePrompt,\n        folderPrompt,\n        contentType,\n        targetAudience,\n        linkHosted,\n      }),\n      traverseFileSystem({\n        inputPath: inputRoot,\n        projectName,\n        processFolder: () => {\n          folders++;\n          return Promise.resolve();\n        },\n        ignore,\n        filePrompt,\n        folderPrompt,\n        contentType,\n        targetAudience,\n        linkHosted,\n      }),\n    ]);\n\n    return {\n      files,\n      folders,\n    };\n  };\n\n  const { files, folders } = await filesAndFolders();\n\n  /**\n   * Create markdown files for each code file in the project\n   */", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["48", {"page_content": "/**\n   * Create markdown files for each code file in the project\n   */\n\n  updateSpinnerText(`Processing ${files} files...`);\n  await traverseFileSystem({\n    inputPath: inputRoot,\n    projectName,\n    processFile,\n    ignore,\n    filePrompt,\n    folderPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  });\n  spinnerSuccess(`Processing ${files} files...`);\n\n  /**\n   * Create markdown summaries for each folder in the project\n   */\n  updateSpinnerText(`Processing ${folders} folders... `);\n  await traverseFileSystem({\n    inputPath: outputRoot,\n    projectName,\n    processFolder,\n    ignore,\n    filePrompt,\n    folderPrompt,\n    contentType,\n    targetAudience,\n    linkHosted,\n  });\n  spinnerSuccess(`Processing ${folders} folders... `);\n  stopSpinner();\n\n  /**\n   * Print results\n   */\n  return models;\n};", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["49", {"page_content": "/**\n   * Print results\n   */\n  return models;\n};\n\n/**\n * Calculates the checksum of all the files in a folder\n */\nasync function calculateChecksum(contents: string[]): Promise<string> {\n  const checksums: string[] = [];\n  for (const content of contents) {\n    const checksum = Md5.hashStr(content);\n    checksums.push(checksum);\n  }\n  const concatenatedChecksum = checksums.join('');\n  const finalChecksum = Md5.hashStr(concatenatedChecksum);\n  return finalChecksum;\n}\n\n/**\n * Checks if a summary.json file exists.\n * If it does, compares the checksums to see if it\n * needs to be re-indexed or not.\n */\n\nasync function shouldReindex(\n  contentPath: string,\n  name: string,\n  newChecksum: string,\n): Promise<boolean> {\n  const jsonPath = path.join(contentPath, name);\n\n  let summaryExists = false;\n  try {\n    await fs.access(jsonPath);\n    summaryExists = true;\n  } catch (error) {}", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["50", {"page_content": "if (summaryExists) {\n    const fileContents = await fs.readFile(jsonPath, 'utf8');\n    const fileContentsJSON = JSON.parse(fileContents);\n\n    const oldChecksum = fileContentsJSON.checksum;\n\n    if (oldChecksum === newChecksum) {\n      console.log(`Skipping ${jsonPath} because it has not changed`);\n      return false;\n    } else {\n      console.log(`Reindexing ${jsonPath} because it has changed`);\n      return true;\n    }\n  }\n  //if no summary then generate one\n  return true;\n}", "metadata": {"source": "autodoc/src/cli/commands/index/processRepository.ts"}, "type": "Document"}], ["51", {"page_content": "import { encoding_for_model } from '@dqbd/tiktoken';\nimport { LLMModelDetails, LLMModels, Priority } from '../../../types.js';", "metadata": {"source": "autodoc/src/cli/commands/index/selectModel.ts"}, "type": "Document"}], ["52", {"page_content": "export const selectModel = (\n  prompts: string[],\n  llms: LLMModels[],\n  models: Record<LLMModels, LLMModelDetails>,\n  priority: Priority,\n): LLMModelDetails | null => {\n  if (priority === Priority.COST) {\n    if (\n      llms.includes(LLMModels.GPT3) &&\n      models[LLMModels.GPT3].maxLength >\n        getMaxPromptLength(prompts, LLMModels.GPT3)\n    ) {\n      return models[LLMModels.GPT3];\n    } else if (\n      llms.includes(LLMModels.GPT4) &&\n      models[LLMModels.GPT4].maxLength >\n        getMaxPromptLength(prompts, LLMModels.GPT4)\n    ) {\n      return models[LLMModels.GPT4];\n    } else if (\n      llms.includes(LLMModels.GPT432k) &&\n      models[LLMModels.GPT432k].maxLength >\n        getMaxPromptLength(prompts, LLMModels.GPT432k)\n    ) {\n      return models[LLMModels.GPT432k];\n    } else {\n      return null;\n    }\n  } else {\n    if (llms.includes(LLMModels.GPT4)) {\n      if (\n        models[LLMModels.GPT4].maxLength >\n        getMaxPromptLength(prompts, LLMModels.GPT4)\n      ) {", "metadata": {"source": "autodoc/src/cli/commands/index/selectModel.ts"}, "type": "Document"}], ["53", {"page_content": "getMaxPromptLength(prompts, LLMModels.GPT4)\n      ) {\n        return models[LLMModels.GPT4];\n      } else if (\n        llms.includes(LLMModels.GPT432k) &&\n        models[LLMModels.GPT432k].maxLength >\n          getMaxPromptLength(prompts, LLMModels.GPT432k)\n      ) {\n        return models[LLMModels.GPT432k];\n      } else {\n        return null;\n      }\n    } else {\n      return models[LLMModels.GPT3];\n    }\n  }", "metadata": {"source": "autodoc/src/cli/commands/index/selectModel.ts"}, "type": "Document"}], ["54", {"page_content": "function getMaxPromptLength(prompts: string[], model: LLMModels) {\n    const encoding = encoding_for_model(model);\n    return Math.max(...prompts.map((p) => encoding.encode(p).length));\n  }\n};", "metadata": {"source": "autodoc/src/cli/commands/index/selectModel.ts"}, "type": "Document"}], ["55", {"page_content": "import { FileSummary, FolderSummary } from '../../../types.js';\n\nexport const createCodeFileSummary = (\n  filePath: string,\n  projectName: string,\n  fileContents: string,\n  contentType: string,\n  filePrompt: string,\n): string => {\n  return `\n    You are acting as a ${contentType} documentation expert for a project called ${projectName}.\n    Below is the ${contentType} from a file located at \\`${filePath}\\`. \n    ${filePrompt}\n    Do not say \"this file is a part of the ${projectName} project\".\n\n    ${contentType}:\n    ${fileContents}\n\n    Response:\n\n  `;\n};", "metadata": {"source": "autodoc/src/cli/commands/index/prompts.ts"}, "type": "Document"}], ["56", {"page_content": "${contentType}:\n    ${fileContents}\n\n    Response:\n\n  `;\n};\n\nexport const createCodeQuestions = (\n  filePath: string,\n  projectName: string,\n  fileContents: string,\n  contentType: string,\n  targetAudience: string,\n): string => {\n  return `\n    You are acting as a ${contentType} documentation expert for a project called ${projectName}.\n    Below is the ${contentType} from a file located at \\`${filePath}\\`. \n    What are 3 questions that a ${targetAudience} might have about this ${contentType}? \n    Answer each question in 1-2 sentences. Output should be in markdown format.\n\n    ${contentType}:\n    ${fileContents}\n\n    Questions and Answers:\n    \n  `;\n};", "metadata": {"source": "autodoc/src/cli/commands/index/prompts.ts"}, "type": "Document"}], ["57", {"page_content": "${contentType}:\n    ${fileContents}\n\n    Questions and Answers:\n    \n  `;\n};\n\nexport const folderSummaryPrompt = (\n  folderPath: string,\n  projectName: string,\n  files: FileSummary[],\n  folders: FolderSummary[],\n  contentType: string,\n  folderPrompt: string,\n): string => {\n  return `\n    You are acting as a ${contentType} documentation expert for a project called ${projectName}.\n    You are currently documenting the folder located at \\`${folderPath}\\`. \n    \n    Below is a list of the files in this folder and a summary of the contents of each file:\n\n    ${files.map((file) => {\n      return `\n        Name: ${file.fileName}\n        Summary: ${file.summary}    \n\n      `;\n    })}\n\n    And here is a list of the subfolders in this folder and a summary of the contents of each subfolder:\n\n    ${folders.map((folder) => {\n      return `\n        Name: ${folder.folderName}\n        Summary: ${folder.summary}    \n\n      `;\n    })}", "metadata": {"source": "autodoc/src/cli/commands/index/prompts.ts"}, "type": "Document"}], ["58", {"page_content": "`;\n    })}\n\n    ${folderPrompt}\n    Do not say \"this file is a part of the ${projectName} project\".\n    Do not just list the files and folders.\n\n    Response:\n  `;\n};", "metadata": {"source": "autodoc/src/cli/commands/index/prompts.ts"}, "type": "Document"}], ["59", {"page_content": "import { OpenAIEmbeddings } from 'langchain/embeddings';\nimport { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';\nimport * as fs from 'fs';\nimport { Document } from 'langchain/document';\nimport { BaseDocumentLoader } from 'langchain/document_loaders';\nimport path from 'path';\nimport { AutodocRepoConfig } from '../../../types.js';\nimport { HNSWLib } from '../../../langchain/hnswlib.js';\n\nasync function processFile(filePath: string): Promise<Document> {\n  return await new Promise<Document>((resolve, reject) => {\n    fs.readFile(filePath, 'utf8', (err, fileContents) => {\n      if (err) {\n        reject(err);\n      } else {\n        const metadata = { source: filePath };\n        const doc = new Document({\n          pageContent: fileContents,\n          metadata: metadata,\n        });\n        resolve(doc);\n      }\n    });\n  });\n}", "metadata": {"source": "autodoc/src/cli/commands/index/createVectorStore.ts"}, "type": "Document"}], ["60", {"page_content": "async function processDirectory(directoryPath: string): Promise<Document[]> {\n  const docs: Document[] = [];\n  let files: string[];\n  try {\n    files = fs.readdirSync(directoryPath);\n  } catch (err) {\n    console.error(err);\n    throw new Error(\n      `Could not read directory: ${directoryPath}. Did you run \\`sh download.sh\\`?`,\n    );\n  }\n  for (const file of files) {\n    const filePath = path.join(directoryPath, file);\n    const stat = fs.statSync(filePath);\n    if (stat.isDirectory()) {\n      const newDocs = processDirectory(filePath);\n      const nestedDocs = await newDocs;\n      docs.push(...nestedDocs);\n    } else {\n      const newDoc = processFile(filePath);\n      const doc = await newDoc;\n      docs.push(doc);\n    }\n  }\n  return docs;\n}\n\nclass RepoLoader extends BaseDocumentLoader {\n  constructor(public filePath: string) {\n    super();\n  }\n  async load(): Promise<Document[]> {\n    return await processDirectory(this.filePath);\n  }\n}", "metadata": {"source": "autodoc/src/cli/commands/index/createVectorStore.ts"}, "type": "Document"}], ["61", {"page_content": "export const createVectorStore = async ({\n  root,\n  output,\n}: AutodocRepoConfig): Promise<void> => {\n  const loader = new RepoLoader(root);\n  const rawDocs = await loader.load();\n  /* Split the text into chunks */\n  const textSplitter = new RecursiveCharacterTextSplitter({\n    chunkSize: 8000,\n    chunkOverlap: 100,\n  });\n  const docs = await textSplitter.splitDocuments(rawDocs);\n  /* Create the vectorstore */\n  const vectorStore = await HNSWLib.fromDocuments(docs, new OpenAIEmbeddings());\n  await vectorStore.save(output);\n};", "metadata": {"source": "autodoc/src/cli/commands/index/createVectorStore.ts"}, "type": "Document"}], ["62", {"page_content": "import chalk from 'chalk';\nimport inquirer from 'inquirer';\nimport fsSync from 'node:fs';\nimport fs from 'node:fs/promises';\nimport { userConfigFileName, userConfigFilePath } from '../../../const.js';\nimport { AutodocUserConfig, LLMModels } from '../../../types.js';\n\nexport const makeConfigTemplate = (\n  config?: AutodocUserConfig,\n): AutodocUserConfig => {\n  return {\n    llms: config?.llms ?? [LLMModels.GPT3],\n  };\n};\n\nexport const user = async (\n  config: AutodocUserConfig = makeConfigTemplate(),\n) => {\n  if (fsSync.existsSync(userConfigFilePath)) {\n    const questions = [\n      {\n        type: 'confirm',\n        name: 'continue',\n        message:\n          'A user configuration already exists. It will be overwritten. Do you want to continue?',\n        default: false,\n      },\n    ];", "metadata": {"source": "autodoc/src/cli/commands/user/index.ts"}, "type": "Document"}], ["63", {"page_content": "const answers = await inquirer.prompt(questions);\n    if (!answers.continue) {\n      process.exit(0);\n    }\n  } else {\n    try {\n      fs.mkdir(userConfigFilePath.replace(userConfigFileName, ''), {\n        recursive: true,\n      });\n    } catch (error) {\n      console.error(error);\n      process.exit(1);\n    }\n  }\n\n  const questions = [\n    {\n      type: 'list',\n      name: 'llms',\n      message: chalk.yellow(\n        `Select which LLMs you have access to (use GPT-3.5 Turbo if you aren't sure):`,\n      ),\n      default: 0,\n      choices: [\n        {\n          name: 'GPT-3.5 Turbo',\n          value: [LLMModels.GPT3],\n        },\n        {\n          name: 'GPT-3.5 Turbo, GPT-4 8K (Early Access)',\n          value: [LLMModels.GPT3, LLMModels.GPT4],\n        },\n        {\n          name: 'GPT-3.5 Turbo, GPT-4 8K (Early Access), GPT-4 32K (Early Access)',\n          value: [LLMModels.GPT3, LLMModels.GPT4, LLMModels.GPT432k],\n        },\n      ],\n    },\n  ];", "metadata": {"source": "autodoc/src/cli/commands/user/index.ts"}, "type": "Document"}], ["64", {"page_content": "const { llms } = await inquirer.prompt(questions);\n\n  const newConfig = makeConfigTemplate({\n    ...config,\n    llms,\n  });\n\n  await fs.writeFile(\n    userConfigFilePath,\n    JSON.stringify(newConfig, null, 2),\n    'utf-8',\n  );\n\n  console.log(\n    chalk.green(\n      'Autodoc user configuration saved. Run `doc q` to start querying.',\n    ),\n  );\n};", "metadata": {"source": "autodoc/src/cli/commands/user/index.ts"}, "type": "Document"}], ["65", {"page_content": "import path from 'path';\nimport { AutodocRepoConfig } from '../../../types.js';\nimport { spinnerSuccess, updateSpinnerText } from '../../spinner.js';\nimport { processRepository } from '../index/processRepository.js';\nimport {\n  printModelDetails,\n  totalIndexCostEstimate,\n} from '../../utils/LLMUtil.js';\nimport chalk from 'chalk';\n\nexport const estimate = async ({\n  name,\n  repositoryUrl,\n  root,\n  output,\n  llms,\n  priority,\n  maxConcurrentCalls,\n  addQuestions,\n  ignore,\n  filePrompt,\n  folderPrompt,\n  chatPrompt,\n  contentType,\n  targetAudience,\n  linkHosted,\n}: AutodocRepoConfig) => {\n  const json = path.join(output, 'docs', 'json/');\n\n  /**\n   * Dry run of the processRepository command\n   * to get the estimated price for indexing the repo\n   */\n  updateSpinnerText('Estimating cost...');", "metadata": {"source": "autodoc/src/cli/commands/estimate/index.ts"}, "type": "Document"}], ["66", {"page_content": "const runDetails = await processRepository(\n    {\n      name,\n      repositoryUrl,\n      root,\n      output: json,\n      llms,\n      priority,\n      maxConcurrentCalls,\n      addQuestions,\n      ignore,\n      filePrompt,\n      folderPrompt,\n      chatPrompt,\n      contentType,\n      targetAudience,\n      linkHosted,\n    },\n    true,\n  );\n  spinnerSuccess();\n\n  /**\n   * Print Results\n   */\n  printModelDetails(Object.values(runDetails));\n  const total = totalIndexCostEstimate(Object.values(runDetails));\n  console.log(\n    chalk.redBright(\n      `Cost estimate to process this repository: $${total.toFixed(\n        2,\n      )}\\nThis is just an estimate. Actual cost may vary.\\nIt recommended that you set a limit in your OpenAI account to prevent unexpected charges.`,\n    ),\n  );\n};", "metadata": {"source": "autodoc/src/cli/commands/estimate/index.ts"}, "type": "Document"}], ["67", {"page_content": "#!/usr/bin/env node\n\nimport fs from 'node:fs/promises';\nimport { Command } from 'commander';\nimport { spinnerError, stopSpinner } from './cli/spinner.js';\nimport { init } from './cli/commands/init/index.js';\nimport { estimate } from './cli/commands/estimate/index.js';\nimport { index } from './cli/commands/index/index.js';\nimport { query } from './cli/commands/query/index.js';\nimport { AutodocRepoConfig, AutodocUserConfig } from './types.js';\nimport inquirer from 'inquirer';\nimport chalk from 'chalk';\nimport { user } from './cli/commands/user/index.js';\nimport { userConfigFilePath } from './const.js';\n\nconst program = new Command();\nprogram.description('Autodoc CLI Tool');\nprogram.version('0.0.9');", "metadata": {"source": "autodoc/src/index.ts"}, "type": "Document"}], ["68", {"page_content": "const program = new Command();\nprogram.description('Autodoc CLI Tool');\nprogram.version('0.0.9');\n\nprogram\n  .command('init')\n  .description(\n    'Initialize repository by creating a `autodoc.config.json` file in the current directory.',\n  )\n  .action(async () => {\n    try {\n      const config: AutodocRepoConfig = JSON.parse(\n        await fs.readFile('./autodoc.config.json', 'utf8'),\n      );\n      init(config);\n    } catch (e) {\n      init();\n    }\n  });\n\nprogram\n  .command('estimate')\n  .description('Estimate the cost of running `index` on your respository.')\n  .action(async () => {\n    try {\n      const config: AutodocRepoConfig = JSON.parse(\n        await fs.readFile('./autodoc.config.json', 'utf8'),\n      );\n      estimate(config);\n    } catch (e) {\n      console.error(\n        'Failed to find `autodoc.config.json` file. Did you run `doc init`?',\n      );\n      console.error(e);\n      process.exit(1);\n    }\n  });", "metadata": {"source": "autodoc/src/index.ts"}, "type": "Document"}], ["69", {"page_content": "program\n  .command('index')\n  .description(\n    'Traverse your codebase, write docs via LLM, and create a locally stored index.',\n  )\n  .action(async () => {\n    try {\n      const config: AutodocRepoConfig = JSON.parse(\n        await fs.readFile('./autodoc.config.json', 'utf8'),\n      );\n\n      await estimate(config);\n\n      const questions = [\n        {\n          type: 'confirm',\n          name: 'continue',\n          message: 'Do you want to continue with indexing?',\n          default: true,\n        },\n      ];\n\n      const answers = await inquirer.prompt(questions);\n\n      if (answers.continue) {\n        console.log(chalk.green('Starting crawl...'));\n        index(config);\n      } else {\n        console.log('Exiting...');\n        process.exit(0);\n      }\n    } catch (e) {\n      console.error(\n        'Failed to find `autodoc.config.json` file. Did you run `doc init`?',\n      );\n      console.error(e);\n      process.exit(1);\n    }\n  });", "metadata": {"source": "autodoc/src/index.ts"}, "type": "Document"}], ["70", {"page_content": "program\n  .command('user')\n  .description('Set the Autodoc user config')\n  .action(async () => {\n    try {\n      const config: AutodocUserConfig = JSON.parse(\n        await fs.readFile(userConfigFilePath, 'utf8'),\n      );\n      user(config);\n    } catch (e) {\n      user();\n    }\n  });\n\nprogram\n  .command('q')\n  .description('Query an Autodoc index')\n  .action(async () => {\n    let repoConfig: AutodocRepoConfig;\n    try {\n      repoConfig = JSON.parse(\n        await fs.readFile('./autodoc.config.json', 'utf8'),\n      );\n    } catch (e) {\n      console.error(\n        'Failed to find `autodoc.config.json` file. Did you run `doc init`?',\n      );\n      console.error(e);\n      process.exit(1);\n    }\n\n    try {\n      const userConfig: AutodocUserConfig = JSON.parse(\n        await fs.readFile(userConfigFilePath, 'utf8'),\n      );", "metadata": {"source": "autodoc/src/index.ts"}, "type": "Document"}], ["71", {"page_content": "query(repoConfig, userConfig);\n    } catch (e) {\n      try {\n        await user();\n        const userConfig: AutodocRepoConfig = JSON.parse(\n          await fs.readFile(userConfigFilePath, 'utf8'),\n        );\n        query(repoConfig, userConfig);\n      } catch (e) {\n        console.error('Failed to config file. Did you run `doc init`?');\n        console.error(e);\n        process.exit(1);\n      }\n    }\n  });\n\n/**\n * Listen for unhandled promise rejections\n */\nprocess.on('unhandledRejection', function (err: Error) {\n  console.error(err.stack);\n\n  spinnerError(); // show an error spinner\n  stopSpinner(); // stop the spinner\n  program.error('', { exitCode: 1 }); // exit with error code 1\n});\n\nprogram.parse();", "metadata": {"source": "autodoc/src/index.ts"}, "type": "Document"}], ["72", {"page_content": "import { OpenAIChat } from 'langchain/llms';\n\nexport type AutodocUserConfig = {\n  llms: LLMModels[];\n};\n\nexport type AutodocRepoConfig = {\n  name: string;\n  repositoryUrl: string;\n  root: string;\n  output: string;\n  llms: LLMModels[];\n  priority: Priority;\n  maxConcurrentCalls: number;\n  addQuestions: boolean;\n  ignore: string[];\n  filePrompt: string;\n  folderPrompt: string;\n  chatPrompt: string;\n  contentType: string;\n  targetAudience: string;\n  linkHosted: boolean;\n};\n\nexport type FileSummary = {\n  fileName: string;\n  filePath: string;\n  url: string;\n  summary: string;\n  questions?: string;\n  checksum: string;\n};\n\nexport type ProcessFileParams = {\n  fileName: string;\n  filePath: string;\n  projectName: string;\n  contentType: string;\n  filePrompt: string;\n  targetAudience: string;\n  linkHosted: boolean;\n};\n\nexport type ProcessFile = (params: ProcessFileParams) => Promise<void>;", "metadata": {"source": "autodoc/src/types.ts"}, "type": "Document"}], ["73", {"page_content": "export type ProcessFile = (params: ProcessFileParams) => Promise<void>;\n\nexport type FolderSummary = {\n  folderName: string;\n  folderPath: string;\n  url: string;\n  files: FileSummary[];\n  folders: FolderSummary[];\n  summary: string;\n  questions: string;\n  checksum: string;\n};\n\nexport type ProcessFolderParams = {\n  inputPath: string;\n  folderName: string;\n  folderPath: string;\n  projectName: string;\n  contentType: string;\n  folderPrompt: string;\n  targetAudience: string;\n  linkHosted: boolean;\n  shouldIgnore: (fileName: string) => boolean;\n};\n\nexport type ProcessFolder = (params: ProcessFolderParams) => Promise<void>;\n\nexport type TraverseFileSystemParams = {\n  inputPath: string;\n  projectName: string;\n  processFile?: ProcessFile;\n  processFolder?: ProcessFolder;\n  ignore: string[];\n  filePrompt: string;\n  folderPrompt: string;\n  contentType: string;\n  targetAudience: string;\n  linkHosted: boolean;\n};", "metadata": {"source": "autodoc/src/types.ts"}, "type": "Document"}], ["74", {"page_content": "export enum LLMModels {\n  GPT3 = 'gpt-3.5-turbo',\n  GPT4 = 'gpt-4',\n  GPT432k = 'gpt-4-32k',\n}\n\nexport type LLMModelDetails = {\n  name: LLMModels;\n  inputCostPer1KTokens: number;\n  outputCostPer1KTokens: number;\n  maxLength: number;\n  llm: OpenAIChat;\n  inputTokens: number;\n  outputTokens: number;\n  succeeded: number;\n  failed: number;\n  total: number;\n};\n\nexport enum Priority {\n  COST = 'cost',\n  PERFORMANCE = 'performance',\n}", "metadata": {"source": "autodoc/src/types.ts"}, "type": "Document"}], ["75", {"page_content": "import fs from 'node:fs/promises';\nimport path from 'node:path';\nimport HierarchicalNSW from 'hnswlib-node';\nimport type {\n  HierarchicalNSW as HierarchicalNSWT,\n  SpaceName,\n} from 'hnswlib-node';\nimport { Document, InMemoryDocstore } from 'langchain/docstore';\nimport { Embeddings } from 'langchain/embeddings';\nimport { SaveableVectorStore } from 'langchain/vectorstores';\n\nexport interface HNSWLibBase {\n  space: SpaceName;\n  numDimensions?: number;\n}\n\nexport interface HNSWLibArgs extends HNSWLibBase {\n  docstore?: InMemoryDocstore;\n  index?: HierarchicalNSWT;\n}\n\nexport class HNSWLib extends SaveableVectorStore {\n  _index?: HierarchicalNSWT;\n\n  docstore: InMemoryDocstore;\n\n  args: HNSWLibBase;\n\n  constructor(embeddings: Embeddings, args: HNSWLibArgs) {\n    super(embeddings, args);\n    this._index = args.index;\n    this.args = args;\n    this.embeddings = embeddings;\n    this.docstore = args?.docstore ?? new InMemoryDocstore();\n  }", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["76", {"page_content": "async addDocuments(documents: Document[]): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents,\n    );\n  }\n\n  private static async getHierarchicalNSW(args: HNSWLibBase) {\n    const { HierarchicalNSW } = await HNSWLib.imports();\n    if (!args.space) {\n      throw new Error('hnswlib-node requires a space argument');\n    }\n    if (args.numDimensions === undefined) {\n      throw new Error('hnswlib-node requires a numDimensions argument');\n    }\n    return new HierarchicalNSW(args.space, args.numDimensions);\n  }\n\n  private async initIndex(vectors: number[][]) {\n    if (!this._index) {\n      if (this.args.numDimensions === undefined) {\n        this.args.numDimensions = vectors[0].length;\n      }\n      this.index = await HNSWLib.getHierarchicalNSW(this.args);\n    }\n    if (!this.index.getCurrentCount()) {\n      this.index.initIndex(vectors.length);\n    }\n  }", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["77", {"page_content": "public get index(): HierarchicalNSWT {\n    if (!this._index) {\n      throw new Error(\n        'Vector store not initialised yet. Try calling `addTexts` first.',\n      );\n    }\n    return this._index;\n  }\n\n  private set index(index: HierarchicalNSWT) {\n    this._index = index;\n  }\n\n  async addVectors(vectors: number[][], documents: Document[]) {\n    if (vectors.length === 0) {\n      return;\n    }\n    await this.initIndex(vectors);", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["78", {"page_content": "// TODO here we could optionally normalise the vectors to unit length\n    // so that dot product is equivalent to cosine similarity, like this\n    // https://github.com/nmslib/hnswlib/issues/384#issuecomment-1155737730\n    // While we only support OpenAI embeddings this isn't necessary\n    if (vectors.length !== documents.length) {\n      throw new Error(`Vectors and metadatas must have the same length`);\n    }\n    if (vectors[0].length !== this.args.numDimensions) {\n      throw new Error(\n        `Vectors must have the same length as the number of dimensions (${this.args.numDimensions})`,\n      );\n    }\n    const capacity = this.index.getMaxElements();\n    const needed = this.index.getCurrentCount() + vectors.length;\n    if (needed > capacity) {\n      this.index.resizeIndex(needed);\n    }\n    const docstoreSize = this.docstore.count;\n    for (let i = 0; i < vectors.length; i += 1) {\n      this.index.addPoint(vectors[i], docstoreSize + i);", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["79", {"page_content": "this.index.addPoint(vectors[i], docstoreSize + i);\n      this.docstore.add({ [docstoreSize + i]: documents[i] });\n    }\n  }", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["80", {"page_content": "async similaritySearchVectorWithScore(query: number[], k: number) {\n    if (query.length !== this.args.numDimensions) {\n      throw new Error(\n        `Query vector must have the same length as the number of dimensions (${this.args.numDimensions})`,\n      );\n    }\n    if (k > this.index.getCurrentCount()) {\n      const total = this.index.getCurrentCount();\n      console.warn(\n        `k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`,\n      );\n      // eslint-disable-next-line no-param-reassign\n      k = total;\n    }\n    const result = this.index.searchKnn(query, k);\n    return result.neighbors.map(\n      (docIndex, resultIndex) =>\n        [\n          this.docstore.search(String(docIndex)),\n          result.distances[resultIndex],\n        ] as [Document, number],\n    );\n  }", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["81", {"page_content": "async save(directory: string) {\n    await fs.mkdir(directory, { recursive: true });\n    await Promise.all([\n      this.index.writeIndex(path.join(directory, 'hnswlib.index')),\n      await fs.writeFile(\n        path.join(directory, 'args.json'),\n        JSON.stringify(this.args),\n      ),\n      await fs.writeFile(\n        path.join(directory, 'docstore.json'),\n        JSON.stringify(Array.from(this.docstore._docs.entries())),\n      ),\n    ]);\n  }\n\n  static async load(directory: string, embeddings: Embeddings) {\n    const args = JSON.parse(\n      await fs.readFile(path.join(directory, 'args.json'), 'utf8'),\n    );\n    const index = await HNSWLib.getHierarchicalNSW(args);\n    const [docstoreFiles] = await Promise.all([\n      fs\n        .readFile(path.join(directory, 'docstore.json'), 'utf8')\n        .then(JSON.parse),\n      index.readIndex(path.join(directory, 'hnswlib.index')),\n    ]);\n    args.docstore = new InMemoryDocstore(new Map(docstoreFiles));\n\n    args.index = index;", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["82", {"page_content": "args.index = index;\n\n    return new HNSWLib(embeddings, args);\n  }\n\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[],\n    embeddings: Embeddings,\n    dbConfig?: {\n      docstore?: InMemoryDocstore;\n    },\n  ): Promise<HNSWLib> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata: metadatas[i],\n      });\n      docs.push(newDoc);\n    }\n    return HNSWLib.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: Embeddings,\n    dbConfig?: {\n      docstore?: InMemoryDocstore;\n    },\n  ): Promise<HNSWLib> {\n    const args: HNSWLibArgs = {\n      docstore: dbConfig?.docstore,\n      space: 'cosine',\n    };\n    const instance = new this(embeddings, args);\n    await instance.addDocuments(docs);\n    return instance;\n  }", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["83", {"page_content": "static async imports(): Promise<{\n    HierarchicalNSW: typeof HierarchicalNSWT;\n  }> {\n    return HierarchicalNSW;\n  }\n}", "metadata": {"source": "autodoc/src/langchain/hnswlib.ts"}, "type": "Document"}], ["84", {"page_content": "{\n  \"name\": \"@context-labs/autodoc\",\n  \"version\": \"0.0.9\",\n  \"description\": \"autodoc\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.js\",\n  \"exports\": {\n    \".\": \"./dist/src/index.js\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"dev\": \"npm run build && npm install -g .\",\n    \"clean\": \"rm -rf dist\"\n  },\n  \"bin\": {\n    \"doc\": \"./dist/index.js\"\n  },\n  \"prettier\": {\n    \"printWidth\": 80,\n    \"trailingComma\": \"all\",\n    \"singleQuote\": true\n  },\n  \"repository\": \"https://github.com/context-labs\",\n  \"author\": \"sam@usecontext.io\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"@dqbd/tiktoken\": \"^1.0.2\",\n    \"@types/istextorbinary\": \"^2.3.1\",\n    \"chalk\": \"^5.2.0\",\n    \"cli-progress\": \"^3.12.0\",\n    \"commander\": \"^10.0.0\",\n    \"esbuild\": \"^0.17.12\",\n    \"hnswlib-node\": \"^1.4.2\",\n    \"inquirer\": \"^9.1.5\",\n    \"istextorbinary\": \"^6.0.0\",\n    \"langchain\": \"^0.0.39\",\n    \"marked\": \"^4.3.0\",\n    \"marked-terminal\": \"^5.1.1\",\n    \"minimatch\": \"^7.4.3\",", "metadata": {"source": "autodoc/package.json"}, "type": "Document"}], ["85", {"page_content": "\"marked\": \"^4.3.0\",\n    \"marked-terminal\": \"^5.1.1\",\n    \"minimatch\": \"^7.4.3\",\n    \"ora\": \"^6.2.0\",\n    \"ts-md5\": \"^1.3.1\"\n  },\n  \"devDependencies\": {\n    \"@types/commander\": \"^2.12.2\",\n    \"@types/figlet\": \"^1.5.5\",\n    \"@types/inquirer\": \"^9.0.3\",\n    \"@types/marked\": \"^4.0.8\",\n    \"@types/marked-terminal\": \"^3.1.3\",\n    \"@types/node\": \"^18.15.5\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.37.0\",\n    \"@typescript-eslint/parser\": \"^5.37.0\",\n    \"eslint\": \"^7.32.0\",\n    \"eslint-config-next\": \"^13.1.4\",\n    \"eslint-config-prettier\": \"^8.5.0\",\n    \"eslint-plugin-prettier\": \"^4.0.0\",\n    \"eslint-plugin-react\": \"^7.25.1\",\n    \"eslint-plugin-react-hooks\": \"^4.2.0\",\n    \"prettier\": \"^2.7.1\",\n    \"typescript\": \"^4.8.3\"\n  }\n}", "metadata": {"source": "autodoc/package.json"}, "type": "Document"}], ["86", {"page_content": "{\n  \"compilerOptions\": {\n    \"rootDir\": \"src\",\n    \"outDir\": \"dist\",\n    \"strict\": true,\n    \"target\": \"es2020\",\n    \"module\": \"ES2020\",\n    \"sourceMap\": true,\n    \"esModuleInterop\": true,\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"declaration\": true,\n    \"skipLibCheck\": true,\n  }\n}", "metadata": {"source": "autodoc/tsconfig.json"}, "type": "Document"}], ["87", {"page_content": "<h1 align=\"center\">\n  <br>\n  <a href=\"https://github.com/context-labs/autodoc\"><img src=\"https://raw.githubusercontent.com/context-labs/autodoc/master/assets/autodoc.png\" alt=\"Markdownify\" width=\"200\" style=\"border-radius:8px;\"></a>\n  <br>\nAutodoc\n  <br>\n</h1>", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["88", {"page_content": "<h4 align=\"center\">\u26a1 Toolkit for auto-generating codebase documentation using LLMs \u26a1</h4>\n<p align=\"center\">\n<a href=\"https://opensource.org/licenses/MIT\">\n\t  <img alt=\"Twitter URL\" src=\"https://img.shields.io/badge/License-MIT-yellow.svg\">\n  </a>\n\t<a href=\"https://www.npmjs.com/package/@context-labs/autodoc\">\n\t  <img alt=\"NPM Package\" src=\"https://badge.fury.io/js/@context-labs%2Fautodoc.svg\">\n  </a>\n  <a href=\"https://twitter.com/autodoc_\">\n\t  <img alt=\"Twitter URL\" src=\"https://img.shields.io/twitter/url?label=Follow%20%40autodoc_&style=social&url=https%3A%2F%2Ftwitter.com%2Fautodoc_\">\n\t  <a href=\"https://discord.com/invite/zpFEXXWSNg\">\n\t  <img alt=\"Discord Server\" src=\"https://dcbadge.vercel.app/api/server/zpFEXXWSNg?compact=true&style=flat\">\n  </a>\n</p>\n\n<p align=\"center\">\n  <a href=\"#what-is-this\">What is this?</a> \u2022\n  <a href=\"#get-started\">Get Started</a> \u2022\n  <a href=\"#community\">Community</a> \u2022\n  <a href=\"#contributing\">Contribute</a>\n</p>", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["89", {"page_content": "## What is this?\nAutodoc is a **experimental** toolkit for auto-generating codebase documentation for git repositories using Large Language Models, like [GPT-4](https://openai.com/research/gpt-4) or [Alpaca](https://github.com/ggerganov/llama.cpp). Autodoc can be [installed](#get-started) in your repo in about 5 minutes. It indexes your codebase through a depth-first traversal of all repository contents and calls an LLM to write documentation for each file and folder. These documents can be combined to describe the different components of your system and how they work together. \n\nThe generated documentation lives in your codebase, and travels where your code travels. Developers who download your code can use the `doc` command to ask questions about your codebase and get highly specific answers with reference links back to code files.", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["90", {"page_content": "In the near future, documentation will be re-indexed as part your CI pipeline, so it is always up-to-date. If your interested in working contributing to this work, see [this issue](https://github.com/context-labs/autodoc/issues/7).\n\n\n### Status\nAutodoc is in the early stages of development. It is functional, but not ready for production use. Things may break, or not work as expected. If you're interested in working on the core Autodoc framework, please see [contributing](#contributing). We would love to have your help!\n\n### FAQs\n**Question:** I'm not getting good responses. How can I improve response quality?", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["91", {"page_content": "### FAQs\n**Question:** I'm not getting good responses. How can I improve response quality?\n\n**Answer:** Autodoc is in the early stages of development. As such, the response quality can vary widely based on the type of project your indexing and how questions are phrased. A few tips to writing good query:\n1. Be specific with your questions. Ask things like \"What are the different components of authorization in this system?\" rather than \"explain auth\". This will help Autodoc select the right context to get the best answer for your question.\n2. Use GPT-4. GPT-4 is substantially better at understanding code compared to GPT-3.5 and this understanding carries over into writing good documentation as well. If you don't have access, sign up [here](https://openai.com/waitlist/gpt-4-api).", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["92", {"page_content": "### Examples\nBelow are a few examples of how Autodoc can be used. \n1. [Autodoc](https://github.com/context-labs/autodoc) - This repository contains documentation for itself, generated by Autodoc. It lives in the `.autodoc` folder. Follow the instructions [here](#querying) to learn how to query it.\n2. [TolyGPT.com](https://tolygpt.com) - TolyGPT is an Autodoc chatbot trained on the [Solana validator](https://github.com/solana-labs/solana) codebase and deployed to the web for easy access. In the near future, Autodoc will support a web version in addition to the existing CLI tool.\n\n## Get Started\n\n#### Requirements\nAutodoc requires Node v18.0.0 or greater. v19.0.0 or greater is recommended. Make sure you're running the proper version:\n\n```bash\n$ node -v\n```\n\nExample output:\n```bash\nv19.8.1\n```\n\nInstall the Autodoc CLI tool as a global NPM module:", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["93", {"page_content": "Example output:\n```bash\nv19.8.1\n```\n\nInstall the Autodoc CLI tool as a global NPM module:\n\n```bash\n$ npm install -g @context-labs/autodoc\n```\nThis command installs the Autodoc CLI tool that will allow you to create and query Autodoc indexes.\n\nRun `doc` to see the available commands.\n\n### Querying\nYou can query a repository that has Autodoc installed via the CLI. We'll use the Autodoc repository itself as an example to demonstrate how querying in Autodoc works, but this could be your own repository that contains an index.\n\nClone Autodoc and change directory to get started:\n\n```bash \n$ git clone https://github.com/context-labs/autodoc.git\n$ cd autodoc\n```\n\nRight now Autodoc only supports OpenAI. Make sure you have have your OpenAI API key exported in your current session:\n\n```bash\n$ export OPENAI_API_KEY=<YOUR_KEY_HERE>\n```\n\nTo start the Autodoc query CLI, run:\n\n```bash\n$ doc q\n```", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["94", {"page_content": "To start the Autodoc query CLI, run:\n\n```bash\n$ doc q\n```\n\nIf this is your first time running `doc q`, you'll get a screen that prompts you to select which GPT models you have access to. Select whichever is appropriate for your level of access. If you aren't sure, select the first option:\n\n<img src=\"https://raw.githubusercontent.com/context-labs/autodoc/master/assets/select-models.png\" alt=\"Markdownify\" width=\"60%\" style=\"border-radius:24px;\">\n\nYou're now ready to query documentation for the Autodoc repository:\n\n<img src=\"https://raw.githubusercontent.com/context-labs/autodoc/master/assets/query.gif\" alt=\"Markdownify\" width=\"60%\" style=\"border-radius:24px;\">\n\nThis is the core querying experience. It's very basic right now, with plenty of room of improvement. If you're interested in improving the Autodoc CLI querying experience, checkout [this issue](https://github.com/context-labs/autodoc/issues/11).", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["95", {"page_content": "### Indexing\nFollow the steps below to generate documentation for your own repository using Autodoc.\n\nChange directory into the root of your project:\n```bash\ncd $PROJECT_ROOT\n```\nMake sure your OpenAI API key is available in the current session:\n\n```bash\n$ export OPENAI_API_KEY=<YOUR_KEY_HERE>\n```\n\nRun the `init` command:\n```\ndoc init\n```\nYou will be prompted to enter the name of your project, GitHub url, and select which GPT models you have access to. If you aren't sure which models you have access to, select the first option. You can also specify your own GPT file/directory prompts that will be used to summarize/analyze the code repoThis command will generate an `autodoc.config.json` file in the root of your project to store the values. This file should be checked in to git.\n\n**Note:** Do not skip entering these values or indexing may not work.", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["96", {"page_content": "**Note:** Do not skip entering these values or indexing may not work.\n\n**Prompt Configuration:** You'll find prompt directions specified in `prompts.ts`, with some snippets customizable in the `autodoc.config.json`. The current prompts are developer focused and assume your repo is code focused. We will have more reference templates in the future.\n\nRun the `index` command:\n```bash\ndoc index\n```\n\nYou should see a screen like this:\n\n<img src=\"https://raw.githubusercontent.com/context-labs/autodoc/master/assets/index-estimate.png\" alt=\"Markdownify\" width=\"60%\" style=\"border-radius:24px;\">\n\nThis screen estimates the cost of indexing your repository. You can also access this screen via the `doc estimate` command. If you've already indexed once, then `doc index` will only reindex files that have been changed on the second go.", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["97", {"page_content": "For every file in your project, Autodoc calculates the number of tokens in the file based on the file content. The more lines of code, the larger the number of tokens. Using this number, it determine which model it will use on per file basis, always choosing the cheapest model whose context length supports the number of tokens in the file. If you're interested in helping make model selection configurable in Autodoc, check out [this issue](https://github.com/context-labs/autodoc/issues/9).\n\n**Note:** This naive model selection strategy means that files under ~4000 tokens will be documented using GPT-3.5, which will result in less accurate documentation. **We recommend using GPT-4 8K at a minimum.** Indexing with GPT-4 results in significantly better output. You can apply for access [here](https://openai.com/waitlist/gpt-4-api).\n\nFor large projects, the cost can be several hundred dollars. View OpenAI pricing [here](https://openai.com/pricing).", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["98", {"page_content": "In the near future, we will support self-hosted models, such as [Llama](https://github.com/facebookresearch/llama) and [Alpaca](https://github.com/tatsu-lab/stanford_alpaca). Read [this issue](https://github.com/context-labs/autodoc/issues/8) if you're interesting in contributing to this work.\n\nWhen your repository is done being indexed, you should see a screen like this:\n\n<img src=\"https://raw.githubusercontent.com/context-labs/autodoc/master/assets/index-finished.png\" alt=\"Markdownify\" width=\"60%\" style=\"border-radius:24px;\">\n\nYou can now query your application using the steps outlined in [querying](#querying).\n\n## Community\nThere is a small group of us that are working full time on Autodoc. Join us on [Discord](https://discord.gg/zpFEXXWSNg), or follow us on [Twitter](https://twitter.com/autodoc_) for updates. We'll be posting regularly and continuing to improve the Autodoc application. Want to contribute? Read below.\n\n\n## Contributing", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["99", {"page_content": "## Contributing\n\nAs an open source project in a rapidly developing field, we are extremely open to contributions, whether it be in the form of a new feature, improved infra, or better documentation.\n\nFor detailed information on how to contribute, see [here](.github/CONTRIBUTING.md).", "metadata": {"source": "autodoc/README.md"}, "type": "Document"}], ["100", {"page_content": "{\n  \"name\": \"autodoc\",\n  \"repositoryUrl\": \"https://github.com/context-labs/autodoc\",\n  \"root\": \".\",\n  \"output\": \"./.autodoc\",\n  \"llms\": [\n    \"gpt-4\"\n  ],\n  \"ignore\": [\n    \".*\",\n    \"*package-lock.json\",\n    \"*package.json\",\n    \"node_modules\",\n    \"*dist*\",\n    \"*build*\",\n    \"*test*\",\n    \"*.svg\",\n    \"*.md\",\n    \"*.mdx\",\n    \"*.toml\",\n    \"*autodoc*\"\n  ],\n  \"filePrompt\": \"Write a detailed technical explanation of what this code does. \\n      Focus on the high-level purpose of the code and how it may be used in the larger project.\\n      Include code examples where appropriate. Keep you response between 100 and 300 words. \\n      DO NOT RETURN MORE THAN 300 WORDS.\\n      Output should be in markdown format.\\n      Do not just list the methods and classes in this file.\",", "metadata": {"source": "autodoc/autodoc.config.json"}, "type": "Document"}], ["101", {"page_content": "\"folderPrompt\": \"Write a technical explanation of what the code in this file does\\n      and how it might fit into the larger project or work with other parts of the project.\\n      Give examples of how this code might be used. Include code examples where appropriate.\\n      Be concise. Include any information that may be relevant to a developer who is curious about this code.\\n      Keep you response under 400 words. Output should be in markdown format.\\n      Do not just list the files and folders in this folder.\",\n  \"chatPrompt\": \"\",\n  \"contentType\": \"code\",\n  \"targetAudience\": \"smart developer\",\n  \"linkHosted\": true\n}", "metadata": {"source": "autodoc/autodoc.config.json"}, "type": "Document"}], ["102", {"page_content": "{\n  \"name\": \"@context-labs/autodoc\",\n  \"version\": \"0.0.9\",\n  \"lockfileVersion\": 2,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"@context-labs/autodoc\",\n      \"version\": \"0.0.9\",\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@dqbd/tiktoken\": \"^1.0.2\",\n        \"@types/istextorbinary\": \"^2.3.1\",\n        \"chalk\": \"^5.2.0\",\n        \"cli-progress\": \"^3.12.0\",\n        \"commander\": \"^10.0.0\",\n        \"esbuild\": \"^0.17.12\",\n        \"hnswlib-node\": \"^1.4.2\",\n        \"inquirer\": \"^9.1.5\",\n        \"istextorbinary\": \"^6.0.0\",\n        \"langchain\": \"^0.0.39\",\n        \"marked\": \"^4.3.0\",\n        \"marked-terminal\": \"^5.1.1\",\n        \"minimatch\": \"^7.4.3\",\n        \"ora\": \"^6.2.0\",\n        \"ts-md5\": \"^1.3.1\"\n      },\n      \"bin\": {\n        \"doc\": \"dist/index.js\"\n      },\n      \"devDependencies\": {\n        \"@types/commander\": \"^2.12.2\",\n        \"@types/figlet\": \"^1.5.5\",\n        \"@types/inquirer\": \"^9.0.3\",\n        \"@types/marked\": \"^4.0.8\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["103", {"page_content": "\"@types/inquirer\": \"^9.0.3\",\n        \"@types/marked\": \"^4.0.8\",\n        \"@types/marked-terminal\": \"^3.1.3\",\n        \"@types/node\": \"^18.15.5\",\n        \"@typescript-eslint/eslint-plugin\": \"^5.37.0\",\n        \"@typescript-eslint/parser\": \"^5.37.0\",\n        \"eslint\": \"^7.32.0\",\n        \"eslint-config-next\": \"^13.1.4\",\n        \"eslint-config-prettier\": \"^8.5.0\",\n        \"eslint-plugin-prettier\": \"^4.0.0\",\n        \"eslint-plugin-react\": \"^7.25.1\",\n        \"eslint-plugin-react-hooks\": \"^4.2.0\",\n        \"prettier\": \"^2.7.1\",\n        \"typescript\": \"^4.8.3\"\n      }\n    },\n    \"node_modules/@babel/code-frame\": {\n      \"version\": \"7.12.11\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.12.11.tgz\",\n      \"integrity\": \"sha512-Zt1yodBx1UcyiePMSkWnU4hPqhwq7hGi2nFL1LeA3EUl+q2LQx16MISgJ0+z7dnmgvP9QtIleuETGOiOH1RcIw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/highlight\": \"^7.10.4\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["104", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"@babel/highlight\": \"^7.10.4\"\n      }\n    },\n    \"node_modules/@babel/helper-validator-identifier\": {\n      \"version\": \"7.19.1\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.19.1.tgz\",\n      \"integrity\": \"sha512-awrNfaMtnHUr653GgGEs++LlAvW6w+DcPrOliSMXWCKo597CwL5Acf/wWdNkf/tfEQE3mjkeD1YOVZOUV/od1w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/highlight\": {\n      \"version\": \"7.18.6\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/highlight/-/highlight-7.18.6.tgz\",\n      \"integrity\": \"sha512-u7stbOuYjaPezCuLj29hNW1v64M2Md2qupEKP1fHc7WdOA3DgLh37suiSrZYY7haUB7iBeQZ9P1uiRF359do3g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/helper-validator-identifier\": \"^7.18.6\",\n        \"chalk\": \"^2.0.0\",\n        \"js-tokens\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=6.9.0\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["105", {"page_content": "\"js-tokens\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=6.9.0\"\n      }\n    },\n    \"node_modules/@babel/highlight/node_modules/ansi-styles\": {\n      \"version\": \"3.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz\",\n      \"integrity\": \"sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-convert\": \"^1.9.0\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/@babel/highlight/node_modules/chalk\": {\n      \"version\": \"2.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz\",\n      \"integrity\": \"sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ansi-styles\": \"^3.2.1\",\n        \"escape-string-regexp\": \"^1.0.5\",\n        \"supports-color\": \"^5.3.0\"\n      },\n      \"engines\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["106", {"page_content": "\"supports-color\": \"^5.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/@babel/highlight/node_modules/color-convert\": {\n      \"version\": \"1.9.3\",\n      \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz\",\n      \"integrity\": \"sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-name\": \"1.1.3\"\n      }\n    },\n    \"node_modules/@babel/highlight/node_modules/color-name\": {\n      \"version\": \"1.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz\",\n      \"integrity\": \"sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==\",\n      \"dev\": true\n    },\n    \"node_modules/@babel/highlight/node_modules/escape-string-regexp\": {\n      \"version\": \"1.0.5\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["107", {"page_content": "\"node_modules/@babel/highlight/node_modules/escape-string-regexp\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz\",\n      \"integrity\": \"sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.8.0\"\n      }\n    },\n    \"node_modules/@babel/runtime\": {\n      \"version\": \"7.21.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/runtime/-/runtime-7.21.0.tgz\",\n      \"integrity\": \"sha512-xwII0//EObnq89Ji5AKYQaRYiW/nZ3llSv29d49IuxPhKbtJoLP+9QUUZ4nVragQVtaVGeZrpB+ZtG/Pdy/POw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"regenerator-runtime\": \"^0.13.11\"\n      },\n      \"engines\": {\n        \"node\": \">=6.9.0\"\n      }\n    },\n    \"node_modules/@colors/colors\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/@colors/colors/-/colors-1.5.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["108", {"page_content": "\"resolved\": \"https://registry.npmjs.org/@colors/colors/-/colors-1.5.0.tgz\",\n      \"integrity\": \"sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==\",\n      \"optional\": true,\n      \"engines\": {\n        \"node\": \">=0.1.90\"\n      }\n    },\n    \"node_modules/@dqbd/tiktoken\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@dqbd/tiktoken/-/tiktoken-1.0.2.tgz\",\n      \"integrity\": \"sha512-AjGTBRWsMoVmVeN55NLyupyM8TNamOUBl6tj5t/leLDVup3CFGO9tVagNL1jf3GyZLkWZSTmYVbPQ/M2LEcNzw==\"\n    },\n    \"node_modules/@esbuild/android-arm\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.17.12.tgz\",\n      \"integrity\": \"sha512-E/sgkvwoIfj4aMAPL2e35VnUJspzVYl7+M1B2cqeubdBhADV4uPon0KCc8p2G+LqSJ6i8ocYPCqY3A4GGq0zkQ==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["109", {"page_content": "\"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/android-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-WQ9p5oiXXYJ33F2EkE3r0FRDFVpEdcDiwNX3u7Xaibxfx6vQE0Sb8ytrfQsA5WO6kDn6mDfKLh6KrPBjvkk7xA==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/android-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-m4OsaCr5gT+se25rFPHKQXARMyAehHTQAz4XX1Vk3d27VtqiX0ALMBPoXZsGaB6JYryCLfgGwUslMqTfqeLU0w==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["110", {"page_content": "\"os\": [\n        \"android\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/darwin-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-O3GCZghRIx+RAN0NDPhyyhRgwa19MoKlzGonIb5hgTj78krqp9XZbYCvFr9N1eUxg0ZQEpiiZ4QvsOQwBpP+lg==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/darwin-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-5D48jM3tW27h1qjaD9UNRuN+4v0zvksqZSPZqeSWggfMlsVdAhH3pwSfQIFJwcs9QJ9BRibPS4ViZgs3d2wsCA==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["111", {"page_content": "\"os\": [\n        \"darwin\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/freebsd-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-OWvHzmLNTdF1erSvrfoEBGlN94IE6vCEaGEkEH29uo/VoONqPnoDFfShi41Ew+yKimx4vrmmAJEGNoyyP+OgOQ==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/freebsd-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-A0Xg5CZv8MU9xh4a+7NUpi5VHBKh1RaGJKqjxe4KG87X+mTjDE6ZvlJqpWoeJxgfXHT7IMP9tDFu7IZ03OtJAw==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"freebsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["112", {"page_content": "\"os\": [\n        \"freebsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-arm\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.17.12.tgz\",\n      \"integrity\": \"sha512-WsHyJ7b7vzHdJ1fv67Yf++2dz3D726oO3QCu8iNYik4fb5YuuReOI9OtA+n7Mk0xyQivNTPbl181s+5oZ38gyA==\",\n      \"cpu\": [\n        \"arm\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-cK3AjkEc+8v8YG02hYLQIQlOznW+v9N+OI9BAFuyqkfQFR+DnDLhEM5N8QRxAUz99cJTo1rLNXqRrvY15gbQUg==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["113", {"page_content": "\"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-ia32\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.17.12.tgz\",\n      \"integrity\": \"sha512-jdOBXJqcgHlah/nYHnj3Hrnl9l63RjtQ4vn9+bohjQPI2QafASB5MtHAoEv0JQHVb/xYQTFOeuHnNYE1zF7tYw==\",\n      \"cpu\": [\n        \"ia32\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-loong64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.17.12.tgz\",\n      \"integrity\": \"sha512-GTOEtj8h9qPKXCyiBBnHconSCV9LwFyx/gv3Phw0pa25qPYjVuuGZ4Dk14bGCfGX3qKF0+ceeQvwmtI+aYBbVA==\",\n      \"cpu\": [\n        \"loong64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["114", {"page_content": "\"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-mips64el\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.17.12.tgz\",\n      \"integrity\": \"sha512-o8CIhfBwKcxmEENOH9RwmUejs5jFiNoDw7YgS0EJTF6kgPgcqLFjgoc5kDey5cMHRVCIWc6kK2ShUePOcc7RbA==\",\n      \"cpu\": [\n        \"mips64el\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-ppc64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.17.12.tgz\",\n      \"integrity\": \"sha512-biMLH6NR/GR4z+ap0oJYb877LdBpGac8KfZoEnDiBKd7MD/xt8eaw1SFfYRUeMVx519kVkAOL2GExdFmYnZx3A==\",\n      \"cpu\": [\n        \"ppc64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["115", {"page_content": "\"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-riscv64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.17.12.tgz\",\n      \"integrity\": \"sha512-jkphYUiO38wZGeWlfIBMB72auOllNA2sLfiZPGDtOBb1ELN8lmqBrlMiucgL8awBw1zBXN69PmZM6g4yTX84TA==\",\n      \"cpu\": [\n        \"riscv64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-s390x\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.17.12.tgz\",\n      \"integrity\": \"sha512-j3ucLdeY9HBcvODhCY4b+Ds3hWGO8t+SAidtmWu/ukfLLG/oYDMaA+dnugTVAg5fnUOGNbIYL9TOjhWgQB8W5g==\",\n      \"cpu\": [\n        \"s390x\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["116", {"page_content": "\"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/linux-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-uo5JL3cgaEGotaqSaJdRfFNSCUJOIliKLnDGWaVCgIKkHxwhYMm95pfMbWZ9l7GeW9kDg0tSxcy9NYdEtjwwmA==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"linux\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/netbsd-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-DNdoRg8JX+gGsbqt2gPgkgb00mqOgOO27KnrWZtdABl6yWTST30aibGJ6geBq3WM2TIeW6COs5AScnC7GwtGPg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"netbsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["117", {"page_content": "\"os\": [\n        \"netbsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/openbsd-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-aVsENlr7B64w8I1lhHShND5o8cW6sB9n9MUtLumFlPhG3elhNWtE7M1TFpj3m7lT3sKQUMkGFjTQBrvDDO1YWA==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"openbsd\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/sunos-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-qbHGVQdKSwi0JQJuZznS4SyY27tYXYF0mrgthbxXrZI3AHKuRvU+Eqbg/F0rmLDpW/jkIZBlCO1XfHUBMNJ1pg==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"sunos\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["118", {"page_content": "\"os\": [\n        \"sunos\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/win32-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-zsCp8Ql+96xXTVTmm6ffvoTSZSV2B/LzzkUXAY33F/76EajNw1m+jZ9zPfNJlJ3Rh4EzOszNDHsmG/fZOhtqDg==\",\n      \"cpu\": [\n        \"arm64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/win32-ia32\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.17.12.tgz\",\n      \"integrity\": \"sha512-FfrFjR4id7wcFYOdqbDfDET3tjxCozUgbqdkOABsSFzoZGFC92UK7mg4JKRc/B3NNEf1s2WHxJ7VfTdVDPN3ng==\",\n      \"cpu\": [\n        \"ia32\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["119", {"page_content": "\"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@esbuild/win32-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-JOOxw49BVZx2/5tW3FqkdjSD/5gXYeVGPDcB0lvap0gLQshkh1Nyel1QazC+wNxus3xPlsYAgqU1BUmrmCvWtw==\",\n      \"cpu\": [\n        \"x64\"\n      ],\n      \"optional\": true,\n      \"os\": [\n        \"win32\"\n      ],\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/@eslint-community/eslint-utils\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.3.0.tgz\",\n      \"integrity\": \"sha512-v3oplH6FYCULtFuCeqyuTd9D2WKO937Dxdq+GmHOLL72TTRriLxz2VLlNfkZRsvj6PKnOPAtuT6dwrs/pA5DvA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"eslint-visitor-keys\": \"^3.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["120", {"page_content": "},\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^6.0.0 || ^7.0.0 || >=8.0.0\"\n      }\n    },\n    \"node_modules/@eslint-community/regexpp\": {\n      \"version\": \"4.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.4.1.tgz\",\n      \"integrity\": \"sha512-BISJ6ZE4xQsuL/FmsyRaiffpq977bMlsKfGHTQrOGFErfByxIe6iZTxPf/00Zon9b9a7iUykfQwejN3s2ZW/Bw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^12.0.0 || ^14.0.0 || >=16.0.0\"\n      }\n    },\n    \"node_modules/@eslint/eslintrc\": {\n      \"version\": \"0.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.4.3.tgz\",\n      \"integrity\": \"sha512-J6KFFz5QCYUJq3pf0mjEcCJVERbzv71PUIDczuh9JkwGEzced6CO5ADLHB1rbf/+oPBtoPfMYNOpGDzCANlbXw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ajv\": \"^6.12.4\",\n        \"debug\": \"^4.1.1\",\n        \"espree\": \"^7.3.0\",\n        \"globals\": \"^13.9.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["121", {"page_content": "\"debug\": \"^4.1.1\",\n        \"espree\": \"^7.3.0\",\n        \"globals\": \"^13.9.0\",\n        \"ignore\": \"^4.0.6\",\n        \"import-fresh\": \"^3.2.1\",\n        \"js-yaml\": \"^3.13.1\",\n        \"minimatch\": \"^3.0.4\",\n        \"strip-json-comments\": \"^3.1.1\"\n      },\n      \"engines\": {\n        \"node\": \"^10.12.0 || >=12.0.0\"\n      }\n    },\n    \"node_modules/@eslint/eslintrc/node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/@eslint/eslintrc/node_modules/ignore\": {\n      \"version\": \"4.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["122", {"page_content": "\"version\": \"4.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",\n      \"integrity\": \"sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 4\"\n      }\n    },\n    \"node_modules/@eslint/eslintrc/node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/@humanwhocodes/config-array\": {\n      \"version\": \"0.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.5.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["123", {"page_content": "\"integrity\": \"sha512-FagtKFz74XrTl7y6HCzQpwDfXP0yhxe9lHLD1UZxjvZIcbyRz8zTFF/yYNfSfzU414eDwZ1SrO0Qvtyf+wFMQg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@humanwhocodes/object-schema\": \"^1.2.0\",\n        \"debug\": \"^4.1.1\",\n        \"minimatch\": \"^3.0.4\"\n      },\n      \"engines\": {\n        \"node\": \">=10.10.0\"\n      }\n    },\n    \"node_modules/@humanwhocodes/config-array/node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/@humanwhocodes/config-array/node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["124", {"page_content": "\"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/@humanwhocodes/object-schema\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz\",\n      \"integrity\": \"sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==\",\n      \"dev\": true\n    },\n    \"node_modules/@next/eslint-plugin-next\": {\n      \"version\": \"13.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/@next/eslint-plugin-next/-/eslint-plugin-next-13.2.4.tgz\",\n      \"integrity\": \"sha512-ck1lI+7r1mMJpqLNa3LJ5pxCfOB1lfJncKmRJeJxcJqcngaFwylreLP7da6Rrjr6u2gVRTfmnkSkjc80IiQCwQ==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["125", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"glob\": \"7.1.7\"\n      }\n    },\n    \"node_modules/@nodelib/fs.scandir\": {\n      \"version\": \"2.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz\",\n      \"integrity\": \"sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@nodelib/fs.stat\": \"2.0.5\",\n        \"run-parallel\": \"^1.1.9\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/@nodelib/fs.stat\": {\n      \"version\": \"2.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz\",\n      \"integrity\": \"sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/@nodelib/fs.walk\": {\n      \"version\": \"1.2.8\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["126", {"page_content": "}\n    },\n    \"node_modules/@nodelib/fs.walk\": {\n      \"version\": \"1.2.8\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz\",\n      \"integrity\": \"sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@nodelib/fs.scandir\": \"2.1.5\",\n        \"fastq\": \"^1.6.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/@pkgr/utils\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/@pkgr/utils/-/utils-2.3.1.tgz\",\n      \"integrity\": \"sha512-wfzX8kc1PMyUILA+1Z/EqoE4UCXGy0iRGMhPwdfae1+f0OXlLqCk+By+aMzgJBzR9AzS4CDizioG6Ss1gvAFJw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"cross-spawn\": \"^7.0.3\",\n        \"is-glob\": \"^4.0.3\",\n        \"open\": \"^8.4.0\",\n        \"picocolors\": \"^1.0.0\",\n        \"tiny-glob\": \"^0.2.9\",\n        \"tslib\": \"^2.4.0\"\n      },\n      \"engines\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["127", {"page_content": "\"tiny-glob\": \"^0.2.9\",\n        \"tslib\": \"^2.4.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.18.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/unts\"\n      }\n    },\n    \"node_modules/@rushstack/eslint-patch\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/@rushstack/eslint-patch/-/eslint-patch-1.2.0.tgz\",\n      \"integrity\": \"sha512-sXo/qW2/pAcmT43VoRKOJbDOfV3cYpq3szSVfIThQXNt+E4DfKj361vaAt3c88U5tPUxzEswam7GW48PJqtKAg==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/commander\": {\n      \"version\": \"2.12.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/commander/-/commander-2.12.2.tgz\",\n      \"integrity\": \"sha512-0QEFiR8ljcHp9bAbWxecjVRuAMr16ivPiGOw6KFQBVrVd0RQIcM3xKdRisH2EDWgVWujiYtHwhSkSUoAAGzH7Q==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["128", {"page_content": "\"deprecated\": \"This is a stub types definition for commander (https://github.com/tj/commander.js). commander provides its own type definitions, so you don't need @types/commander installed!\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"commander\": \"*\"\n      }\n    },\n    \"node_modules/@types/figlet\": {\n      \"version\": \"1.5.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/figlet/-/figlet-1.5.5.tgz\",\n      \"integrity\": \"sha512-0sMBeFoqdGgdXoR/hgKYSWMpFufSpToosNsI2VgmkPqZJgeEXsXNu2hGr0FN401dBro2tNO5y2D6uw3UxVaxbg==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/inquirer\": {\n      \"version\": \"9.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/inquirer/-/inquirer-9.0.3.tgz\",\n      \"integrity\": \"sha512-CzNkWqQftcmk2jaCWdBTf9Sm7xSw4rkI1zpU/Udw3HX5//adEZUIm9STtoRP1qgWj0CWQtJ9UTvqmO2NNjhMJw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/through\": \"*\",\n        \"rxjs\": \"^7.2.0\"\n      }\n    },\n    \"node_modules/@types/istextorbinary\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["129", {"page_content": "\"rxjs\": \"^7.2.0\"\n      }\n    },\n    \"node_modules/@types/istextorbinary\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/@types/istextorbinary/-/istextorbinary-2.3.1.tgz\",\n      \"integrity\": \"sha512-Fu3zxViCkMd2oEkwQ1ITv16MCfybykq1VYjoeqLcYjeq3RhWDnwMb+Ang0MP3xwq17kDkCt8XQ7omTJ/1ukSoQ==\",\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@types/json-schema\": {\n      \"version\": \"7.0.11\",\n      \"resolved\": \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.11.tgz\",\n      \"integrity\": \"sha512-wOuvG1SN4Us4rez+tylwwwCV1psiNVOkJeM3AUWUNWg/jDQY2+HE/444y5gc+jBmRqASOm2Oeh5c1axHobwRKQ==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/json5\": {\n      \"version\": \"0.0.29\",\n      \"resolved\": \"https://registry.npmjs.org/@types/json5/-/json5-0.0.29.tgz\",\n      \"integrity\": \"sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["130", {"page_content": "\"dev\": true\n    },\n    \"node_modules/@types/marked\": {\n      \"version\": \"4.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/@types/marked/-/marked-4.0.8.tgz\",\n      \"integrity\": \"sha512-HVNzMT5QlWCOdeuBsgXP8EZzKUf0+AXzN+sLmjvaB3ZlLqO+e4u0uXrdw9ub69wBKFs+c6/pA4r9sy6cCDvImw==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/marked-terminal\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/marked-terminal/-/marked-terminal-3.1.3.tgz\",\n      \"integrity\": \"sha512-dKgOLKlI5zFb2jTbRcyQqbdrHxeU74DCOkVIZtsoB2sc1ctXZ1iB2uxG2jjAuzoLdvwHP065ijN6Q8HecWdWYg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/marked\": \"^3\",\n        \"chalk\": \"^2.4.1\"\n      }\n    },\n    \"node_modules/@types/marked-terminal/node_modules/@types/marked\": {\n      \"version\": \"3.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/marked/-/marked-3.0.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["131", {"page_content": "\"resolved\": \"https://registry.npmjs.org/@types/marked/-/marked-3.0.3.tgz\",\n      \"integrity\": \"sha512-ZgAr847Wl68W+B0sWH7F4fDPxTzerLnRuUXjUpp1n4NjGSs8hgPAjAp7NQIXblG34MXTrf5wWkAK8PVJ2LIlVg==\",\n      \"dev\": true\n    },\n    \"node_modules/@types/marked-terminal/node_modules/ansi-styles\": {\n      \"version\": \"3.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz\",\n      \"integrity\": \"sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-convert\": \"^1.9.0\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/@types/marked-terminal/node_modules/chalk\": {\n      \"version\": \"2.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz\",\n      \"integrity\": \"sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==\",\n      \"dev\": true,\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["132", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"ansi-styles\": \"^3.2.1\",\n        \"escape-string-regexp\": \"^1.0.5\",\n        \"supports-color\": \"^5.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/@types/marked-terminal/node_modules/color-convert\": {\n      \"version\": \"1.9.3\",\n      \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz\",\n      \"integrity\": \"sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-name\": \"1.1.3\"\n      }\n    },\n    \"node_modules/@types/marked-terminal/node_modules/color-name\": {\n      \"version\": \"1.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz\",\n      \"integrity\": \"sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["133", {"page_content": "\"dev\": true\n    },\n    \"node_modules/@types/marked-terminal/node_modules/escape-string-regexp\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz\",\n      \"integrity\": \"sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.8.0\"\n      }\n    },\n    \"node_modules/@types/node\": {\n      \"version\": \"18.15.6\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-18.15.6.tgz\",\n      \"integrity\": \"sha512-YErOafCZpK4g+Rp3Q/PBgZNAsWKGunQTm9FA3/Pbcm0VCriTEzcrutQ/SxSc0rytAp0NoFWue669jmKhEtd0sA==\"\n    },\n    \"node_modules/@types/semver\": {\n      \"version\": \"7.3.13\",\n      \"resolved\": \"https://registry.npmjs.org/@types/semver/-/semver-7.3.13.tgz\",\n      \"integrity\": \"sha512-21cFJr9z3g5dW8B0CVI9g2O9beqaThGQ6ZFBqHfwhzLDKUxaqTIy3vnfah/UPkfOiF2pLq+tGz+W8RyCskuslw==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["134", {"page_content": "\"dev\": true\n    },\n    \"node_modules/@types/through\": {\n      \"version\": \"0.0.30\",\n      \"resolved\": \"https://registry.npmjs.org/@types/through/-/through-0.0.30.tgz\",\n      \"integrity\": \"sha512-FvnCJljyxhPM3gkRgWmxmDZyAQSiBQQWLI0A0VFL0K7W1oRUrPJSqNO0NvTnLkBcotdlp3lKvaT0JrnyRDkzOg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"node_modules/@typescript-eslint/eslint-plugin\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-5.56.0.tgz\",\n      \"integrity\": \"sha512-ZNW37Ccl3oMZkzxrYDUX4o7cnuPgU+YrcaYXzsRtLB16I1FR5SHMqga3zGsaSliZADCWo2v8qHWqAYIj8nWCCg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@eslint-community/regexpp\": \"^4.4.0\",\n        \"@typescript-eslint/scope-manager\": \"5.56.0\",\n        \"@typescript-eslint/type-utils\": \"5.56.0\",\n        \"@typescript-eslint/utils\": \"5.56.0\",\n        \"debug\": \"^4.3.4\",\n        \"grapheme-splitter\": \"^1.0.4\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["135", {"page_content": "\"debug\": \"^4.3.4\",\n        \"grapheme-splitter\": \"^1.0.4\",\n        \"ignore\": \"^5.2.0\",\n        \"natural-compare-lite\": \"^1.4.0\",\n        \"semver\": \"^7.3.7\",\n        \"tsutils\": \"^3.21.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {\n        \"@typescript-eslint/parser\": \"^5.0.0\",\n        \"eslint\": \"^6.0.0 || ^7.0.0 || ^8.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/parser\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.56.0.tgz\",\n      \"integrity\": \"sha512-sn1OZmBxUsgxMmR8a8U5QM/Wl+tyqlH//jTqCg8daTAmhAk26L2PFhcqPLlYBhYUJMZJK276qLXlHN3a83o2cg==\",\n      \"dev\": true,\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["136", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/scope-manager\": \"5.56.0\",\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/typescript-estree\": \"5.56.0\",\n        \"debug\": \"^4.3.4\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^6.0.0 || ^7.0.0 || ^8.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/scope-manager\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-5.56.0.tgz\",\n      \"integrity\": \"sha512-jGYKyt+iBakD0SA5Ww8vFqGpoV2asSjwt60Gl6YcO8ksQ8s2HlUEyHBMSa38bdLopYqGf7EYQMUIGdT/Luw+sw==\",\n      \"dev\": true,\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["137", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/visitor-keys\": \"5.56.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      }\n    },\n    \"node_modules/@typescript-eslint/type-utils\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-5.56.0.tgz\",\n      \"integrity\": \"sha512-8WxgOgJjWRy6m4xg9KoSHPzBNZeQbGlQOH7l2QEhQID/+YseaFxg5J/DLwWSsi9Axj4e/cCiKx7PVzOq38tY4A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/typescript-estree\": \"5.56.0\",\n        \"@typescript-eslint/utils\": \"5.56.0\",\n        \"debug\": \"^4.3.4\",\n        \"tsutils\": \"^3.21.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["138", {"page_content": "\"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"*\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/types\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/types/-/types-5.56.0.tgz\",\n      \"integrity\": \"sha512-JyAzbTJcIyhuUhogmiu+t79AkdnqgPUEsxMTMc/dCZczGMJQh1MK2wgrju++yMN6AWroVAy2jxyPcPr3SWCq5w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      }\n    },\n    \"node_modules/@typescript-eslint/typescript-estree\": {\n      \"version\": \"5.56.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["139", {"page_content": "},\n    \"node_modules/@typescript-eslint/typescript-estree\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-5.56.0.tgz\",\n      \"integrity\": \"sha512-41CH/GncsLXOJi0jb74SnC7jVPWeVJ0pxQj8bOjH1h2O26jXN3YHKDT1ejkVz5YeTEQPeLCCRY0U2r68tfNOcg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/visitor-keys\": \"5.56.0\",\n        \"debug\": \"^4.3.4\",\n        \"globby\": \"^11.1.0\",\n        \"is-glob\": \"^4.0.3\",\n        \"semver\": \"^7.3.7\",\n        \"tsutils\": \"^3.21.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/utils\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["140", {"page_content": "\"optional\": true\n        }\n      }\n    },\n    \"node_modules/@typescript-eslint/utils\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/utils/-/utils-5.56.0.tgz\",\n      \"integrity\": \"sha512-XhZDVdLnUJNtbzaJeDSCIYaM+Tgr59gZGbFuELgF7m0IY03PlciidS7UQNKLE0+WpUTn1GlycEr6Ivb/afjbhA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@eslint-community/eslint-utils\": \"^4.2.0\",\n        \"@types/json-schema\": \"^7.0.9\",\n        \"@types/semver\": \"^7.3.12\",\n        \"@typescript-eslint/scope-manager\": \"5.56.0\",\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/typescript-estree\": \"5.56.0\",\n        \"eslint-scope\": \"^5.1.1\",\n        \"semver\": \"^7.3.7\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["141", {"page_content": "\"url\": \"https://opencollective.com/typescript-eslint\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^6.0.0 || ^7.0.0 || ^8.0.0\"\n      }\n    },\n    \"node_modules/@typescript-eslint/visitor-keys\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-5.56.0.tgz\",\n      \"integrity\": \"sha512-1mFdED7u5bZpX6Xxf5N9U2c18sb+8EvU3tyOIj6LQZ5OOvnmj8BVeNNP603OFPm5KkS1a7IvCIcwrdHXaEMG/Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"eslint-visitor-keys\": \"^3.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"type\": \"opencollective\",\n        \"url\": \"https://opencollective.com/typescript-eslint\"\n      }\n    },\n    \"node_modules/acorn\": {\n      \"version\": \"7.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["142", {"page_content": "\"version\": \"7.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz\",\n      \"integrity\": \"sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==\",\n      \"dev\": true,\n      \"bin\": {\n        \"acorn\": \"bin/acorn\"\n      },\n      \"engines\": {\n        \"node\": \">=0.4.0\"\n      }\n    },\n    \"node_modules/acorn-jsx\": {\n      \"version\": \"5.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz\",\n      \"integrity\": \"sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==\",\n      \"dev\": true,\n      \"peerDependencies\": {\n        \"acorn\": \"^6.0.0 || ^7.0.0 || ^8.0.0\"\n      }\n    },\n    \"node_modules/ajv\": {\n      \"version\": \"6.12.6\",\n      \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz\",\n      \"integrity\": \"sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==\",\n      \"dev\": true,\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["143", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"fast-deep-equal\": \"^3.1.1\",\n        \"fast-json-stable-stringify\": \"^2.0.0\",\n        \"json-schema-traverse\": \"^0.4.1\",\n        \"uri-js\": \"^4.2.2\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/epoberezkin\"\n      }\n    },\n    \"node_modules/ansi-colors\": {\n      \"version\": \"4.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.3.tgz\",\n      \"integrity\": \"sha512-/6w/C21Pm1A7aZitlI5Ni/2J6FFQN8i1Cvz3kHABAAbw93v/NlvKdVOqz7CCWz/3iv/JplRSEEZ83XION15ovw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/ansi-escapes\": {\n      \"version\": \"6.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-6.1.0.tgz\",\n      \"integrity\": \"sha512-bQyg9bzRntwR/8b89DOEhGwctcwCrbWW/TuqTQnpqpy5Fz3aovcOTj5i8NJV6AHc8OGNdMaqdxAWww8pz2kiKg==\",\n      \"dependencies\": {\n        \"type-fest\": \"^3.0.0\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["144", {"page_content": "\"dependencies\": {\n        \"type-fest\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=14.16\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/ansi-escapes/node_modules/type-fest\": {\n      \"version\": \"3.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/type-fest/-/type-fest-3.7.0.tgz\",\n      \"integrity\": \"sha512-A2qUJ/j8vkKIT+UorxayZjFJoEdNkIPZkjOJSWezoAbRQd7QEhnz2iJlfVy4Or0GuEnCXts5cNorQNUvdLkaSQ==\",\n      \"engines\": {\n        \"node\": \">=14.16\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n      \"integrity\": \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/ansi-styles\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["145", {"page_content": "\"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/ansi-styles\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz\",\n      \"integrity\": \"sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-convert\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/ansicolors\": {\n      \"version\": \"0.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/ansicolors/-/ansicolors-0.3.2.tgz\",\n      \"integrity\": \"sha512-QXu7BPrP29VllRxH8GwB7x5iX5qWKAAMLqKQGWTeLWVlNHNOpVMJ91dsxQAIWXpjuW5wqvxu3Jd/nRjrJ+0pqg==\"\n    },\n    \"node_modules/argparse\": {\n      \"version\": \"1.0.10\",\n      \"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["146", {"page_content": "\"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz\",\n      \"integrity\": \"sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"sprintf-js\": \"~1.0.2\"\n      }\n    },\n    \"node_modules/aria-query\": {\n      \"version\": \"5.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/aria-query/-/aria-query-5.1.3.tgz\",\n      \"integrity\": \"sha512-R5iJ5lkuHybztUfuOAznmboyjWq8O6sqNqtK7CLOqdydi54VNbORp49mb14KbWgG1QD3JFO9hJdZ+y4KutfdOQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"deep-equal\": \"^2.0.5\"\n      }\n    },\n    \"node_modules/array-buffer-byte-length\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/array-buffer-byte-length/-/array-buffer-byte-length-1.0.0.tgz\",\n      \"integrity\": \"sha512-LPuwb2P+NrQw3XhxGc36+XSvuBPopovXYTR9Ew++Du9Yb/bx5AzBfrIsBoj0EZUifjQU+sHL21sseZ3jerWO/A==\",\n      \"dev\": true,\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["147", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"is-array-buffer\": \"^3.0.1\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/array-includes\": {\n      \"version\": \"3.1.6\",\n      \"resolved\": \"https://registry.npmjs.org/array-includes/-/array-includes-3.1.6.tgz\",\n      \"integrity\": \"sha512-sgTbLvL6cNnw24FnbaDyjmvddQ2ML8arZsgaJhoABMoplz/4QRhtrYS+alr1BUM1Bwp6dhx8vVCBSLG+StwOFw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"is-string\": \"^1.0.7\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/array-keyed-map\": {\n      \"version\": \"2.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/array-keyed-map/-/array-keyed-map-2.1.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["148", {"page_content": "\"resolved\": \"https://registry.npmjs.org/array-keyed-map/-/array-keyed-map-2.1.3.tgz\",\n      \"integrity\": \"sha512-JIUwuFakO+jHjxyp4YgSiKXSZeC0U+R1jR94bXWBcVlFRBycqXlb+kH9JHxBGcxnVuSqx5bnn0Qz9xtSeKOjiA==\"\n    },\n    \"node_modules/array-union\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz\",\n      \"integrity\": \"sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/array.prototype.flat\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/array.prototype.flat/-/array.prototype.flat-1.3.1.tgz\",\n      \"integrity\": \"sha512-roTU0KWIOmJ4DRLmwKd19Otg0/mT3qPNt0Qb3GWW8iObuZXxrjB/pzn0R3hqpRSWg4HCwqx+0vwOnWnvlOyeIA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["149", {"page_content": "\"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"es-shim-unscopables\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/array.prototype.flatmap\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/array.prototype.flatmap/-/array.prototype.flatmap-1.3.1.tgz\",\n      \"integrity\": \"sha512-8UGn9O1FDVvMNB0UlLv4voxRMze7+FpHyF5mSMRjWHUMlpoDViniy05870VlxhfgTnLbpuwTzvD76MTtWxB/mQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"es-shim-unscopables\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/array.prototype.tosorted\": {\n      \"version\": \"1.1.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["150", {"page_content": "}\n    },\n    \"node_modules/array.prototype.tosorted\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/array.prototype.tosorted/-/array.prototype.tosorted-1.1.1.tgz\",\n      \"integrity\": \"sha512-pZYPXPRl2PqWcsUs6LOMn+1f1532nEoPTYowBtqLwAW+W8vSVhkIGnmOX1t/UQjD6YGI0vcD2B1U7ZFGQH9jnQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"es-shim-unscopables\": \"^1.0.0\",\n        \"get-intrinsic\": \"^1.1.3\"\n      }\n    },\n    \"node_modules/ast-types-flow\": {\n      \"version\": \"0.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/ast-types-flow/-/ast-types-flow-0.0.7.tgz\",\n      \"integrity\": \"sha512-eBvWn1lvIApYMhzQMsu9ciLfkBY499mFZlNqG+/9WR7PVlroQw0vG30cOQQbaKz3sCEc44TAOu2ykzqXSNnwag==\",\n      \"dev\": true\n    },\n    \"node_modules/astral-regex\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["151", {"page_content": "\"resolved\": \"https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz\",\n      \"integrity\": \"sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/asynckit\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz\",\n      \"integrity\": \"sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==\"\n    },\n    \"node_modules/available-typed-arrays\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.5.tgz\",\n      \"integrity\": \"sha512-DMD0KiN46eipeziST1LPP/STfDU0sufISXmjSgvVsoU2tqxctQeASejWcfNtxYKqETM1UxQ8sp2OrSBWpHY6sw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["152", {"page_content": "},\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/axe-core\": {\n      \"version\": \"4.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/axe-core/-/axe-core-4.6.3.tgz\",\n      \"integrity\": \"sha512-/BQzOX780JhsxDnPpH4ZiyrJAzcd8AfzFPkv+89veFSr1rcMjuq2JDCwypKaPeB6ljHp9KjXhPpjgCvQlWYuqg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/axios\": {\n      \"version\": \"0.26.1\",\n      \"resolved\": \"https://registry.npmjs.org/axios/-/axios-0.26.1.tgz\",\n      \"integrity\": \"sha512-fPwcX4EvnSHuInCMItEhAGnaSEXRBjtzh9fOtsE6E1G6p7vl7edEeZe11QHf18+6+9gR5PbKV/sGKNaD8YaMeA==\",\n      \"dependencies\": {\n        \"follow-redirects\": \"^1.14.8\"\n      }\n    },\n    \"node_modules/axobject-query\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/axobject-query/-/axobject-query-3.1.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["153", {"page_content": "\"resolved\": \"https://registry.npmjs.org/axobject-query/-/axobject-query-3.1.1.tgz\",\n      \"integrity\": \"sha512-goKlv8DZrK9hUh975fnHzhNIO4jUnFCfv/dszV5VwUGDFjI6vQ2VwoyjYjYNEbBE8AH87TduWP5uyDR1D+Iteg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"deep-equal\": \"^2.0.5\"\n      }\n    },\n    \"node_modules/balanced-match\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n      \"integrity\": \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\"\n    },\n    \"node_modules/base64-js\": {\n      \"version\": \"1.5.1\",\n      \"resolved\": \"https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz\",\n      \"integrity\": \"sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["154", {"page_content": "},\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ]\n    },\n    \"node_modules/binary-extensions\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz\",\n      \"integrity\": \"sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/binaryextensions\": {\n      \"version\": \"4.18.0\",\n      \"resolved\": \"https://registry.npmjs.org/binaryextensions/-/binaryextensions-4.18.0.tgz\",\n      \"integrity\": \"sha512-PQu3Kyv9dM4FnwB7XGj1+HucW+ShvJzJqjuw1JkKVs1mWdwOKVcRjOi+pV9X52A0tNvrPCsPkbFFQb+wE1EAXw==\",\n      \"engines\": {\n        \"node\": \">=0.8\"\n      },\n      \"funding\": {\n        \"url\": \"https://bevry.me/fund\"\n      }\n    },\n    \"node_modules/bindings\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["155", {"page_content": "\"url\": \"https://bevry.me/fund\"\n      }\n    },\n    \"node_modules/bindings\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/bindings/-/bindings-1.5.0.tgz\",\n      \"integrity\": \"sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==\",\n      \"dependencies\": {\n        \"file-uri-to-path\": \"1.0.0\"\n      }\n    },\n    \"node_modules/bl\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/bl/-/bl-5.1.0.tgz\",\n      \"integrity\": \"sha512-tv1ZJHLfTDnXE6tMHv73YgSJaWR2AFuPwMntBe7XL/GBFHnT0CLnsHMogfk5+GzCDC5ZWarSCYaIGATZt9dNsQ==\",\n      \"dependencies\": {\n        \"buffer\": \"^6.0.3\",\n        \"inherits\": \"^2.0.4\",\n        \"readable-stream\": \"^3.4.0\"\n      }\n    },\n    \"node_modules/brace-expansion\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["156", {"page_content": "\"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz\",\n      \"integrity\": \"sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==\",\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\"\n      }\n    },\n    \"node_modules/braces\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/braces/-/braces-3.0.2.tgz\",\n      \"integrity\": \"sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"fill-range\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/browser-or-node\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/browser-or-node/-/browser-or-node-2.1.1.tgz\",\n      \"integrity\": \"sha512-8CVjaLJGuSKMVTxJ2DpBl5XnlNDiT4cQFeuCJJrvJmts9YrTZDizTX7PjC2s6W4x+MBGZeEY6dGMrF04/6Hgqg==\"\n    },\n    \"node_modules/buffer\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["157", {"page_content": "},\n    \"node_modules/buffer\": {\n      \"version\": \"6.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz\",\n      \"integrity\": \"sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ],\n      \"dependencies\": {\n        \"base64-js\": \"^1.3.1\",\n        \"ieee754\": \"^1.2.1\"\n      }\n    },\n    \"node_modules/call-bind\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz\",\n      \"integrity\": \"sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==\",\n      \"dev\": true,\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["158", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"function-bind\": \"^1.1.1\",\n        \"get-intrinsic\": \"^1.0.2\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/callsites\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz\",\n      \"integrity\": \"sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/cardinal\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/cardinal/-/cardinal-2.1.1.tgz\",\n      \"integrity\": \"sha512-JSr5eOgoEymtYHBjNWyjrMqet9Am2miJhlfKNdqLp6zoeAh0KN5dRAcxlecj5mAJrmQomgiOBj35xHLrFjqBpw==\",\n      \"dependencies\": {\n        \"ansicolors\": \"~0.3.2\",\n        \"redeyed\": \"~2.1.0\"\n      },\n      \"bin\": {\n        \"cdl\": \"bin/cdl.js\"\n      }\n    },\n    \"node_modules/chalk\": {\n      \"version\": \"5.2.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["159", {"page_content": "\"cdl\": \"bin/cdl.js\"\n      }\n    },\n    \"node_modules/chalk\": {\n      \"version\": \"5.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-5.2.0.tgz\",\n      \"integrity\": \"sha512-ree3Gqw/nazQAPuJJEy+avdl7QfZMcUvmHIKgEZkGL+xOBzRvup5Hxo6LHuMceSxOabuJLJm5Yp/92R9eMmMvA==\",\n      \"engines\": {\n        \"node\": \"^12.17.0 || ^14.13 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/chalk?sponsor=1\"\n      }\n    },\n    \"node_modules/chardet\": {\n      \"version\": \"0.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/chardet/-/chardet-0.7.0.tgz\",\n      \"integrity\": \"sha512-mT8iDcrh03qDGRRmoA2hmBJnxpllMR+0/0qlzjqZES6NdiWDcZkCNAk4rPFZ9Q85r27unkiNNg8ZOiwZXBHwcA==\"\n    },\n    \"node_modules/cli-cursor\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-cursor/-/cli-cursor-4.0.0.tgz\",\n      \"integrity\": \"sha512-VGtlMu3x/4DOtIUwEkRezxUZ2lBacNJCHash0N0WeZDBS+7Ux1dm3XWAgWYxLJFMMdOeXMHXorshEFhbMSGelg==\",\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["160", {"page_content": "\"dependencies\": {\n        \"restore-cursor\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/cli-progress\": {\n      \"version\": \"3.12.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-progress/-/cli-progress-3.12.0.tgz\",\n      \"integrity\": \"sha512-tRkV3HJ1ASwm19THiiLIXLO7Im7wlTuKnvkYaTkyoAPefqjNg7W7DHKUlGRxy9vxDvbyCYQkQozvptuMkGCg8A==\",\n      \"dependencies\": {\n        \"string-width\": \"^4.2.3\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/cli-spinners\": {\n      \"version\": \"2.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-spinners/-/cli-spinners-2.7.0.tgz\",\n      \"integrity\": \"sha512-qu3pN8Y3qHNgE2AFweciB1IfMnmZ/fsNTEE+NOFjmGB2F/7rLhnhzppvpCnN4FovtP26k8lHyy9ptEbNwWFLzw==\",\n      \"engines\": {\n        \"node\": \">=6\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["161", {"page_content": "\"engines\": {\n        \"node\": \">=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/cli-table3\": {\n      \"version\": \"0.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/cli-table3/-/cli-table3-0.6.3.tgz\",\n      \"integrity\": \"sha512-w5Jac5SykAeZJKntOxJCrm63Eg5/4dhMWIcuTbo9rpE+brgaSZo0RuNJZeOyMgsUdhDeojvgyQLmjI+K50ZGyg==\",\n      \"dependencies\": {\n        \"string-width\": \"^4.2.0\"\n      },\n      \"engines\": {\n        \"node\": \"10.* || >= 12.*\"\n      },\n      \"optionalDependencies\": {\n        \"@colors/colors\": \"1.5.0\"\n      }\n    },\n    \"node_modules/cli-width\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-width/-/cli-width-4.0.0.tgz\",\n      \"integrity\": \"sha512-ZksGS2xpa/bYkNzN3BAw1wEjsLV/ZKOf/CCrJ/QOBsxx6fOARIkwTutxp1XIOIohi6HKmOFjMoK/XaqDVUpEEw==\",\n      \"engines\": {\n        \"node\": \">= 12\"\n      }\n    },\n    \"node_modules/clone\": {\n      \"version\": \"1.0.4\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["162", {"page_content": "\"node\": \">= 12\"\n      }\n    },\n    \"node_modules/clone\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/clone/-/clone-1.0.4.tgz\",\n      \"integrity\": \"sha512-JQHZ2QMW6l3aH/j6xCqQThY/9OH4D/9ls34cgkUBiEeocRTU04tHfKPBsUK1PqZCUQM7GiA0IIXJSuXHI64Kbg==\",\n      \"engines\": {\n        \"node\": \">=0.8\"\n      }\n    },\n    \"node_modules/color-convert\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",\n      \"integrity\": \"sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"color-name\": \"~1.1.4\"\n      },\n      \"engines\": {\n        \"node\": \">=7.0.0\"\n      }\n    },\n    \"node_modules/color-name\": {\n      \"version\": \"1.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["163", {"page_content": "\"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",\n      \"integrity\": \"sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\",\n      \"dev\": true\n    },\n    \"node_modules/combined-stream\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz\",\n      \"integrity\": \"sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==\",\n      \"dependencies\": {\n        \"delayed-stream\": \"~1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8\"\n      }\n    },\n    \"node_modules/commander\": {\n      \"version\": \"10.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/commander/-/commander-10.0.0.tgz\",\n      \"integrity\": \"sha512-zS5PnTI22FIRM6ylNW8G4Ap0IEOyk62fhLSD0+uHRT9McRCLGpkVNvao4bjimpK/GShynyQkFFxHhwMcETmduA==\",\n      \"engines\": {\n        \"node\": \">=14\"\n      }\n    },\n    \"node_modules/concat-map\": {\n      \"version\": \"0.0.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["164", {"page_content": "\"node\": \">=14\"\n      }\n    },\n    \"node_modules/concat-map\": {\n      \"version\": \"0.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n      \"integrity\": \"sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==\",\n      \"dev\": true\n    },\n    \"node_modules/cross-spawn\": {\n      \"version\": \"7.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz\",\n      \"integrity\": \"sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"path-key\": \"^3.1.0\",\n        \"shebang-command\": \"^2.0.0\",\n        \"which\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/damerau-levenshtein\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/damerau-levenshtein/-/damerau-levenshtein-1.0.8.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["165", {"page_content": "\"resolved\": \"https://registry.npmjs.org/damerau-levenshtein/-/damerau-levenshtein-1.0.8.tgz\",\n      \"integrity\": \"sha512-sdQSFB7+llfUcQHUQO3+B8ERRj0Oa4w9POWMI/puGtuf7gFywGmkaLCElnudfTiKZV+NvHqL0ifzdrI8Ro7ESA==\",\n      \"dev\": true\n    },\n    \"node_modules/debug\": {\n      \"version\": \"4.3.4\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-4.3.4.tgz\",\n      \"integrity\": \"sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ms\": \"2.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">=6.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"supports-color\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/deep-equal\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/deep-equal/-/deep-equal-2.2.0.tgz\",\n      \"integrity\": \"sha512-RdpzE0Hv4lhowpIUKKMJfeH6C1pXdtT1/it80ubgWqwI3qpuxUBpC1S4hnHg+zjnuOoDkzUtUCEEkG+XG5l3Mw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["166", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"es-get-iterator\": \"^1.1.2\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"is-arguments\": \"^1.1.1\",\n        \"is-array-buffer\": \"^3.0.1\",\n        \"is-date-object\": \"^1.0.5\",\n        \"is-regex\": \"^1.1.4\",\n        \"is-shared-array-buffer\": \"^1.0.2\",\n        \"isarray\": \"^2.0.5\",\n        \"object-is\": \"^1.1.5\",\n        \"object-keys\": \"^1.1.1\",\n        \"object.assign\": \"^4.1.4\",\n        \"regexp.prototype.flags\": \"^1.4.3\",\n        \"side-channel\": \"^1.0.4\",\n        \"which-boxed-primitive\": \"^1.0.2\",\n        \"which-collection\": \"^1.0.1\",\n        \"which-typed-array\": \"^1.1.9\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/deep-is\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz\",\n      \"integrity\": \"sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["167", {"page_content": "\"dev\": true\n    },\n    \"node_modules/defaults\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/defaults/-/defaults-1.0.4.tgz\",\n      \"integrity\": \"sha512-eFuaLoy/Rxalv2kr+lqMlUnrDWV+3j4pljOIJgLIhI058IQfWJ7vXhyEIHu+HtC738klGALYxOKDO0bQP3tg8A==\",\n      \"dependencies\": {\n        \"clone\": \"^1.0.2\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/define-lazy-prop\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/define-lazy-prop/-/define-lazy-prop-2.0.0.tgz\",\n      \"integrity\": \"sha512-Ds09qNh8yw3khSjiJjiUInaGX9xlqZDY7JVryGxdxV7NPeuqQfplOpQ66yJFZut3jLa5zOwkXw1g9EI2uKh4Og==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/define-properties\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/define-properties/-/define-properties-1.2.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["168", {"page_content": "\"resolved\": \"https://registry.npmjs.org/define-properties/-/define-properties-1.2.0.tgz\",\n      \"integrity\": \"sha512-xvqAVKGfT1+UAvPwKTVw/njhdQ8ZhXK4lI0bCIuCMrp2up9nPnaDftrLtmpTazqd1o+UY4zgzU+avtMbDP+ldA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-property-descriptors\": \"^1.0.0\",\n        \"object-keys\": \"^1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/delayed-stream\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz\",\n      \"integrity\": \"sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==\",\n      \"engines\": {\n        \"node\": \">=0.4.0\"\n      }\n    },\n    \"node_modules/dir-glob\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["169", {"page_content": "\"resolved\": \"https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz\",\n      \"integrity\": \"sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"path-type\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/doctrine\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz\",\n      \"integrity\": \"sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"esutils\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">=6.0.0\"\n      }\n    },\n    \"node_modules/eastasianwidth\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz\",\n      \"integrity\": \"sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==\"", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["170", {"page_content": "},\n    \"node_modules/emoji-regex\": {\n      \"version\": \"9.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz\",\n      \"integrity\": \"sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==\"\n    },\n    \"node_modules/enhanced-resolve\": {\n      \"version\": \"5.12.0\",\n      \"resolved\": \"https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.12.0.tgz\",\n      \"integrity\": \"sha512-QHTXI/sZQmko1cbDoNAa3mJ5qhWUUNAq3vR0/YiD379fWQrcfuoX1+HW2S0MTt7XmoPLapdaDKUtelUSPic7hQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"graceful-fs\": \"^4.2.4\",\n        \"tapable\": \"^2.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10.13.0\"\n      }\n    },\n    \"node_modules/enquirer\": {\n      \"version\": \"2.3.6\",\n      \"resolved\": \"https://registry.npmjs.org/enquirer/-/enquirer-2.3.6.tgz\",\n      \"integrity\": \"sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["171", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"ansi-colors\": \"^4.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8.6\"\n      }\n    },\n    \"node_modules/es-abstract\": {\n      \"version\": \"1.21.2\",\n      \"resolved\": \"https://registry.npmjs.org/es-abstract/-/es-abstract-1.21.2.tgz\",\n      \"integrity\": \"sha512-y/B5POM2iBnIxCiernH1G7rC9qQoM77lLIMQLuob0zhp8C56Po81+2Nj0WFKnd0pNReDTnkYryc+zhOzpEIROg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"array-buffer-byte-length\": \"^1.0.0\",\n        \"available-typed-arrays\": \"^1.0.5\",\n        \"call-bind\": \"^1.0.2\",\n        \"es-set-tostringtag\": \"^2.0.1\",\n        \"es-to-primitive\": \"^1.2.1\",\n        \"function.prototype.name\": \"^1.1.5\",\n        \"get-intrinsic\": \"^1.2.0\",\n        \"get-symbol-description\": \"^1.0.0\",\n        \"globalthis\": \"^1.0.3\",\n        \"gopd\": \"^1.0.1\",\n        \"has\": \"^1.0.3\",\n        \"has-property-descriptors\": \"^1.0.0\",\n        \"has-proto\": \"^1.0.1\",\n        \"has-symbols\": \"^1.0.3\",\n        \"internal-slot\": \"^1.0.5\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["172", {"page_content": "\"has-proto\": \"^1.0.1\",\n        \"has-symbols\": \"^1.0.3\",\n        \"internal-slot\": \"^1.0.5\",\n        \"is-array-buffer\": \"^3.0.2\",\n        \"is-callable\": \"^1.2.7\",\n        \"is-negative-zero\": \"^2.0.2\",\n        \"is-regex\": \"^1.1.4\",\n        \"is-shared-array-buffer\": \"^1.0.2\",\n        \"is-string\": \"^1.0.7\",\n        \"is-typed-array\": \"^1.1.10\",\n        \"is-weakref\": \"^1.0.2\",\n        \"object-inspect\": \"^1.12.3\",\n        \"object-keys\": \"^1.1.1\",\n        \"object.assign\": \"^4.1.4\",\n        \"regexp.prototype.flags\": \"^1.4.3\",\n        \"safe-regex-test\": \"^1.0.0\",\n        \"string.prototype.trim\": \"^1.2.7\",\n        \"string.prototype.trimend\": \"^1.0.6\",\n        \"string.prototype.trimstart\": \"^1.0.6\",\n        \"typed-array-length\": \"^1.0.4\",\n        \"unbox-primitive\": \"^1.0.2\",\n        \"which-typed-array\": \"^1.1.9\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["173", {"page_content": "},\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/es-get-iterator\": {\n      \"version\": \"1.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/es-get-iterator/-/es-get-iterator-1.1.3.tgz\",\n      \"integrity\": \"sha512-sPZmqHBe6JIiTfN5q2pEi//TwxmAFHwj/XEuYjTuse78i8KxaqMTTzxPoFKuzRpDpTJ+0NAbpfenkmH2rePtuw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"has-symbols\": \"^1.0.3\",\n        \"is-arguments\": \"^1.1.1\",\n        \"is-map\": \"^2.0.2\",\n        \"is-set\": \"^2.0.2\",\n        \"is-string\": \"^1.0.7\",\n        \"isarray\": \"^2.0.5\",\n        \"stop-iteration-iterator\": \"^1.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/es-set-tostringtag\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["174", {"page_content": "\"resolved\": \"https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.0.1.tgz\",\n      \"integrity\": \"sha512-g3OMbtlwY3QewlqAiMLI47KywjWZoEytKr8pf6iTC8uJq5bIAH52Z9pnQ8pVL6whrCto53JZDuUIsifGeLorTg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"get-intrinsic\": \"^1.1.3\",\n        \"has\": \"^1.0.3\",\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/es-shim-unscopables\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-shim-unscopables/-/es-shim-unscopables-1.0.0.tgz\",\n      \"integrity\": \"sha512-Jm6GPcCdC30eMLbZ2x8z2WuRwAws3zTBBKuusffYVUrNj/GVSUAZ+xKMaUpfNDR5IbyNA5LJbaecoUVbmUcB1w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has\": \"^1.0.3\"\n      }\n    },\n    \"node_modules/es-to-primitive\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.2.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["175", {"page_content": "\"resolved\": \"https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.2.1.tgz\",\n      \"integrity\": \"sha512-QCOllgZJtaUo9miYBcLChTUaHNjJF3PYs1VidD7AwiEj1kYxKeQTctLAezAOH5ZKRH0g2IgPn6KwB4IT8iRpvA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-callable\": \"^1.1.4\",\n        \"is-date-object\": \"^1.0.1\",\n        \"is-symbol\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/esbuild\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/esbuild/-/esbuild-0.17.12.tgz\",\n      \"integrity\": \"sha512-bX/zHl7Gn2CpQwcMtRogTTBf9l1nl+H6R8nUbjk+RuKqAE3+8FDulLA+pHvX7aA7Xe07Iwa+CWvy9I8Y2qqPKQ==\",\n      \"hasInstallScript\": true,\n      \"bin\": {\n        \"esbuild\": \"bin/esbuild\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"optionalDependencies\": {\n        \"@esbuild/android-arm\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["176", {"page_content": "},\n      \"optionalDependencies\": {\n        \"@esbuild/android-arm\": \"0.17.12\",\n        \"@esbuild/android-arm64\": \"0.17.12\",\n        \"@esbuild/android-x64\": \"0.17.12\",\n        \"@esbuild/darwin-arm64\": \"0.17.12\",\n        \"@esbuild/darwin-x64\": \"0.17.12\",\n        \"@esbuild/freebsd-arm64\": \"0.17.12\",\n        \"@esbuild/freebsd-x64\": \"0.17.12\",\n        \"@esbuild/linux-arm\": \"0.17.12\",\n        \"@esbuild/linux-arm64\": \"0.17.12\",\n        \"@esbuild/linux-ia32\": \"0.17.12\",\n        \"@esbuild/linux-loong64\": \"0.17.12\",\n        \"@esbuild/linux-mips64el\": \"0.17.12\",\n        \"@esbuild/linux-ppc64\": \"0.17.12\",\n        \"@esbuild/linux-riscv64\": \"0.17.12\",\n        \"@esbuild/linux-s390x\": \"0.17.12\",\n        \"@esbuild/linux-x64\": \"0.17.12\",\n        \"@esbuild/netbsd-x64\": \"0.17.12\",\n        \"@esbuild/openbsd-x64\": \"0.17.12\",\n        \"@esbuild/sunos-x64\": \"0.17.12\",\n        \"@esbuild/win32-arm64\": \"0.17.12\",\n        \"@esbuild/win32-ia32\": \"0.17.12\",\n        \"@esbuild/win32-x64\": \"0.17.12\"\n      }", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["177", {"page_content": "\"@esbuild/win32-ia32\": \"0.17.12\",\n        \"@esbuild/win32-x64\": \"0.17.12\"\n      }\n    },\n    \"node_modules/escape-string-regexp\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz\",\n      \"integrity\": \"sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/eslint\": {\n      \"version\": \"7.32.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz\",\n      \"integrity\": \"sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@babel/code-frame\": \"7.12.11\",\n        \"@eslint/eslintrc\": \"^0.4.3\",\n        \"@humanwhocodes/config-array\": \"^0.5.0\",\n        \"ajv\": \"^6.10.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["178", {"page_content": "\"@humanwhocodes/config-array\": \"^0.5.0\",\n        \"ajv\": \"^6.10.0\",\n        \"chalk\": \"^4.0.0\",\n        \"cross-spawn\": \"^7.0.2\",\n        \"debug\": \"^4.0.1\",\n        \"doctrine\": \"^3.0.0\",\n        \"enquirer\": \"^2.3.5\",\n        \"escape-string-regexp\": \"^4.0.0\",\n        \"eslint-scope\": \"^5.1.1\",\n        \"eslint-utils\": \"^2.1.0\",\n        \"eslint-visitor-keys\": \"^2.0.0\",\n        \"espree\": \"^7.3.1\",\n        \"esquery\": \"^1.4.0\",\n        \"esutils\": \"^2.0.2\",\n        \"fast-deep-equal\": \"^3.1.3\",\n        \"file-entry-cache\": \"^6.0.1\",\n        \"functional-red-black-tree\": \"^1.0.1\",\n        \"glob-parent\": \"^5.1.2\",\n        \"globals\": \"^13.6.0\",\n        \"ignore\": \"^4.0.6\",\n        \"import-fresh\": \"^3.0.0\",\n        \"imurmurhash\": \"^0.1.4\",\n        \"is-glob\": \"^4.0.0\",\n        \"js-yaml\": \"^3.13.1\",\n        \"json-stable-stringify-without-jsonify\": \"^1.0.1\",\n        \"levn\": \"^0.4.1\",\n        \"lodash.merge\": \"^4.6.2\",\n        \"minimatch\": \"^3.0.4\",\n        \"natural-compare\": \"^1.4.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["179", {"page_content": "\"minimatch\": \"^3.0.4\",\n        \"natural-compare\": \"^1.4.0\",\n        \"optionator\": \"^0.9.1\",\n        \"progress\": \"^2.0.0\",\n        \"regexpp\": \"^3.1.0\",\n        \"semver\": \"^7.2.1\",\n        \"strip-ansi\": \"^6.0.0\",\n        \"strip-json-comments\": \"^3.1.0\",\n        \"table\": \"^6.0.9\",\n        \"text-table\": \"^0.2.0\",\n        \"v8-compile-cache\": \"^2.0.3\"\n      },\n      \"bin\": {\n        \"eslint\": \"bin/eslint.js\"\n      },\n      \"engines\": {\n        \"node\": \"^10.12.0 || >=12.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/eslint\"\n      }\n    },\n    \"node_modules/eslint-config-next\": {\n      \"version\": \"13.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-config-next/-/eslint-config-next-13.2.4.tgz\",\n      \"integrity\": \"sha512-lunIBhsoeqw6/Lfkd6zPt25w1bn0znLA/JCL+au1HoEpSb4/PpsOYsYtgV/q+YPsoKIOzFyU5xnb04iZnXjUvg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@next/eslint-plugin-next\": \"13.2.4\",\n        \"@rushstack/eslint-patch\": \"^1.1.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["180", {"page_content": "\"@next/eslint-plugin-next\": \"13.2.4\",\n        \"@rushstack/eslint-patch\": \"^1.1.3\",\n        \"@typescript-eslint/parser\": \"^5.42.0\",\n        \"eslint-import-resolver-node\": \"^0.3.6\",\n        \"eslint-import-resolver-typescript\": \"^3.5.2\",\n        \"eslint-plugin-import\": \"^2.26.0\",\n        \"eslint-plugin-jsx-a11y\": \"^6.5.1\",\n        \"eslint-plugin-react\": \"^7.31.7\",\n        \"eslint-plugin-react-hooks\": \"^4.5.0\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^7.23.0 || ^8.0.0\",\n        \"typescript\": \">=3.3.1\"\n      },\n      \"peerDependenciesMeta\": {\n        \"typescript\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/eslint-config-prettier\": {\n      \"version\": \"8.8.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-8.8.0.tgz\",\n      \"integrity\": \"sha512-wLbQiFre3tdGgpDv67NQKnJuTlcUVYHas3k+DZCc2U2BadthoEY4B7hLPvAxaqdyOGCzuLfii2fqGph10va7oA==\",\n      \"dev\": true,\n      \"bin\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["181", {"page_content": "\"dev\": true,\n      \"bin\": {\n        \"eslint-config-prettier\": \"bin/cli.js\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \">=7.0.0\"\n      }\n    },\n    \"node_modules/eslint-import-resolver-node\": {\n      \"version\": \"0.3.7\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-import-resolver-node/-/eslint-import-resolver-node-0.3.7.tgz\",\n      \"integrity\": \"sha512-gozW2blMLJCeFpBwugLTGyvVjNoeo1knonXAcatC6bjPBZitotxdWf7Gimr25N4c0AAOo4eOUfaG82IJPDpqCA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"debug\": \"^3.2.7\",\n        \"is-core-module\": \"^2.11.0\",\n        \"resolve\": \"^1.22.1\"\n      }\n    },\n    \"node_modules/eslint-import-resolver-node/node_modules/debug\": {\n      \"version\": \"3.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.7.tgz\",\n      \"integrity\": \"sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ms\": \"^2.1.1\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["182", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"ms\": \"^2.1.1\"\n      }\n    },\n    \"node_modules/eslint-import-resolver-typescript\": {\n      \"version\": \"3.5.3\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-import-resolver-typescript/-/eslint-import-resolver-typescript-3.5.3.tgz\",\n      \"integrity\": \"sha512-njRcKYBc3isE42LaTcJNVANR3R99H9bAxBDMNDr2W7yq5gYPxbU3MkdhsQukxZ/Xg9C2vcyLlDsbKfRDg0QvCQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"debug\": \"^4.3.4\",\n        \"enhanced-resolve\": \"^5.10.0\",\n        \"get-tsconfig\": \"^4.2.0\",\n        \"globby\": \"^13.1.2\",\n        \"is-core-module\": \"^2.10.0\",\n        \"is-glob\": \"^4.0.3\",\n        \"synckit\": \"^0.8.4\"\n      },\n      \"engines\": {\n        \"node\": \"^14.18.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/unts/projects/eslint-import-resolver-ts\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"*\",\n        \"eslint-plugin-import\": \"*\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["183", {"page_content": "\"eslint\": \"*\",\n        \"eslint-plugin-import\": \"*\"\n      }\n    },\n    \"node_modules/eslint-import-resolver-typescript/node_modules/globby\": {\n      \"version\": \"13.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/globby/-/globby-13.1.3.tgz\",\n      \"integrity\": \"sha512-8krCNHXvlCgHDpegPzleMq07yMYTO2sXKASmZmquEYWEmCx6J5UTRbp5RwMJkTJGtcQ44YpiUYUiN0b9mzy8Bw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"dir-glob\": \"^3.0.1\",\n        \"fast-glob\": \"^3.2.11\",\n        \"ignore\": \"^5.2.0\",\n        \"merge2\": \"^1.4.1\",\n        \"slash\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/eslint-import-resolver-typescript/node_modules/slash\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/slash/-/slash-4.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["184", {"page_content": "\"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/slash/-/slash-4.0.0.tgz\",\n      \"integrity\": \"sha512-3dOsAHXXUkQTpOYcoAxLIorMTp4gIQr5IW3iVb7A7lFIp0VHhnynm9izx6TssdrIcVIESAlVjtnO2K8bg+Coew==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/eslint-module-utils\": {\n      \"version\": \"2.7.4\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-module-utils/-/eslint-module-utils-2.7.4.tgz\",\n      \"integrity\": \"sha512-j4GT+rqzCoRKHwURX7pddtIPGySnX9Si/cgMI5ztrcqOPtk5dDEeZ34CQVPphnqkJytlc97Vuk05Um2mJ3gEQA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"debug\": \"^3.2.7\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      },\n      \"peerDependenciesMeta\": {\n        \"eslint\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/eslint-module-utils/node_modules/debug\": {\n      \"version\": \"3.2.7\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["185", {"page_content": "},\n    \"node_modules/eslint-module-utils/node_modules/debug\": {\n      \"version\": \"3.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.7.tgz\",\n      \"integrity\": \"sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ms\": \"^2.1.1\"\n      }\n    },\n    \"node_modules/eslint-plugin-import\": {\n      \"version\": \"2.27.5\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-import/-/eslint-plugin-import-2.27.5.tgz\",\n      \"integrity\": \"sha512-LmEt3GVofgiGuiE+ORpnvP+kAm3h6MLZJ4Q5HCyHADofsb4VzXFsRiWj3c0OFiV+3DWFh0qg3v9gcPlfc3zRow==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"array-includes\": \"^3.1.6\",\n        \"array.prototype.flat\": \"^1.3.1\",\n        \"array.prototype.flatmap\": \"^1.3.1\",\n        \"debug\": \"^3.2.7\",\n        \"doctrine\": \"^2.1.0\",\n        \"eslint-import-resolver-node\": \"^0.3.7\",\n        \"eslint-module-utils\": \"^2.7.4\",\n        \"has\": \"^1.0.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["186", {"page_content": "\"eslint-module-utils\": \"^2.7.4\",\n        \"has\": \"^1.0.3\",\n        \"is-core-module\": \"^2.11.0\",\n        \"is-glob\": \"^4.0.3\",\n        \"minimatch\": \"^3.1.2\",\n        \"object.values\": \"^1.1.6\",\n        \"resolve\": \"^1.22.1\",\n        \"semver\": \"^6.3.0\",\n        \"tsconfig-paths\": \"^3.14.1\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^2 || ^3 || ^4 || ^5 || ^6 || ^7.2.0 || ^8\"\n      }\n    },\n    \"node_modules/eslint-plugin-import/node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/eslint-plugin-import/node_modules/debug\": {\n      \"version\": \"3.2.7\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["187", {"page_content": "},\n    \"node_modules/eslint-plugin-import/node_modules/debug\": {\n      \"version\": \"3.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.7.tgz\",\n      \"integrity\": \"sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ms\": \"^2.1.1\"\n      }\n    },\n    \"node_modules/eslint-plugin-import/node_modules/doctrine\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz\",\n      \"integrity\": \"sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"esutils\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/eslint-plugin-import/node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["188", {"page_content": "\"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/eslint-plugin-import/node_modules/semver\": {\n      \"version\": \"6.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",\n      \"integrity\": \"sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      }\n    },\n    \"node_modules/eslint-plugin-jsx-a11y\": {\n      \"version\": \"6.7.1\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-jsx-a11y/-/eslint-plugin-jsx-a11y-6.7.1.tgz\",\n      \"integrity\": \"sha512-63Bog4iIethyo8smBklORknVjB0T2dwB8Mr/hIC+fBS0uyHdYYpzM/Ed+YC8VxTjlXHEWFOdmgwcDn1U2L9VCA==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["189", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"@babel/runtime\": \"^7.20.7\",\n        \"aria-query\": \"^5.1.3\",\n        \"array-includes\": \"^3.1.6\",\n        \"array.prototype.flatmap\": \"^1.3.1\",\n        \"ast-types-flow\": \"^0.0.7\",\n        \"axe-core\": \"^4.6.2\",\n        \"axobject-query\": \"^3.1.1\",\n        \"damerau-levenshtein\": \"^1.0.8\",\n        \"emoji-regex\": \"^9.2.2\",\n        \"has\": \"^1.0.3\",\n        \"jsx-ast-utils\": \"^3.3.3\",\n        \"language-tags\": \"=1.0.5\",\n        \"minimatch\": \"^3.1.2\",\n        \"object.entries\": \"^1.1.6\",\n        \"object.fromentries\": \"^2.0.6\",\n        \"semver\": \"^6.3.0\"\n      },\n      \"engines\": {\n        \"node\": \">=4.0\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^3 || ^4 || ^5 || ^6 || ^7 || ^8\"\n      }\n    },\n    \"node_modules/eslint-plugin-jsx-a11y/node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["190", {"page_content": "\"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/eslint-plugin-jsx-a11y/node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/eslint-plugin-jsx-a11y/node_modules/semver\": {\n      \"version\": \"6.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["191", {"page_content": "\"version\": \"6.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",\n      \"integrity\": \"sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      }\n    },\n    \"node_modules/eslint-plugin-prettier\": {\n      \"version\": \"4.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-prettier/-/eslint-plugin-prettier-4.2.1.tgz\",\n      \"integrity\": \"sha512-f/0rXLXUt0oFYs8ra4w49wYZBG5GKZpAYsJSm6rnYL5uVDjd+zowwMwVZHnAjf4edNrKpCDYfXDgmRE/Ak7QyQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"prettier-linter-helpers\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=12.0.0\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \">=7.28.0\",\n        \"prettier\": \">=2.0.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"eslint-config-prettier\": {\n          \"optional\": true\n        }\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["192", {"page_content": "\"eslint-config-prettier\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/eslint-plugin-react\": {\n      \"version\": \"7.32.2\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-react/-/eslint-plugin-react-7.32.2.tgz\",\n      \"integrity\": \"sha512-t2fBMa+XzonrrNkyVirzKlvn5RXzzPwRHtMvLAtVZrt8oxgnTQaYbU6SXTOO1mwQgp1y5+toMSKInnzGr0Knqg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"array-includes\": \"^3.1.6\",\n        \"array.prototype.flatmap\": \"^1.3.1\",\n        \"array.prototype.tosorted\": \"^1.1.1\",\n        \"doctrine\": \"^2.1.0\",\n        \"estraverse\": \"^5.3.0\",\n        \"jsx-ast-utils\": \"^2.4.1 || ^3.0.0\",\n        \"minimatch\": \"^3.1.2\",\n        \"object.entries\": \"^1.1.6\",\n        \"object.fromentries\": \"^2.0.6\",\n        \"object.hasown\": \"^1.1.2\",\n        \"object.values\": \"^1.1.6\",\n        \"prop-types\": \"^15.8.1\",\n        \"resolve\": \"^2.0.0-next.4\",\n        \"semver\": \"^6.3.0\",\n        \"string.prototype.matchall\": \"^4.0.8\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["193", {"page_content": "\"semver\": \"^6.3.0\",\n        \"string.prototype.matchall\": \"^4.0.8\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^3 || ^4 || ^5 || ^6 || ^7 || ^8\"\n      }\n    },\n    \"node_modules/eslint-plugin-react-hooks\": {\n      \"version\": \"4.6.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-4.6.0.tgz\",\n      \"integrity\": \"sha512-oFc7Itz9Qxh2x4gNHStv3BqJq54ExXmfC+a1NjAta66IAN87Wu0R/QArgIS9qKzX3dXKPI9H5crl9QchNMY9+g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"peerDependencies\": {\n        \"eslint\": \"^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0\"\n      }\n    },\n    \"node_modules/eslint-plugin-react/node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["194", {"page_content": "\"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/eslint-plugin-react/node_modules/doctrine\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz\",\n      \"integrity\": \"sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"esutils\": \"^2.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/eslint-plugin-react/node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["195", {"page_content": "\"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/eslint-plugin-react/node_modules/resolve\": {\n      \"version\": \"2.0.0-next.4\",\n      \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-2.0.0-next.4.tgz\",\n      \"integrity\": \"sha512-iMDbmAWtfU+MHpxt/I5iWI7cY6YVEZUQ3MBgPQ++XD1PELuJHIl82xBmObyP2KyQmkNB2dsqF7seoQQiAn5yDQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-core-module\": \"^2.9.0\",\n        \"path-parse\": \"^1.0.7\",\n        \"supports-preserve-symlinks-flag\": \"^1.0.0\"\n      },\n      \"bin\": {\n        \"resolve\": \"bin/resolve\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["196", {"page_content": "},\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/eslint-plugin-react/node_modules/semver\": {\n      \"version\": \"6.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",\n      \"integrity\": \"sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==\",\n      \"dev\": true,\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      }\n    },\n    \"node_modules/eslint-scope\": {\n      \"version\": \"5.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz\",\n      \"integrity\": \"sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"esrecurse\": \"^4.3.0\",\n        \"estraverse\": \"^4.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8.0.0\"\n      }\n    },\n    \"node_modules/eslint-scope/node_modules/estraverse\": {\n      \"version\": \"4.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["197", {"page_content": "}\n    },\n    \"node_modules/eslint-scope/node_modules/estraverse\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz\",\n      \"integrity\": \"sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=4.0\"\n      }\n    },\n    \"node_modules/eslint-utils\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz\",\n      \"integrity\": \"sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"eslint-visitor-keys\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/mysticatea\"\n      }\n    },\n    \"node_modules/eslint-utils/node_modules/eslint-visitor-keys\": {\n      \"version\": \"1.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["198", {"page_content": "\"node_modules/eslint-utils/node_modules/eslint-visitor-keys\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz\",\n      \"integrity\": \"sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/eslint-visitor-keys\": {\n      \"version\": \"3.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.3.0.tgz\",\n      \"integrity\": \"sha512-mQ+suqKJVyeuwGYHAdjMFqjCyfl8+Ldnxuyp3ldiMBFKkvytrXUZWaiPCEav8qDHKty44bD+qV1IP4T+w+xXRA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \"^12.22.0 || ^14.17.0 || >=16.0.0\"\n      }\n    },\n    \"node_modules/eslint/node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["199", {"page_content": "\"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/eslint/node_modules/chalk\": {\n      \"version\": \"4.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz\",\n      \"integrity\": \"sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ansi-styles\": \"^4.1.0\",\n        \"supports-color\": \"^7.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/chalk?sponsor=1\"\n      }\n    },\n    \"node_modules/eslint/node_modules/eslint-visitor-keys\": {\n      \"version\": \"2.1.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["200", {"page_content": "},\n    \"node_modules/eslint/node_modules/eslint-visitor-keys\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz\",\n      \"integrity\": \"sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=10\"\n      }\n    },\n    \"node_modules/eslint/node_modules/has-flag\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n      \"integrity\": \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/eslint/node_modules/ignore\": {\n      \"version\": \"4.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["201", {"page_content": "\"version\": \"4.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",\n      \"integrity\": \"sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 4\"\n      }\n    },\n    \"node_modules/eslint/node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/eslint/node_modules/supports-color\": {\n      \"version\": \"7.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["202", {"page_content": "\"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",\n      \"integrity\": \"sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-flag\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/espree\": {\n      \"version\": \"7.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/espree/-/espree-7.3.1.tgz\",\n      \"integrity\": \"sha512-v3JCNCE64umkFpmkFGqzVKsOT0tN1Zr+ueqLZfpV1Ob8e+CEgPWa+OxCoGH3tnhimMKIaBm4m/vaRpJ/krRz2g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"acorn\": \"^7.4.0\",\n        \"acorn-jsx\": \"^5.3.1\",\n        \"eslint-visitor-keys\": \"^1.3.0\"\n      },\n      \"engines\": {\n        \"node\": \"^10.12.0 || >=12.0.0\"\n      }\n    },\n    \"node_modules/espree/node_modules/eslint-visitor-keys\": {\n      \"version\": \"1.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["203", {"page_content": "},\n    \"node_modules/espree/node_modules/eslint-visitor-keys\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz\",\n      \"integrity\": \"sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/esprima\": {\n      \"version\": \"4.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz\",\n      \"integrity\": \"sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==\",\n      \"bin\": {\n        \"esparse\": \"bin/esparse.js\",\n        \"esvalidate\": \"bin/esvalidate.js\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/esquery\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/esquery/-/esquery-1.5.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["204", {"page_content": "\"resolved\": \"https://registry.npmjs.org/esquery/-/esquery-1.5.0.tgz\",\n      \"integrity\": \"sha512-YQLXUplAwJgCydQ78IMJywZCceoqk1oH01OERdSAJc/7U2AylwjhSCLDEtqwg811idIS/9fIU5GjG73IgjKMVg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"estraverse\": \"^5.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10\"\n      }\n    },\n    \"node_modules/esrecurse\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz\",\n      \"integrity\": \"sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"estraverse\": \"^5.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">=4.0\"\n      }\n    },\n    \"node_modules/estraverse\": {\n      \"version\": \"5.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n      \"integrity\": \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["205", {"page_content": "\"dev\": true,\n      \"engines\": {\n        \"node\": \">=4.0\"\n      }\n    },\n    \"node_modules/esutils\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz\",\n      \"integrity\": \"sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/eventemitter3\": {\n      \"version\": \"4.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz\",\n      \"integrity\": \"sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==\"\n    },\n    \"node_modules/eventsource-parser\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-0.1.0.tgz\",\n      \"integrity\": \"sha512-M9QjFtEIkwytUarnx113HGmgtk52LSn3jNAtnWKi3V+b9rqSfQeVdLsaD5AG/O4IrGQwmAAHBIsqbmURPTd2rA==\",\n      \"engines\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["206", {"page_content": "\"engines\": {\n        \"node\": \">=14.18\"\n      }\n    },\n    \"node_modules/exponential-backoff\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/exponential-backoff/-/exponential-backoff-3.1.1.tgz\",\n      \"integrity\": \"sha512-dX7e/LHVJ6W3DE1MHWi9S1EYzDESENfLrYohG2G++ovZrYOkm4Knwa0mc1cn84xJOR4KEU0WSchhLbd0UklbHw==\"\n    },\n    \"node_modules/expr-eval\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/expr-eval/-/expr-eval-2.0.2.tgz\",\n      \"integrity\": \"sha512-4EMSHGOPSwAfBiibw3ndnP0AvjDWLsMvGOvWEZ2F96IGk0bIVdjQisOHxReSkE13mHcfbuCiXw+G4y0zv6N8Eg==\"\n    },\n    \"node_modules/external-editor\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/external-editor/-/external-editor-3.1.0.tgz\",\n      \"integrity\": \"sha512-hMQ4CX1p1izmuLYyZqLMO/qGNw10wSv9QDCPfzXfyFrOaCSSoRfqE1Kf1s5an66J5JZC62NewG+mK49jOCtQew==\",\n      \"dependencies\": {\n        \"chardet\": \"^0.7.0\",\n        \"iconv-lite\": \"^0.4.24\",\n        \"tmp\": \"^0.0.33\"", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["207", {"page_content": "\"chardet\": \"^0.7.0\",\n        \"iconv-lite\": \"^0.4.24\",\n        \"tmp\": \"^0.0.33\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/fast-deep-equal\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\",\n      \"integrity\": \"sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\",\n      \"dev\": true\n    },\n    \"node_modules/fast-diff\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/fast-diff/-/fast-diff-1.2.0.tgz\",\n      \"integrity\": \"sha512-xJuoT5+L99XlZ8twedaRf6Ax2TgQVxvgZOYoPKqZufmJib0tL2tegPBOZb1pVNgIhlqDlA0eO0c3wBvQcmzx4w==\",\n      \"dev\": true\n    },\n    \"node_modules/fast-glob\": {\n      \"version\": \"3.2.12\",\n      \"resolved\": \"https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.12.tgz\",\n      \"integrity\": \"sha512-DVj4CQIYYow0BlaelwK1pHl5n5cRSJfM60UA0zK891sVInoPri2Ekj7+e1CT3/3qxXenpI+nBBmQAcJPJgaj4w==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["208", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"@nodelib/fs.stat\": \"^2.0.2\",\n        \"@nodelib/fs.walk\": \"^1.2.3\",\n        \"glob-parent\": \"^5.1.2\",\n        \"merge2\": \"^1.3.0\",\n        \"micromatch\": \"^4.0.4\"\n      },\n      \"engines\": {\n        \"node\": \">=8.6.0\"\n      }\n    },\n    \"node_modules/fast-json-stable-stringify\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz\",\n      \"integrity\": \"sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==\",\n      \"dev\": true\n    },\n    \"node_modules/fast-levenshtein\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz\",\n      \"integrity\": \"sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==\",\n      \"dev\": true\n    },\n    \"node_modules/fastq\": {\n      \"version\": \"1.15.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["209", {"page_content": "\"dev\": true\n    },\n    \"node_modules/fastq\": {\n      \"version\": \"1.15.0\",\n      \"resolved\": \"https://registry.npmjs.org/fastq/-/fastq-1.15.0.tgz\",\n      \"integrity\": \"sha512-wBrocU2LCXXa+lWBt8RoIRD89Fi8OdABODa/kEnyeyjS5aZO5/GNvI5sEINADqP/h8M29UHTHUb53sUu5Ihqdw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"reusify\": \"^1.0.4\"\n      }\n    },\n    \"node_modules/figures\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/figures/-/figures-5.0.0.tgz\",\n      \"integrity\": \"sha512-ej8ksPF4x6e5wvK9yevct0UCXh8TTFlWGVLlgjZuoBH1HwjIfKE/IdL5mq89sFA7zELi1VhKpmtDnrs7zWyeyg==\",\n      \"dependencies\": {\n        \"escape-string-regexp\": \"^5.0.0\",\n        \"is-unicode-supported\": \"^1.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">=14\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/figures/node_modules/escape-string-regexp\": {\n      \"version\": \"5.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["210", {"page_content": "},\n    \"node_modules/figures/node_modules/escape-string-regexp\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-5.0.0.tgz\",\n      \"integrity\": \"sha512-/veY75JbMK4j1yjvuUxuVsiS/hr/4iHs9FTT6cgTexxdE0Ly/glccBAkloH/DofkjRbZU3bnoj38mOmhkZ0lHw==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/file-entry-cache\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz\",\n      \"integrity\": \"sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"flat-cache\": \"^3.0.4\"\n      },\n      \"engines\": {\n        \"node\": \"^10.12.0 || >=12.0.0\"\n      }\n    },\n    \"node_modules/file-uri-to-path\": {\n      \"version\": \"1.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["211", {"page_content": "}\n    },\n    \"node_modules/file-uri-to-path\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz\",\n      \"integrity\": \"sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==\"\n    },\n    \"node_modules/fill-range\": {\n      \"version\": \"7.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz\",\n      \"integrity\": \"sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"to-regex-range\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/flat-cache\": {\n      \"version\": \"3.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz\",\n      \"integrity\": \"sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["212", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"flatted\": \"^3.1.0\",\n        \"rimraf\": \"^3.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"^10.12.0 || >=12.0.0\"\n      }\n    },\n    \"node_modules/flatted\": {\n      \"version\": \"3.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/flatted/-/flatted-3.2.7.tgz\",\n      \"integrity\": \"sha512-5nqDSxl8nn5BSNxyR3n4I6eDmbolI6WT+QqR547RwxQapgjQBmtktdP+HTBb/a/zLsbzERTONyUB5pefh5TtjQ==\",\n      \"dev\": true\n    },\n    \"node_modules/follow-redirects\": {\n      \"version\": \"1.15.2\",\n      \"resolved\": \"https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.2.tgz\",\n      \"integrity\": \"sha512-VQLG33o04KaQ8uYi2tVNbdrWp1QWxNNea+nmIB4EVM28v0hmP17z7aG1+wAkNzVq4KeXTq3221ye5qTJP91JwA==\",\n      \"funding\": [\n        {\n          \"type\": \"individual\",\n          \"url\": \"https://github.com/sponsors/RubenVerborgh\"\n        }\n      ],\n      \"engines\": {\n        \"node\": \">=4.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"debug\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["213", {"page_content": "\"node\": \">=4.0\"\n      },\n      \"peerDependenciesMeta\": {\n        \"debug\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/for-each\": {\n      \"version\": \"0.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/for-each/-/for-each-0.3.3.tgz\",\n      \"integrity\": \"sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-callable\": \"^1.1.3\"\n      }\n    },\n    \"node_modules/form-data\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/form-data/-/form-data-4.0.0.tgz\",\n      \"integrity\": \"sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==\",\n      \"dependencies\": {\n        \"asynckit\": \"^0.4.0\",\n        \"combined-stream\": \"^1.0.8\",\n        \"mime-types\": \"^2.1.12\"\n      },\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/fs.realpath\": {\n      \"version\": \"1.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["214", {"page_content": "\"node\": \">= 6\"\n      }\n    },\n    \"node_modules/fs.realpath\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n      \"integrity\": \"sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==\",\n      \"dev\": true\n    },\n    \"node_modules/function-bind\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz\",\n      \"integrity\": \"sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==\",\n      \"dev\": true\n    },\n    \"node_modules/function.prototype.name\": {\n      \"version\": \"1.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/function.prototype.name/-/function.prototype.name-1.1.5.tgz\",\n      \"integrity\": \"sha512-uN7m/BzVKQnCUF/iW8jYea67v++2u7m5UgENbHRtdDVclOUP+FMPlCNdmk0h/ysGyo2tavMJEDqJAkJdRa1vMA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["215", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.3\",\n        \"es-abstract\": \"^1.19.0\",\n        \"functions-have-names\": \"^1.2.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/functional-red-black-tree\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz\",\n      \"integrity\": \"sha512-dsKNQNdj6xA3T+QlADDA7mOSlX0qiMINjn0cgr+eGHGsbSHzTabcIogz2+p/iqP1Xs6EP/sS2SbqH+brGTbq0g==\",\n      \"dev\": true\n    },\n    \"node_modules/functions-have-names\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/functions-have-names/-/functions-have-names-1.2.3.tgz\",\n      \"integrity\": \"sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==\",\n      \"dev\": true,\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["216", {"page_content": "\"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-intrinsic\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.0.tgz\",\n      \"integrity\": \"sha512-L049y6nFOuom5wGyRc3/gdTLO94dySVKRACj1RmJZBQXlbTMhtNIgkWkUHq+jYmZvKf14EW1EoJnnjbmoHij0Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"function-bind\": \"^1.1.1\",\n        \"has\": \"^1.0.3\",\n        \"has-symbols\": \"^1.0.3\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-symbol-description\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-symbol-description/-/get-symbol-description-1.0.0.tgz\",\n      \"integrity\": \"sha512-2EmdH1YvIQiZpltCNgkuiUnyukzxM/R6NDJX31Ke3BG1Nq5b0S2PhX59UKi9vZpPDQVdqn+1IcaAwnzTT5vCjw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["217", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/get-tsconfig\": {\n      \"version\": \"4.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.4.0.tgz\",\n      \"integrity\": \"sha512-0Gdjo/9+FzsYhXCEFueo2aY1z1tpXrxWZzP7k8ul9qt1U5o8rYJwTJYmaeHdrVosYIVYkOy2iwCJ9FdpocJhPQ==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/privatenumber/get-tsconfig?sponsor=1\"\n      }\n    },\n    \"node_modules/glob\": {\n      \"version\": \"7.1.7\",\n      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.1.7.tgz\",\n      \"integrity\": \"sha512-OvD9ENzPLbegENnYP5UUfJIirTg4+XwMWGaQfQTY0JenxNvvIKP3U3/tAQSPIu/lHxXYSZmpXlUHeqAIdKzBLQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"fs.realpath\": \"^1.0.0\",\n        \"inflight\": \"^1.0.4\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["218", {"page_content": "\"dependencies\": {\n        \"fs.realpath\": \"^1.0.0\",\n        \"inflight\": \"^1.0.4\",\n        \"inherits\": \"2\",\n        \"minimatch\": \"^3.0.4\",\n        \"once\": \"^1.3.0\",\n        \"path-is-absolute\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/glob-parent\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz\",\n      \"integrity\": \"sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-glob\": \"^4.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/glob/node_modules/brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["219", {"page_content": "\"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"node_modules/glob/node_modules/minimatch\": {\n      \"version\": \"3.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"brace-expansion\": \"^1.1.7\"\n      },\n      \"engines\": {\n        \"node\": \"*\"\n      }\n    },\n    \"node_modules/globals\": {\n      \"version\": \"13.20.0\",\n      \"resolved\": \"https://registry.npmjs.org/globals/-/globals-13.20.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["220", {"page_content": "\"resolved\": \"https://registry.npmjs.org/globals/-/globals-13.20.0.tgz\",\n      \"integrity\": \"sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"type-fest\": \"^0.20.2\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/globalthis\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/globalthis/-/globalthis-1.0.3.tgz\",\n      \"integrity\": \"sha512-sFdI5LyBiNTHjRd7cGPWapiHWMOXKyuBNX/cWJ3NfzrZQVa8GI/8cofCl74AOVqq9W5kNmguTIzJ/1s2gyI9wA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"define-properties\": \"^1.1.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/globalyzer\": {\n      \"version\": \"0.1.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["221", {"page_content": "}\n    },\n    \"node_modules/globalyzer\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/globalyzer/-/globalyzer-0.1.0.tgz\",\n      \"integrity\": \"sha512-40oNTM9UfG6aBmuKxk/giHn5nQ8RVz/SS4Ir6zgzOv9/qC3kKZ9v4etGTcJbEl/NyVQH7FGU7d+X1egr57Md2Q==\",\n      \"dev\": true\n    },\n    \"node_modules/globby\": {\n      \"version\": \"11.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/globby/-/globby-11.1.0.tgz\",\n      \"integrity\": \"sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"array-union\": \"^2.1.0\",\n        \"dir-glob\": \"^3.0.1\",\n        \"fast-glob\": \"^3.2.9\",\n        \"ignore\": \"^5.2.0\",\n        \"merge2\": \"^1.4.1\",\n        \"slash\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/globrex\": {\n      \"version\": \"0.1.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["222", {"page_content": "}\n    },\n    \"node_modules/globrex\": {\n      \"version\": \"0.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/globrex/-/globrex-0.1.2.tgz\",\n      \"integrity\": \"sha512-uHJgbwAMwNFf5mLst7IWLNg14x1CkeqglJb/K3doi4dw6q2IvAAmM/Y81kevy83wP+Sst+nutFTYOGg3d1lsxg==\",\n      \"dev\": true\n    },\n    \"node_modules/gopd\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz\",\n      \"integrity\": \"sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"get-intrinsic\": \"^1.1.3\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/gpt3-tokenizer\": {\n      \"version\": \"1.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/gpt3-tokenizer/-/gpt3-tokenizer-1.1.5.tgz\",\n      \"integrity\": \"sha512-O9iCL8MqGR0Oe9wTh0YftzIbysypNQmS5a5JG3cB3M4LMYjlAVvNnf8LUzVY9MrI7tj+YLY356uHtO2lLX2HpA==\",\n      \"dependencies\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["223", {"page_content": "\"dependencies\": {\n        \"array-keyed-map\": \"^2.1.3\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/graceful-fs\": {\n      \"version\": \"4.2.11\",\n      \"resolved\": \"https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz\",\n      \"integrity\": \"sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==\",\n      \"dev\": true\n    },\n    \"node_modules/grapheme-splitter\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/grapheme-splitter/-/grapheme-splitter-1.0.4.tgz\",\n      \"integrity\": \"sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ==\",\n      \"dev\": true\n    },\n    \"node_modules/has\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/has/-/has-1.0.3.tgz\",\n      \"integrity\": \"sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["224", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"function-bind\": \"^1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4.0\"\n      }\n    },\n    \"node_modules/has-bigints\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/has-bigints/-/has-bigints-1.0.2.tgz\",\n      \"integrity\": \"sha512-tSvCKtBr9lkF0Ex0aQiP9N+OpV4zi2r/Nee5VkRDbaqv35RLYMzbwQfFSZZH0kR+Rd6302UJZ2p/bJCEoR3VoQ==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-flag\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz\",\n      \"integrity\": \"sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/has-property-descriptors\": {\n      \"version\": \"1.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["225", {"page_content": "}\n    },\n    \"node_modules/has-property-descriptors\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.0.tgz\",\n      \"integrity\": \"sha512-62DVLZGoiEBDHQyqG4w9xCuZ7eJEwNmJRWw2VY84Oedb7WFcA27fiEVe8oUQx9hAUJ4ekurquucTGwsyO1XGdQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"get-intrinsic\": \"^1.1.1\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/has-proto/-/has-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-7qE+iP+O+bgF9clE5+UoBFzE65mlBiVj3tKCrlNQ0Ogwm0BjpT/gK4SlLYDMybDh5I3TCTKnPPa0oMG7JDYrhg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-symbols\": {\n      \"version\": \"1.0.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["226", {"page_content": "}\n    },\n    \"node_modules/has-symbols\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz\",\n      \"integrity\": \"sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/has-tostringtag\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.0.tgz\",\n      \"integrity\": \"sha512-kFjcSNhnlGV1kyoGk7OXKSawH5JOb/LzUc5w9B02hOTO0dfFRjbHQKvg1d6cf3HbeUmtU9VbbV3qzZ2Teh97WQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-symbols\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/hnswlib-node\": {\n      \"version\": \"1.4.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["227", {"page_content": "}\n    },\n    \"node_modules/hnswlib-node\": {\n      \"version\": \"1.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/hnswlib-node/-/hnswlib-node-1.4.2.tgz\",\n      \"integrity\": \"sha512-76PIzOaNcX8kOpKwlFPl07uelpctqDMzbiC+Qsk2JWNVkzeU/6iXRk4tfE9z3DoK1RCBrOaFXmQ6RFb1BVF9LA==\",\n      \"hasInstallScript\": true,\n      \"dependencies\": {\n        \"bindings\": \"^1.5.0\",\n        \"node-addon-api\": \"^6.0.0\"\n      }\n    },\n    \"node_modules/iconv-lite\": {\n      \"version\": \"0.4.24\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz\",\n      \"integrity\": \"sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==\",\n      \"dependencies\": {\n        \"safer-buffer\": \">= 2.1.2 < 3\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/ieee754\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["228", {"page_content": "\"resolved\": \"https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz\",\n      \"integrity\": \"sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ]\n    },\n    \"node_modules/ignore\": {\n      \"version\": \"5.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-5.2.4.tgz\",\n      \"integrity\": \"sha512-MAb38BcSbH0eHNBxn7ql2NH/kX33OkB3lZ1BNdh7ENeRChHTYsTvWrMubiIAMNS2llXEEgZ1MUOBtXChP3kaFQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 4\"\n      }\n    },\n    \"node_modules/import-fresh\": {\n      \"version\": \"3.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["229", {"page_content": "\"resolved\": \"https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz\",\n      \"integrity\": \"sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"parent-module\": \"^1.0.0\",\n        \"resolve-from\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/imurmurhash\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz\",\n      \"integrity\": \"sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.8.19\"\n      }\n    },\n    \"node_modules/inflight\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["230", {"page_content": "\"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n      \"integrity\": \"sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"once\": \"^1.3.0\",\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/inherits\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\"\n    },\n    \"node_modules/inquirer\": {\n      \"version\": \"9.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/inquirer/-/inquirer-9.1.5.tgz\",\n      \"integrity\": \"sha512-3ygAIh8gcZavV9bj6MTdYddG2zPSYswP808fKS46NOwlF0zZljVpnLCHODDqItWJDbDpLb3aouAxGaJbkxoppA==\",\n      \"dependencies\": {\n        \"ansi-escapes\": \"^6.0.0\",\n        \"chalk\": \"^5.2.0\",\n        \"cli-cursor\": \"^4.0.0\",\n        \"cli-width\": \"^4.0.0\",\n        \"external-editor\": \"^3.0.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["231", {"page_content": "\"cli-cursor\": \"^4.0.0\",\n        \"cli-width\": \"^4.0.0\",\n        \"external-editor\": \"^3.0.3\",\n        \"figures\": \"^5.0.0\",\n        \"lodash\": \"^4.17.21\",\n        \"mute-stream\": \"1.0.0\",\n        \"ora\": \"^6.1.2\",\n        \"run-async\": \"^2.4.0\",\n        \"rxjs\": \"^7.8.0\",\n        \"string-width\": \"^5.1.2\",\n        \"strip-ansi\": \"^7.0.1\",\n        \"through\": \"^2.3.6\",\n        \"wrap-ansi\": \"^8.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=14.18.0\"\n      }\n    },\n    \"node_modules/inquirer/node_modules/ansi-regex\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz\",\n      \"integrity\": \"sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-regex?sponsor=1\"\n      }\n    },\n    \"node_modules/inquirer/node_modules/string-width\": {\n      \"version\": \"5.1.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["232", {"page_content": "}\n    },\n    \"node_modules/inquirer/node_modules/string-width\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz\",\n      \"integrity\": \"sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==\",\n      \"dependencies\": {\n        \"eastasianwidth\": \"^0.2.0\",\n        \"emoji-regex\": \"^9.2.2\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/inquirer/node_modules/strip-ansi\": {\n      \"version\": \"7.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz\",\n      \"integrity\": \"sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["233", {"page_content": "},\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/strip-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/internal-slot\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/internal-slot/-/internal-slot-1.0.5.tgz\",\n      \"integrity\": \"sha512-Y+R5hJrzs52QCG2laLn4udYVnxsfny9CpOhNhUvk/SSSVyF6T27FzRbF0sroPidSu3X8oEAkOn2K804mjpt6UQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"get-intrinsic\": \"^1.2.0\",\n        \"has\": \"^1.0.3\",\n        \"side-channel\": \"^1.0.4\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/is-arguments\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-arguments/-/is-arguments-1.1.1.tgz\",\n      \"integrity\": \"sha512-8Q7EARjzEnKpt/PCD7e1cgUS0a6X8u5tdSiMqXhojOdoV9TsMsiO+9VLC5vAmO8N7/GmXn7yjR8qnA6bVAEzfA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["234", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-array-buffer\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-array-buffer/-/is-array-buffer-3.0.2.tgz\",\n      \"integrity\": \"sha512-y+FyyR/w8vfIRq4eQcM1EYgSTnmHXPqaF+IgzgraytCFq5Xh8lllDVmAZolPJiZttZLeFSINPYMaEJ7/vWUa1w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.2.0\",\n        \"is-typed-array\": \"^1.1.10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-bigint\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/is-bigint/-/is-bigint-1.0.4.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["235", {"page_content": "\"resolved\": \"https://registry.npmjs.org/is-bigint/-/is-bigint-1.0.4.tgz\",\n      \"integrity\": \"sha512-zB9CruMamjym81i2JZ3UMn54PKGsQzsJeo6xvN3HJJ4CAsQNB6iRutp2To77OfCNuoxspsIhzaPoO1zyCEhFOg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-bigints\": \"^1.0.1\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-binary-path\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz\",\n      \"integrity\": \"sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==\",\n      \"dependencies\": {\n        \"binary-extensions\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/is-boolean-object\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-boolean-object/-/is-boolean-object-1.1.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["236", {"page_content": "\"resolved\": \"https://registry.npmjs.org/is-boolean-object/-/is-boolean-object-1.1.2.tgz\",\n      \"integrity\": \"sha512-gDYaKHJmnj4aWxyj6YHyXVpdQawtVLHU5cb+eztPGczf6cjuTdwve5ZIEfgXqH4e57An1D1AKf8CZ3kYrQRqYA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-callable\": {\n      \"version\": \"1.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz\",\n      \"integrity\": \"sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-core-module\": {\n      \"version\": \"2.11.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["237", {"page_content": "}\n    },\n    \"node_modules/is-core-module\": {\n      \"version\": \"2.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-core-module/-/is-core-module-2.11.0.tgz\",\n      \"integrity\": \"sha512-RRjxlvLDkD1YJwDbroBHMb+cukurkDWNyHx7D3oNB5x9rb5ogcksMC5wHCadcXoo67gVr/+3GFySh3134zi6rw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has\": \"^1.0.3\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-date-object\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/is-date-object/-/is-date-object-1.0.5.tgz\",\n      \"integrity\": \"sha512-9YQaSxsAiSwcvS33MBk3wTCVnWK+HhF8VZR2jRxehM16QcVOdHqPn4VPHmRK4lSr38n9JriurInLcP90xsYNfQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-docker\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["238", {"page_content": "\"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-docker\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-docker/-/is-docker-2.2.1.tgz\",\n      \"integrity\": \"sha512-F+i2BKsFrH66iaUFc0woD8sLy8getkwTwtOBjvs56Cx4CgJDeKQeqfz8wAYiSb8JOprWhHH5p77PbmYCvvUuXQ==\",\n      \"dev\": true,\n      \"bin\": {\n        \"is-docker\": \"cli.js\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/is-extglob\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz\",\n      \"integrity\": \"sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/is-fullwidth-code-point\": {\n      \"version\": \"3.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["239", {"page_content": "}\n    },\n    \"node_modules/is-fullwidth-code-point\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz\",\n      \"integrity\": \"sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/is-glob\": {\n      \"version\": \"4.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz\",\n      \"integrity\": \"sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-extglob\": \"^2.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/is-interactive\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-interactive/-/is-interactive-2.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["240", {"page_content": "\"resolved\": \"https://registry.npmjs.org/is-interactive/-/is-interactive-2.0.0.tgz\",\n      \"integrity\": \"sha512-qP1vozQRI+BMOPcjFzrjXuQvdak2pHNUMZoeG2eRbiSqyvbEf/wQtEOTOX1guk6E3t36RkaqiSt8A/6YElNxLQ==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/is-map\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-map/-/is-map-2.0.2.tgz\",\n      \"integrity\": \"sha512-cOZFQQozTha1f4MxLFzlgKYPTyj26picdZTx82hbc/Xf4K/tZOOXSCkMvU4pKioRXGDLJRn0GM7Upe7kR721yg==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-negative-zero\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-negative-zero/-/is-negative-zero-2.0.2.tgz\",\n      \"integrity\": \"sha512-dqJvarLawXsFbNDeJW7zAz8ItJ9cd28YufuuFzh0G8pNHjJMnY08Dv7sYX2uF5UpQOwieAeOExEYAWWfu7ZZUA==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["241", {"page_content": "\"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-number\": {\n      \"version\": \"7.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz\",\n      \"integrity\": \"sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.12.0\"\n      }\n    },\n    \"node_modules/is-number-object\": {\n      \"version\": \"1.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/is-number-object/-/is-number-object-1.0.7.tgz\",\n      \"integrity\": \"sha512-k1U0IRzLMo7ZlYIfzRu23Oh6MiIFasgpb9X76eqfFZAqwH44UI4KTBvBYIZ1dSL9ZzChTB9ShHfLkR4pdW5krQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["242", {"page_content": "},\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-regex\": {\n      \"version\": \"1.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/is-regex/-/is-regex-1.1.4.tgz\",\n      \"integrity\": \"sha512-kvRdxDsxZjhzUX07ZnLydzS1TU/TJlTUHHY4YLL87e37oUA49DfkLqgy+VjFocowy29cKvcSiu+kIv728jTTVg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-set\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-set/-/is-set-2.0.2.tgz\",\n      \"integrity\": \"sha512-+2cnTEZeY5z/iXGbLhPrOAaK/Mau5k5eXq9j14CpRTftq0pAJu2MwVRSZhyZWBzx3o6X795Lz6Bpb6R0GKf37g==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["243", {"page_content": "\"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-shared-array-buffer\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-shared-array-buffer/-/is-shared-array-buffer-1.0.2.tgz\",\n      \"integrity\": \"sha512-sqN2UDu1/0y6uvXyStCOzyhAjCSlHceFoMKJW8W9EU9cvic/QdsZ0kEU93HEy3IUEFZIiH/3w+AH/UQbPHNdhA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-string\": {\n      \"version\": \"1.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/is-string/-/is-string-1.0.7.tgz\",\n      \"integrity\": \"sha512-tE2UXzivje6ofPW7l23cjDOMa09gb7xlAqG6jG5ej6uPV32TlWP3NKPigtaGeHNu9fohccRYvIiZMfOOnOYUtg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["244", {"page_content": "},\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-symbol\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/is-symbol/-/is-symbol-1.0.4.tgz\",\n      \"integrity\": \"sha512-C/CPBqKWnvdcxqIARxyOh4v1UUEOCHpgDa0WYgpKDFMszcrPcffg5uhwSgPCLD2WWxmq6isisz87tzT01tuGhg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-symbols\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-typed-array\": {\n      \"version\": \"1.1.10\",\n      \"resolved\": \"https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.10.tgz\",\n      \"integrity\": \"sha512-PJqgEHiWZvMpaFZ3uTc8kHPM4+4ADTlDniuQL7cU/UDA0Ql7F70yGfHph3cLNe+c9toaigv+DFzTJKhc2CtO6A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"available-typed-arrays\": \"^1.0.5\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["245", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"available-typed-arrays\": \"^1.0.5\",\n        \"call-bind\": \"^1.0.2\",\n        \"for-each\": \"^0.3.3\",\n        \"gopd\": \"^1.0.1\",\n        \"has-tostringtag\": \"^1.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-unicode-supported\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-1.3.0.tgz\",\n      \"integrity\": \"sha512-43r2mRvz+8JRIKnWJ+3j8JtjRKZ6GmjzfaE/qiBJnikNnYv/6bagRJ1kUhNk8R5EX/GkobD+r+sfxCPJsiKBLQ==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/is-weakmap\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-weakmap/-/is-weakmap-2.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["246", {"page_content": "\"resolved\": \"https://registry.npmjs.org/is-weakmap/-/is-weakmap-2.0.1.tgz\",\n      \"integrity\": \"sha512-NSBR4kH5oVj1Uwvv970ruUkCV7O1mzgVFO4/rev2cLRda9Tm9HrL70ZPut4rOHgY0FNrUu9BCbXA2sdQ+x0chA==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-weakref\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-weakref/-/is-weakref-1.0.2.tgz\",\n      \"integrity\": \"sha512-qctsuLZmIQ0+vSSMfoVvyFe2+GSEvnmZ2ezTup1SBse9+twCCeial6EEi3Nc2KFcf6+qz2FBPnjXsk8xhKSaPQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-weakset\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-weakset/-/is-weakset-2.0.2.tgz\",\n      \"integrity\": \"sha512-t2yVvttHkQktwnNNmBQ98AhENLdPUTDTE21uPqAQ0ARwQfGeQKRVS0NNurH7bTf7RrvcVn1OOge45CnBeHCSmg==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["247", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.1\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/is-wsl\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-wsl/-/is-wsl-2.2.0.tgz\",\n      \"integrity\": \"sha512-fKzAra0rGJUUBwGBgNkHZuToZcn+TtXHpeCgmkMJMMYx1sQDYaCSyjJBSCa2nH1DGm7s3n1oBnohoVTBaN7Lww==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-docker\": \"^2.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/isarray\": {\n      \"version\": \"2.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz\",\n      \"integrity\": \"sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==\",\n      \"dev\": true\n    },\n    \"node_modules/isexe\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["248", {"page_content": "\"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n      \"integrity\": \"sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==\",\n      \"dev\": true\n    },\n    \"node_modules/istextorbinary\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/istextorbinary/-/istextorbinary-6.0.0.tgz\",\n      \"integrity\": \"sha512-4j3UqQCa06GAf6QHlN3giz2EeFU7qc6Q5uB/aY7Gmb3xmLDLepDOtsZqkb4sCfJgFvTbLUinNw0kHgHs8XOHoQ==\",\n      \"dependencies\": {\n        \"binaryextensions\": \"^4.18.0\",\n        \"textextensions\": \"^5.14.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://bevry.me/fund\"\n      }\n    },\n    \"node_modules/js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["249", {"page_content": "\"dev\": true\n    },\n    \"node_modules/js-yaml\": {\n      \"version\": \"3.14.1\",\n      \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz\",\n      \"integrity\": \"sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"argparse\": \"^1.0.7\",\n        \"esprima\": \"^4.0.0\"\n      },\n      \"bin\": {\n        \"js-yaml\": \"bin/js-yaml.js\"\n      }\n    },\n    \"node_modules/json-schema-traverse\": {\n      \"version\": \"0.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz\",\n      \"integrity\": \"sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==\",\n      \"dev\": true\n    },\n    \"node_modules/json-stable-stringify-without-jsonify\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["250", {"page_content": "\"integrity\": \"sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==\",\n      \"dev\": true\n    },\n    \"node_modules/json5\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/json5/-/json5-1.0.2.tgz\",\n      \"integrity\": \"sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"minimist\": \"^1.2.0\"\n      },\n      \"bin\": {\n        \"json5\": \"lib/cli.js\"\n      }\n    },\n    \"node_modules/jsonpointer\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/jsonpointer/-/jsonpointer-5.0.1.tgz\",\n      \"integrity\": \"sha512-p/nXbhSEcu3pZRdkW1OfJhpsVtW1gd4Wa1fnQc9YLiTfAjn0312eMKimbdIQzuZl9aa9xUGaRlP9T/CJE/ditQ==\",\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/jsx-ast-utils\": {\n      \"version\": \"3.3.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["251", {"page_content": "}\n    },\n    \"node_modules/jsx-ast-utils\": {\n      \"version\": \"3.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/jsx-ast-utils/-/jsx-ast-utils-3.3.3.tgz\",\n      \"integrity\": \"sha512-fYQHZTZ8jSfmWZ0iyzfwiU4WDX4HpHbMCZ3gPlWYiCl3BoeOTsqKBqnTVfH2rYT7eP5c3sVbeSPHnnJOaTrWiw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"array-includes\": \"^3.1.5\",\n        \"object.assign\": \"^4.1.3\"\n      },\n      \"engines\": {\n        \"node\": \">=4.0\"\n      }\n    },\n    \"node_modules/langchain\": {\n      \"version\": \"0.0.39\",\n      \"resolved\": \"https://registry.npmjs.org/langchain/-/langchain-0.0.39.tgz\",\n      \"integrity\": \"sha512-vBdCHYWtP05j6/trnVKZ+tic6oF2GOJKnCtm4/cxgHrdAkxq2eQ3dju4eYuXI4jIVyeGYsFCg3R7t2P8mdv1eg==\",\n      \"dependencies\": {\n        \"browser-or-node\": \"^2.1.1\",\n        \"eventsource-parser\": \"^0.1.0\",\n        \"exponential-backoff\": \"^3.1.0\",\n        \"expr-eval\": \"^2.0.2\",\n        \"gpt3-tokenizer\": \"^1.1.5\",\n        \"is-binary-path\": \"^2.1.0\",\n        \"jsonpointer\": \"^5.0.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["252", {"page_content": "\"is-binary-path\": \"^2.1.0\",\n        \"jsonpointer\": \"^5.0.1\",\n        \"object-hash\": \"^3.0.0\",\n        \"openai\": \"^3.2.0\",\n        \"p-queue\": \"^7.3.4\",\n        \"uuid\": \"^9.0.0\",\n        \"yaml\": \"^2.2.1\",\n        \"zod\": \"^3.21.4\"\n      },\n      \"peerDependencies\": {\n        \"@dqbd/tiktoken\": \"^1.0.2\",\n        \"@huggingface/inference\": \"^1.5.1\",\n        \"@pinecone-database/pinecone\": \"^0.0.10\",\n        \"@supabase/supabase-js\": \"^2.10.0\",\n        \"cheerio\": \"^1.0.0-rc.12\",\n        \"chromadb\": \"^1.3.0\",\n        \"cohere-ai\": \"^5.0.2\",\n        \"d3-dsv\": \"^3.0.1\",\n        \"hnswlib-node\": \"^1.4.2\",\n        \"pdf-parse\": \"^1.1.1\",\n        \"puppeteer\": \"^19.7.2\",\n        \"redis\": \"^4.6.4\",\n        \"serpapi\": \"^1.1.1\",\n        \"srt-parser-2\": \"^1.2.2\",\n        \"typeorm\": \"^0.3.12\"\n      },\n      \"peerDependenciesMeta\": {\n        \"@dqbd/tiktoken\": {\n          \"optional\": true\n        },\n        \"@huggingface/inference\": {\n          \"optional\": true\n        },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["253", {"page_content": "},\n        \"@huggingface/inference\": {\n          \"optional\": true\n        },\n        \"@pinecone-database/pinecone\": {\n          \"optional\": true\n        },\n        \"@supabase/supabase-js\": {\n          \"optional\": true\n        },\n        \"cheerio\": {\n          \"optional\": true\n        },\n        \"chromadb\": {\n          \"optional\": true\n        },\n        \"cohere-ai\": {\n          \"optional\": true\n        },\n        \"d3-dsv\": {\n          \"optional\": true\n        },\n        \"hnswlib-node\": {\n          \"optional\": true\n        },\n        \"pdf-parse\": {\n          \"optional\": true\n        },\n        \"puppeteer\": {\n          \"optional\": true\n        },\n        \"redis\": {\n          \"optional\": true\n        },\n        \"serpapi\": {\n          \"optional\": true\n        },\n        \"srt-parser-2\": {\n          \"optional\": true\n        },\n        \"typeorm\": {\n          \"optional\": true\n        }\n      }\n    },\n    \"node_modules/language-subtag-registry\": {\n      \"version\": \"0.3.22\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["254", {"page_content": "}\n      }\n    },\n    \"node_modules/language-subtag-registry\": {\n      \"version\": \"0.3.22\",\n      \"resolved\": \"https://registry.npmjs.org/language-subtag-registry/-/language-subtag-registry-0.3.22.tgz\",\n      \"integrity\": \"sha512-tN0MCzyWnoz/4nHS6uxdlFWoUZT7ABptwKPQ52Ea7URk6vll88bWBVhodtnlfEuCcKWNGoc+uGbw1cwa9IKh/w==\",\n      \"dev\": true\n    },\n    \"node_modules/language-tags\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/language-tags/-/language-tags-1.0.5.tgz\",\n      \"integrity\": \"sha512-qJhlO9cGXi6hBGKoxEG/sKZDAHD5Hnu9Hs4WbOY3pCWXDhw0N8x1NenNzm2EnNLkLkk7J2SdxAkDSbb6ftT+UQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"language-subtag-registry\": \"~0.3.2\"\n      }\n    },\n    \"node_modules/levn\": {\n      \"version\": \"0.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/levn/-/levn-0.4.1.tgz\",\n      \"integrity\": \"sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["255", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"prelude-ls\": \"^1.2.1\",\n        \"type-check\": \"~0.4.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8.0\"\n      }\n    },\n    \"node_modules/lodash\": {\n      \"version\": \"4.17.21\",\n      \"resolved\": \"https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz\",\n      \"integrity\": \"sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==\"\n    },\n    \"node_modules/lodash.merge\": {\n      \"version\": \"4.6.2\",\n      \"resolved\": \"https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz\",\n      \"integrity\": \"sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==\",\n      \"dev\": true\n    },\n    \"node_modules/lodash.truncate\": {\n      \"version\": \"4.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/lodash.truncate/-/lodash.truncate-4.4.2.tgz\",\n      \"integrity\": \"sha512-jttmRe7bRse52OsWIMDLaXxWqRAmtIUccAQ3garviCqJjafXOfNMO0yMfNpdD6zbGaTU0P5Nz7e7gAT6cKmJRw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["256", {"page_content": "\"dev\": true\n    },\n    \"node_modules/log-symbols\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/log-symbols/-/log-symbols-5.1.0.tgz\",\n      \"integrity\": \"sha512-l0x2DvrW294C9uDCoQe1VSU4gf529FkSZ6leBl4TiqZH/e+0R7hSfHQBNut2mNygDgHwvYHfFLn6Oxb3VWj2rA==\",\n      \"dependencies\": {\n        \"chalk\": \"^5.0.0\",\n        \"is-unicode-supported\": \"^1.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/loose-envify\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz\",\n      \"integrity\": \"sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"js-tokens\": \"^3.0.0 || ^4.0.0\"\n      },\n      \"bin\": {\n        \"loose-envify\": \"cli.js\"\n      }\n    },\n    \"node_modules/lru-cache\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["257", {"page_content": "\"bin\": {\n        \"loose-envify\": \"cli.js\"\n      }\n    },\n    \"node_modules/lru-cache\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz\",\n      \"integrity\": \"sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"yallist\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      }\n    },\n    \"node_modules/marked\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/marked/-/marked-4.3.0.tgz\",\n      \"integrity\": \"sha512-PRsaiG84bK+AMvxziE/lCFss8juXjNaWzVbN5tXAm4XjeaS9NAHhop+PjQxz2A9h8Q4M/xGmzP8vqNwy6JeK0A==\",\n      \"bin\": {\n        \"marked\": \"bin/marked.js\"\n      },\n      \"engines\": {\n        \"node\": \">= 12\"\n      }\n    },\n    \"node_modules/marked-terminal\": {\n      \"version\": \"5.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/marked-terminal/-/marked-terminal-5.1.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["258", {"page_content": "\"resolved\": \"https://registry.npmjs.org/marked-terminal/-/marked-terminal-5.1.1.tgz\",\n      \"integrity\": \"sha512-+cKTOx9P4l7HwINYhzbrBSyzgxO2HaHKGZGuB1orZsMIgXYaJyfidT81VXRdpelW/PcHEWxywscePVgI/oUF6g==\",\n      \"dependencies\": {\n        \"ansi-escapes\": \"^5.0.0\",\n        \"cardinal\": \"^2.1.1\",\n        \"chalk\": \"^5.0.0\",\n        \"cli-table3\": \"^0.6.1\",\n        \"node-emoji\": \"^1.11.0\",\n        \"supports-hyperlinks\": \"^2.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">=14.13.1 || >=16.0.0\"\n      },\n      \"peerDependencies\": {\n        \"marked\": \"^1.0.0 || ^2.0.0 || ^3.0.0 || ^4.0.0\"\n      }\n    },\n    \"node_modules/marked-terminal/node_modules/ansi-escapes\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-5.0.0.tgz\",\n      \"integrity\": \"sha512-5GFMVX8HqE/TB+FuBJGuO5XG0WrsA6ptUqoODaT/n9mmUaZFkqnBueB4leqGBCmrUHnCnC4PCZTCd0E7QQ83bA==\",\n      \"dependencies\": {\n        \"type-fest\": \"^1.0.2\"\n      },\n      \"engines\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["259", {"page_content": "\"dependencies\": {\n        \"type-fest\": \"^1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/marked-terminal/node_modules/type-fest\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/type-fest/-/type-fest-1.4.0.tgz\",\n      \"integrity\": \"sha512-yGSza74xk0UG8k+pLh5oeoYirvIiWo5t0/o3zHHAO2tRDiZcxWP7fywNlXhqb6/r6sWvwi+RsyQMWhVLe4BVuA==\",\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/merge2\": {\n      \"version\": \"1.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz\",\n      \"integrity\": \"sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/micromatch\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["260", {"page_content": "\"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/micromatch\": {\n      \"version\": \"4.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz\",\n      \"integrity\": \"sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"braces\": \"^3.0.2\",\n        \"picomatch\": \"^2.3.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8.6\"\n      }\n    },\n    \"node_modules/mime-db\": {\n      \"version\": \"1.52.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz\",\n      \"integrity\": \"sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==\",\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/mime-types\": {\n      \"version\": \"2.1.35\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["261", {"page_content": "\"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz\",\n      \"integrity\": \"sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==\",\n      \"dependencies\": {\n        \"mime-db\": \"1.52.0\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.6\"\n      }\n    },\n    \"node_modules/mimic-fn\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz\",\n      \"integrity\": \"sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==\",\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/minimatch\": {\n      \"version\": \"7.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-7.4.3.tgz\",\n      \"integrity\": \"sha512-5UB4yYusDtkRPbRiy1cqZ1IpGNcJCGlEMG17RKzPddpyiPKoCdwohbED8g4QXT0ewCt8LTkQXuljsUfQ3FKM4A==\",\n      \"dependencies\": {\n        \"brace-expansion\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["262", {"page_content": "\"brace-expansion\": \"^2.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/minimist\": {\n      \"version\": \"1.2.8\",\n      \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz\",\n      \"integrity\": \"sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/ms\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\",\n      \"integrity\": \"sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==\",\n      \"dev\": true\n    },\n    \"node_modules/mute-stream\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/mute-stream/-/mute-stream-1.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["263", {"page_content": "\"resolved\": \"https://registry.npmjs.org/mute-stream/-/mute-stream-1.0.0.tgz\",\n      \"integrity\": \"sha512-avsJQhyd+680gKXyG/sQc0nXaC6rBkPOfyHYcFb9+hdkqQkR9bdnkJ0AMZhke0oesPqIO+mFFJ+IdBc7mst4IA==\",\n      \"engines\": {\n        \"node\": \"^14.17.0 || ^16.13.0 || >=18.0.0\"\n      }\n    },\n    \"node_modules/natural-compare\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz\",\n      \"integrity\": \"sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==\",\n      \"dev\": true\n    },\n    \"node_modules/natural-compare-lite\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/natural-compare-lite/-/natural-compare-lite-1.4.0.tgz\",\n      \"integrity\": \"sha512-Tj+HTDSJJKaZnfiuw+iaF9skdPpTo2GtEly5JHnWV/hfv2Qj/9RKsGISQtLh2ox3l5EAGw487hnBee0sIJ6v2g==\",\n      \"dev\": true\n    },\n    \"node_modules/node-addon-api\": {\n      \"version\": \"6.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["264", {"page_content": "\"dev\": true\n    },\n    \"node_modules/node-addon-api\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/node-addon-api/-/node-addon-api-6.0.0.tgz\",\n      \"integrity\": \"sha512-GyHvgPvUXBvAkXa0YvYnhilSB1A+FRYMpIVggKzPZqdaZfevZOuzfWzyvgzOwRLHBeo/MMswmJFsrNF4Nw1pmA==\"\n    },\n    \"node_modules/node-emoji\": {\n      \"version\": \"1.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/node-emoji/-/node-emoji-1.11.0.tgz\",\n      \"integrity\": \"sha512-wo2DpQkQp7Sjm2A0cq+sN7EHKO6Sl0ctXeBdFZrL9T9+UywORbufTcTZxom8YqpLQt/FqNMUkOpkZrJVYSKD3A==\",\n      \"dependencies\": {\n        \"lodash\": \"^4.17.21\"\n      }\n    },\n    \"node_modules/object-assign\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz\",\n      \"integrity\": \"sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["265", {"page_content": "\"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/object-hash\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz\",\n      \"integrity\": \"sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==\",\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/object-inspect\": {\n      \"version\": \"1.12.3\",\n      \"resolved\": \"https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.3.tgz\",\n      \"integrity\": \"sha512-geUvdk7c+eizMNUDkRpW1wJwgfOiOeHbxBR/hLXK1aT6zmVSO0jsQcs7fj6MGw89jC/cjGfLcNOrtMYtGqm81g==\",\n      \"dev\": true,\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/object-is\": {\n      \"version\": \"1.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/object-is/-/object-is-1.1.5.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["266", {"page_content": "\"resolved\": \"https://registry.npmjs.org/object-is/-/object-is-1.1.5.tgz\",\n      \"integrity\": \"sha512-3cyDsyHgtmi7I7DfSSI2LDp6SK2lwvtbg0p0R1e0RvTqF5ceGx+K2dfSjm1bKDMVCFEDAQvy+o8c6a7VujOddw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/object-keys\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz\",\n      \"integrity\": \"sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/object.assign\": {\n      \"version\": \"4.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/object.assign/-/object.assign-4.1.4.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["267", {"page_content": "\"resolved\": \"https://registry.npmjs.org/object.assign/-/object.assign-4.1.4.tgz\",\n      \"integrity\": \"sha512-1mxKf0e58bvyjSCtKYY4sRe9itRk3PJpquJOjeIkz885CczcI4IvJJDLPS72oowuSh+pBxUFROpX+TU++hxhZQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"has-symbols\": \"^1.0.3\",\n        \"object-keys\": \"^1.1.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/object.entries\": {\n      \"version\": \"1.1.6\",\n      \"resolved\": \"https://registry.npmjs.org/object.entries/-/object.entries-1.1.6.tgz\",\n      \"integrity\": \"sha512-leTPzo4Zvg3pmbQ3rDK69Rl8GQvIqMWubrkxONG9/ojtFE2rD9fjMKfSI5BxW3osRH1m6VdzmqK8oAY9aT4x5w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"engines\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["268", {"page_content": "\"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/object.fromentries\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/object.fromentries/-/object.fromentries-2.0.6.tgz\",\n      \"integrity\": \"sha512-VciD13dswC4j1Xt5394WR4MzmAQmlgN72phd/riNp9vtD7tp4QQWJ0R4wvclXcafgcYK8veHRed2W6XeGBvcfg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/object.hasown\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/object.hasown/-/object.hasown-1.1.2.tgz\",\n      \"integrity\": \"sha512-B5UIT3J1W+WuWIU55h0mjlwaqxiE5vYENJXIXZ4VFe05pNYrkKuK0U/6aFcb0pKywYJh7IhfoqUfKVmrJJHZHw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["269", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/object.values\": {\n      \"version\": \"1.1.6\",\n      \"resolved\": \"https://registry.npmjs.org/object.values/-/object.values-1.1.6.tgz\",\n      \"integrity\": \"sha512-FVVTkD1vENCsAcwNs9k6jea2uHC/X0+JcjG8YA60FN5CMaJmG95wT9jek/xX9nornqGRrBkKtzuAu2wuHpKqvw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/once\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["270", {"page_content": "\"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n      \"integrity\": \"sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"wrappy\": \"1\"\n      }\n    },\n    \"node_modules/onetime\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz\",\n      \"integrity\": \"sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==\",\n      \"dependencies\": {\n        \"mimic-fn\": \"^2.1.0\"\n      },\n      \"engines\": {\n        \"node\": \">=6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/open\": {\n      \"version\": \"8.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/open/-/open-8.4.2.tgz\",\n      \"integrity\": \"sha512-7x81NCL719oNbsq/3mh+hVrAWmFuEYUqrq/Iw3kUzH8ReypT9QQ0BLoJS7/G9k6N81XjW4qHWtjWwe/9eLy1EQ==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["271", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"define-lazy-prop\": \"^2.0.0\",\n        \"is-docker\": \"^2.1.1\",\n        \"is-wsl\": \"^2.2.0\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/openai\": {\n      \"version\": \"3.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/openai/-/openai-3.2.1.tgz\",\n      \"integrity\": \"sha512-762C9BNlJPbjjlWZi4WYK9iM2tAVAv0uUp1UmI34vb0CN5T2mjB/qM6RYBmNKMh/dN9fC+bxqPwWJZUTWW052A==\",\n      \"dependencies\": {\n        \"axios\": \"^0.26.0\",\n        \"form-data\": \"^4.0.0\"\n      }\n    },\n    \"node_modules/optionator\": {\n      \"version\": \"0.9.1\",\n      \"resolved\": \"https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz\",\n      \"integrity\": \"sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"deep-is\": \"^0.1.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["272", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"deep-is\": \"^0.1.3\",\n        \"fast-levenshtein\": \"^2.0.6\",\n        \"levn\": \"^0.4.1\",\n        \"prelude-ls\": \"^1.2.1\",\n        \"type-check\": \"^0.4.0\",\n        \"word-wrap\": \"^1.2.3\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8.0\"\n      }\n    },\n    \"node_modules/ora\": {\n      \"version\": \"6.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/ora/-/ora-6.2.0.tgz\",\n      \"integrity\": \"sha512-c1qb/1rdE+EFDYiLXh10VY459uMh7DN9zlgd8mZJLoeiPpYllN8eAOiih2Rkah5ywxRm5tHN5C9zPheDq8d1MA==\",\n      \"dependencies\": {\n        \"chalk\": \"^5.0.0\",\n        \"cli-cursor\": \"^4.0.0\",\n        \"cli-spinners\": \"^2.6.1\",\n        \"is-interactive\": \"^2.0.0\",\n        \"is-unicode-supported\": \"^1.1.0\",\n        \"log-symbols\": \"^5.1.0\",\n        \"stdin-discarder\": \"^0.1.0\",\n        \"strip-ansi\": \"^7.0.1\",\n        \"wcwidth\": \"^1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["273", {"page_content": "\"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/ora/node_modules/ansi-regex\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz\",\n      \"integrity\": \"sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-regex?sponsor=1\"\n      }\n    },\n    \"node_modules/ora/node_modules/strip-ansi\": {\n      \"version\": \"7.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz\",\n      \"integrity\": \"sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["274", {"page_content": "\"ansi-regex\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/strip-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/os-tmpdir\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz\",\n      \"integrity\": \"sha512-D2FR03Vir7FIu45XBY20mTb+/ZSWB00sjU9jdQXt83gDrI4Ztz5Fs7/yy74g2N5SVQY4xY1qDr4rNddwYRVX0g==\",\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/p-queue\": {\n      \"version\": \"7.3.4\",\n      \"resolved\": \"https://registry.npmjs.org/p-queue/-/p-queue-7.3.4.tgz\",\n      \"integrity\": \"sha512-esox8CWt0j9EZECFvkFl2WNPat8LN4t7WWeXq73D9ha0V96qPRufApZi4ZhPwXAln1uVVal429HVVKPa2X0yQg==\",\n      \"dependencies\": {\n        \"eventemitter3\": \"^4.0.7\",\n        \"p-timeout\": \"^5.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["275", {"page_content": "\"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/p-timeout\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-timeout/-/p-timeout-5.1.0.tgz\",\n      \"integrity\": \"sha512-auFDyzzzGZZZdHz3BtET9VEz0SE/uMEAx7uWfGPucfzEwwe/xH0iVeZibQmANYE/hp9T2+UUZT5m+BKyrDp3Ew==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/parent-module\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz\",\n      \"integrity\": \"sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"callsites\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/path-is-absolute\": {\n      \"version\": \"1.0.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["276", {"page_content": "}\n    },\n    \"node_modules/path-is-absolute\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n      \"integrity\": \"sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/path-key\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n      \"integrity\": \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/path-parse\": {\n      \"version\": \"1.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz\",\n      \"integrity\": \"sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["277", {"page_content": "\"dev\": true\n    },\n    \"node_modules/path-type\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz\",\n      \"integrity\": \"sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/picocolors\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/picocolors/-/picocolors-1.0.0.tgz\",\n      \"integrity\": \"sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==\",\n      \"dev\": true\n    },\n    \"node_modules/picomatch\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz\",\n      \"integrity\": \"sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8.6\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["278", {"page_content": "\"dev\": true,\n      \"engines\": {\n        \"node\": \">=8.6\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/jonschlinkert\"\n      }\n    },\n    \"node_modules/prelude-ls\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz\",\n      \"integrity\": \"sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.8.0\"\n      }\n    },\n    \"node_modules/prettier\": {\n      \"version\": \"2.8.6\",\n      \"resolved\": \"https://registry.npmjs.org/prettier/-/prettier-2.8.6.tgz\",\n      \"integrity\": \"sha512-mtuzdiBbHwPEgl7NxWlqOkithPyp4VN93V7VeHVWBF+ad3I5avc0RVDT4oImXQy9H/AqxA2NSQH8pSxHW6FYbQ==\",\n      \"dev\": true,\n      \"bin\": {\n        \"prettier\": \"bin-prettier.js\"\n      },\n      \"engines\": {\n        \"node\": \">=10.13.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/prettier/prettier?sponsor=1\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["279", {"page_content": "\"funding\": {\n        \"url\": \"https://github.com/prettier/prettier?sponsor=1\"\n      }\n    },\n    \"node_modules/prettier-linter-helpers\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/prettier-linter-helpers/-/prettier-linter-helpers-1.0.0.tgz\",\n      \"integrity\": \"sha512-GbK2cP9nraSSUF9N2XwUwqfzlAFlMNYYl+ShE/V+H8a9uNl/oUqB1w2EL54Jh0OlyRSd8RfWYJ3coVS4TROP2w==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"fast-diff\": \"^1.1.2\"\n      },\n      \"engines\": {\n        \"node\": \">=6.0.0\"\n      }\n    },\n    \"node_modules/progress\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/progress/-/progress-2.0.3.tgz\",\n      \"integrity\": \"sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.4.0\"\n      }\n    },\n    \"node_modules/prop-types\": {\n      \"version\": \"15.8.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["280", {"page_content": "}\n    },\n    \"node_modules/prop-types\": {\n      \"version\": \"15.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz\",\n      \"integrity\": \"sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"loose-envify\": \"^1.4.0\",\n        \"object-assign\": \"^4.1.1\",\n        \"react-is\": \"^16.13.1\"\n      }\n    },\n    \"node_modules/punycode\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/punycode/-/punycode-2.3.0.tgz\",\n      \"integrity\": \"sha512-rRV+zQD8tVFys26lAGR9WUuS4iUAngJScM+ZRSKtvl5tKeZ2t5bvdNFdNHBW9FWR4guGHlgmsZ1G7BSm2wTbuA==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/queue-microtask\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["281", {"page_content": "\"resolved\": \"https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz\",\n      \"integrity\": \"sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ]\n    },\n    \"node_modules/react-is\": {\n      \"version\": \"16.13.1\",\n      \"resolved\": \"https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz\",\n      \"integrity\": \"sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==\",\n      \"dev\": true\n    },\n    \"node_modules/readable-stream\": {\n      \"version\": \"3.6.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["282", {"page_content": "\"dev\": true\n    },\n    \"node_modules/readable-stream\": {\n      \"version\": \"3.6.2\",\n      \"resolved\": \"https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz\",\n      \"integrity\": \"sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==\",\n      \"dependencies\": {\n        \"inherits\": \"^2.0.3\",\n        \"string_decoder\": \"^1.1.1\",\n        \"util-deprecate\": \"^1.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 6\"\n      }\n    },\n    \"node_modules/redeyed\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/redeyed/-/redeyed-2.1.1.tgz\",\n      \"integrity\": \"sha512-FNpGGo1DycYAdnrKFxCMmKYgo/mILAqtRYbkdQD8Ep/Hk2PQ5+aEAEx+IU713RTDmuBaH0c8P5ZozurNu5ObRQ==\",\n      \"dependencies\": {\n        \"esprima\": \"~4.0.0\"\n      }\n    },\n    \"node_modules/regenerator-runtime\": {\n      \"version\": \"0.13.11\",\n      \"resolved\": \"https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.11.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["283", {"page_content": "\"integrity\": \"sha512-kY1AZVr2Ra+t+piVaJ4gxaFaReZVH40AKNo7UCX6W+dEwBo/2oZJzqfuN1qLq1oL45o56cPaTXELwrTh8Fpggg==\",\n      \"dev\": true\n    },\n    \"node_modules/regexp.prototype.flags\": {\n      \"version\": \"1.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.4.3.tgz\",\n      \"integrity\": \"sha512-fjggEOO3slI6Wvgjwflkc4NFRCTZAu5CnNfBd5qOMYhWdn67nJBBu34/TkD++eeFmd8C9r9jfXJ27+nSiRkSUA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.3\",\n        \"functions-have-names\": \"^1.2.2\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/regexpp\": {\n      \"version\": \"3.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz\",\n      \"integrity\": \"sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["284", {"page_content": "\"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/mysticatea\"\n      }\n    },\n    \"node_modules/require-from-string\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz\",\n      \"integrity\": \"sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/resolve\": {\n      \"version\": \"1.22.1\",\n      \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-1.22.1.tgz\",\n      \"integrity\": \"sha512-nBpuuYuY5jFsli/JIs1oldw6fOQCBioohqWZg/2hiaOybXOft4lonv85uDOKXdf8rhyK159cxU5cDcK/NKk8zw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-core-module\": \"^2.9.0\",\n        \"path-parse\": \"^1.0.7\",\n        \"supports-preserve-symlinks-flag\": \"^1.0.0\"\n      },\n      \"bin\": {\n        \"resolve\": \"bin/resolve\"", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["285", {"page_content": "},\n      \"bin\": {\n        \"resolve\": \"bin/resolve\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/resolve-from\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz\",\n      \"integrity\": \"sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/restore-cursor\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/restore-cursor/-/restore-cursor-4.0.0.tgz\",\n      \"integrity\": \"sha512-I9fPXU9geO9bHOt9pHHOhOkYerIMsmVaWB0rA2AI9ERh/+x/i7MV5HKBNrg+ljO5eoPVgCcnFuRjJ9uH6I/3eg==\",\n      \"dependencies\": {\n        \"onetime\": \"^5.1.0\",\n        \"signal-exit\": \"^3.0.2\"\n      },\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["286", {"page_content": "\"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/reusify\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz\",\n      \"integrity\": \"sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==\",\n      \"dev\": true,\n      \"engines\": {\n        \"iojs\": \">=1.0.0\",\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/rimraf\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz\",\n      \"integrity\": \"sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"glob\": \"^7.1.3\"\n      },\n      \"bin\": {\n        \"rimraf\": \"bin.js\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["287", {"page_content": "},\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/isaacs\"\n      }\n    },\n    \"node_modules/run-async\": {\n      \"version\": \"2.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/run-async/-/run-async-2.4.1.tgz\",\n      \"integrity\": \"sha512-tvVnVv01b8c1RrA6Ep7JkStj85Guv/YrMcwqYQnwjsAS2cTmmPGBBjAjpCW7RrSodNSoE2/qg9O4bceNvUuDgQ==\",\n      \"engines\": {\n        \"node\": \">=0.12.0\"\n      }\n    },\n    \"node_modules/run-parallel\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz\",\n      \"integrity\": \"sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==\",\n      \"dev\": true,\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["288", {"page_content": "},\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ],\n      \"dependencies\": {\n        \"queue-microtask\": \"^1.2.2\"\n      }\n    },\n    \"node_modules/rxjs\": {\n      \"version\": \"7.8.0\",\n      \"resolved\": \"https://registry.npmjs.org/rxjs/-/rxjs-7.8.0.tgz\",\n      \"integrity\": \"sha512-F2+gxDshqmIub1KdvZkaEfGDwLNpPvk9Fs6LD/MyQxNgMds/WH9OdDDXOmxUZpME+iSK3rQCctkL0DYyytUqMg==\",\n      \"dependencies\": {\n        \"tslib\": \"^2.1.0\"\n      }\n    },\n    \"node_modules/safe-buffer\": {\n      \"version\": \"5.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz\",\n      \"integrity\": \"sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==\",\n      \"funding\": [\n        {\n          \"type\": \"github\",\n          \"url\": \"https://github.com/sponsors/feross\"\n        },\n        {\n          \"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["289", {"page_content": "\"type\": \"patreon\",\n          \"url\": \"https://www.patreon.com/feross\"\n        },\n        {\n          \"type\": \"consulting\",\n          \"url\": \"https://feross.org/support\"\n        }\n      ]\n    },\n    \"node_modules/safe-regex-test\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/safe-regex-test/-/safe-regex-test-1.0.0.tgz\",\n      \"integrity\": \"sha512-JBUUzyOgEwXQY1NuPtvcj/qcBDbDmEvWufhlnXZIm75DEHp+afM1r1ujJpJsV/gSM4t59tpDyPi1sd6ZaPFfsA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"is-regex\": \"^1.1.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/safer-buffer\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz\",\n      \"integrity\": \"sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\"\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["290", {"page_content": "},\n    \"node_modules/semver\": {\n      \"version\": \"7.3.8\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.3.8.tgz\",\n      \"integrity\": \"sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"lru-cache\": \"^6.0.0\"\n      },\n      \"bin\": {\n        \"semver\": \"bin/semver.js\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      }\n    },\n    \"node_modules/shebang-command\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n      \"integrity\": \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"shebang-regex\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/shebang-regex\": {\n      \"version\": \"3.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["291", {"page_content": "\"node\": \">=8\"\n      }\n    },\n    \"node_modules/shebang-regex\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n      \"integrity\": \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/side-channel\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel/-/side-channel-1.0.4.tgz\",\n      \"integrity\": \"sha512-q5XPytqFEIKHkGdiMIrY10mvLRvnQh42/+GoBlFW3b2LXLE2xxJpZFdm94we0BaoV3RwJyGqg5wS7epxTv0Zvw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.0\",\n        \"get-intrinsic\": \"^1.0.2\",\n        \"object-inspect\": \"^1.9.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/signal-exit\": {\n      \"version\": \"3.0.7\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["292", {"page_content": "}\n    },\n    \"node_modules/signal-exit\": {\n      \"version\": \"3.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz\",\n      \"integrity\": \"sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==\"\n    },\n    \"node_modules/slash\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/slash/-/slash-3.0.0.tgz\",\n      \"integrity\": \"sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/slice-ansi\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz\",\n      \"integrity\": \"sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ansi-styles\": \"^4.0.0\",\n        \"astral-regex\": \"^2.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["293", {"page_content": "\"dependencies\": {\n        \"ansi-styles\": \"^4.0.0\",\n        \"astral-regex\": \"^2.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/slice-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/sprintf-js\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz\",\n      \"integrity\": \"sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==\",\n      \"dev\": true\n    },\n    \"node_modules/stdin-discarder\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/stdin-discarder/-/stdin-discarder-0.1.0.tgz\",\n      \"integrity\": \"sha512-xhV7w8S+bUwlPTb4bAOUQhv8/cSS5offJuX8GQGq32ONF0ZtDWKfkdomM3HMRA+LhX6um/FZ0COqlwsjD53LeQ==\",\n      \"dependencies\": {\n        \"bl\": \"^5.0.0\"\n      },\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["294", {"page_content": "},\n      \"engines\": {\n        \"node\": \"^12.20.0 || ^14.13.1 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/stop-iteration-iterator\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/stop-iteration-iterator/-/stop-iteration-iterator-1.0.0.tgz\",\n      \"integrity\": \"sha512-iCGQj+0l0HOdZ2AEeBADlsRC+vsnDsZsbdSiH1yNSjcfKM7fdpCMfqAL/dwF5BLiw/XhRft/Wax6zQbhq2BcjQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"internal-slot\": \"^1.0.4\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      }\n    },\n    \"node_modules/string_decoder\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz\",\n      \"integrity\": \"sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==\",\n      \"dependencies\": {\n        \"safe-buffer\": \"~5.2.0\"\n      }\n    },\n    \"node_modules/string-width\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["295", {"page_content": "\"safe-buffer\": \"~5.2.0\"\n      }\n    },\n    \"node_modules/string-width\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz\",\n      \"integrity\": \"sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==\",\n      \"dependencies\": {\n        \"emoji-regex\": \"^8.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/string-width/node_modules/emoji-regex\": {\n      \"version\": \"8.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz\",\n      \"integrity\": \"sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==\"\n    },\n    \"node_modules/string.prototype.matchall\": {\n      \"version\": \"4.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.matchall/-/string.prototype.matchall-4.0.8.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["296", {"page_content": "\"integrity\": \"sha512-6zOCOcJ+RJAQshcTvXPHoxoQGONa3e/Lqx90wUA+wEzX78sg5Bo+1tQo4N0pohS0erG9qtCqJDjNCQBjeWVxyg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"has-symbols\": \"^1.0.3\",\n        \"internal-slot\": \"^1.0.3\",\n        \"regexp.prototype.flags\": \"^1.4.3\",\n        \"side-channel\": \"^1.0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/string.prototype.trim\": {\n      \"version\": \"1.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.trim/-/string.prototype.trim-1.2.7.tgz\",\n      \"integrity\": \"sha512-p6TmeT1T3411M8Cgg9wBTMRtY2q9+PNy9EV1i2lIXUN/btt763oIfxwN3RR8VU6wHX8j/1CFy0L+YuThm6bgOg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["297", {"page_content": "\"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/string.prototype.trimend\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.6.tgz\",\n      \"integrity\": \"sha512-JySq+4mrPf9EsDBEDYMOb/lM7XQLulwg5R/m1r0PXEFqrV0qHvl58sdTilSXtKOflCsK2E8jxf+GKC0T07RWwQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/string.prototype.trimstart\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["298", {"page_content": "\"integrity\": \"sha512-omqjMDaY92pbn5HOX7f9IccLA+U1tA9GvtU4JrodiXFfYB7jPzzHpRzpglLAjtUV6bB557zwClJezTqnAiYnQA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/strip-ansi\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n      \"integrity\": \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n      \"dependencies\": {\n        \"ansi-regex\": \"^5.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/strip-bom\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz\",\n      \"integrity\": \"sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["299", {"page_content": "\"dev\": true,\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/strip-json-comments\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz\",\n      \"integrity\": \"sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=8\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/supports-color\": {\n      \"version\": \"5.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz\",\n      \"integrity\": \"sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"has-flag\": \"^3.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=4\"\n      }\n    },\n    \"node_modules/supports-hyperlinks\": {\n      \"version\": \"2.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["300", {"page_content": "}\n    },\n    \"node_modules/supports-hyperlinks\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-hyperlinks/-/supports-hyperlinks-2.3.0.tgz\",\n      \"integrity\": \"sha512-RpsAZlpWcDwOPQA22aCH4J0t7L8JmAvsCxfOSEwm7cQs3LshN36QaTkwd70DnBOXDWGssw2eUoc8CaRWT0XunA==\",\n      \"dependencies\": {\n        \"has-flag\": \"^4.0.0\",\n        \"supports-color\": \"^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/supports-hyperlinks/node_modules/has-flag\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n      \"integrity\": \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/supports-hyperlinks/node_modules/supports-color\": {\n      \"version\": \"7.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["301", {"page_content": "\"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",\n      \"integrity\": \"sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\",\n      \"dependencies\": {\n        \"has-flag\": \"^4.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8\"\n      }\n    },\n    \"node_modules/supports-preserve-symlinks-flag\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz\",\n      \"integrity\": \"sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/synckit\": {\n      \"version\": \"0.8.5\",\n      \"resolved\": \"https://registry.npmjs.org/synckit/-/synckit-0.8.5.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["302", {"page_content": "\"resolved\": \"https://registry.npmjs.org/synckit/-/synckit-0.8.5.tgz\",\n      \"integrity\": \"sha512-L1dapNV6vu2s/4Sputv8xGsCdAVlb5nRDMFU/E27D44l5U6cw1g0dGd45uLc+OXjNMmF4ntiMdCimzcjFKQI8Q==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@pkgr/utils\": \"^2.3.1\",\n        \"tslib\": \"^2.5.0\"\n      },\n      \"engines\": {\n        \"node\": \"^14.18.0 || >=16.0.0\"\n      },\n      \"funding\": {\n        \"url\": \"https://opencollective.com/unts\"\n      }\n    },\n    \"node_modules/table\": {\n      \"version\": \"6.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/table/-/table-6.8.1.tgz\",\n      \"integrity\": \"sha512-Y4X9zqrCftUhMeH2EptSSERdVKt/nEdijTOacGD/97EKjhQ/Qs8RTlEGABSJNNN8lac9kheH+af7yAkEWlgneA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"ajv\": \"^8.0.1\",\n        \"lodash.truncate\": \"^4.4.2\",\n        \"slice-ansi\": \"^4.0.0\",\n        \"string-width\": \"^4.2.3\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=10.0.0\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["303", {"page_content": "},\n      \"engines\": {\n        \"node\": \">=10.0.0\"\n      }\n    },\n    \"node_modules/table/node_modules/ajv\": {\n      \"version\": \"8.12.0\",\n      \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-8.12.0.tgz\",\n      \"integrity\": \"sha512-sRu1kpcO9yLtYxBKvqfTeh9KzZEwO3STyX1HT+4CaDzC6HpTGYhIhPIzj9XuKU7KYDwnaeh5hcOwjy1QuJzBPA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"fast-deep-equal\": \"^3.1.1\",\n        \"json-schema-traverse\": \"^1.0.0\",\n        \"require-from-string\": \"^2.0.2\",\n        \"uri-js\": \"^4.2.2\"\n      },\n      \"funding\": {\n        \"type\": \"github\",\n        \"url\": \"https://github.com/sponsors/epoberezkin\"\n      }\n    },\n    \"node_modules/table/node_modules/json-schema-traverse\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz\",\n      \"integrity\": \"sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["304", {"page_content": "\"dev\": true\n    },\n    \"node_modules/tapable\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/tapable/-/tapable-2.2.1.tgz\",\n      \"integrity\": \"sha512-GNzQvQTOIP6RyTfE2Qxb8ZVlNmw0n88vp1szwWRimP02mnTsx3Wtn5qRdqY9w2XduFNUgvOwhNnQsjwCp+kqaQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=6\"\n      }\n    },\n    \"node_modules/text-table\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz\",\n      \"integrity\": \"sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==\",\n      \"dev\": true\n    },\n    \"node_modules/textextensions\": {\n      \"version\": \"5.15.0\",\n      \"resolved\": \"https://registry.npmjs.org/textextensions/-/textextensions-5.15.0.tgz\",\n      \"integrity\": \"sha512-MeqZRHLuaGamUXGuVn2ivtU3LA3mLCCIO5kUGoohTCoGmCBg/+8yPhWVX9WSl9telvVd8erftjFk9Fwb2dD6rw==\",\n      \"engines\": {\n        \"node\": \">=0.8\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["305", {"page_content": "\"engines\": {\n        \"node\": \">=0.8\"\n      },\n      \"funding\": {\n        \"url\": \"https://bevry.me/fund\"\n      }\n    },\n    \"node_modules/through\": {\n      \"version\": \"2.3.8\",\n      \"resolved\": \"https://registry.npmjs.org/through/-/through-2.3.8.tgz\",\n      \"integrity\": \"sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg==\"\n    },\n    \"node_modules/tiny-glob\": {\n      \"version\": \"0.2.9\",\n      \"resolved\": \"https://registry.npmjs.org/tiny-glob/-/tiny-glob-0.2.9.tgz\",\n      \"integrity\": \"sha512-g/55ssRPUjShh+xkfx9UPDXqhckHEsHr4Vd9zX55oSdGZc/MD0m3sferOkwWtp98bv+kcVfEHtRJgBVJzelrzg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"globalyzer\": \"0.1.0\",\n        \"globrex\": \"^0.1.2\"\n      }\n    },\n    \"node_modules/tmp\": {\n      \"version\": \"0.0.33\",\n      \"resolved\": \"https://registry.npmjs.org/tmp/-/tmp-0.0.33.tgz\",\n      \"integrity\": \"sha512-jRCJlojKnZ3addtTOjdIqoRuPEKBvNXcGYqzO6zWZX8KfKEpnGY5jfggJQ3EjKuu8D4bJRr0y+cYJFmYbImXGw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["306", {"page_content": "\"dependencies\": {\n        \"os-tmpdir\": \"~1.0.2\"\n      },\n      \"engines\": {\n        \"node\": \">=0.6.0\"\n      }\n    },\n    \"node_modules/to-regex-range\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz\",\n      \"integrity\": \"sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-number\": \"^7.0.0\"\n      },\n      \"engines\": {\n        \"node\": \">=8.0\"\n      }\n    },\n    \"node_modules/ts-md5\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/ts-md5/-/ts-md5-1.3.1.tgz\",\n      \"integrity\": \"sha512-DiwiXfwvcTeZ5wCE0z+2A9EseZsztaiZtGrtSaY5JOD7ekPnR/GoIVD5gXZAlK9Na9Kvpo9Waz5rW64WKAWApg==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      }\n    },\n    \"node_modules/tsconfig-paths\": {\n      \"version\": \"3.14.2\",\n      \"resolved\": \"https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.14.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["307", {"page_content": "\"resolved\": \"https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.14.2.tgz\",\n      \"integrity\": \"sha512-o/9iXgCYc5L/JxCHPe3Hvh8Q/2xm5Z+p18PESBU6Ff33695QnCHBEjcytY2q19ua7Mbl/DavtBOLq+oG0RCL+g==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"@types/json5\": \"^0.0.29\",\n        \"json5\": \"^1.0.2\",\n        \"minimist\": \"^1.2.6\",\n        \"strip-bom\": \"^3.0.0\"\n      }\n    },\n    \"node_modules/tslib\": {\n      \"version\": \"2.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-2.5.0.tgz\",\n      \"integrity\": \"sha512-336iVw3rtn2BUK7ORdIAHTyxHGRIHVReokCR3XjbckJMK7ms8FysBfhLR8IXnAgy7T0PTPNBWKiH514FOW/WSg==\"\n    },\n    \"node_modules/tsutils\": {\n      \"version\": \"3.21.0\",\n      \"resolved\": \"https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz\",\n      \"integrity\": \"sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"tslib\": \"^1.8.1\"\n      },\n      \"engines\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["308", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"tslib\": \"^1.8.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 6\"\n      },\n      \"peerDependencies\": {\n        \"typescript\": \">=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta\"\n      }\n    },\n    \"node_modules/tsutils/node_modules/tslib\": {\n      \"version\": \"1.14.1\",\n      \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz\",\n      \"integrity\": \"sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==\",\n      \"dev\": true\n    },\n    \"node_modules/type-check\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz\",\n      \"integrity\": \"sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"prelude-ls\": \"^1.2.1\"\n      },\n      \"engines\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["309", {"page_content": "\"dependencies\": {\n        \"prelude-ls\": \"^1.2.1\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.8.0\"\n      }\n    },\n    \"node_modules/type-fest\": {\n      \"version\": \"0.20.2\",\n      \"resolved\": \"https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz\",\n      \"integrity\": \"sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=10\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/typed-array-length\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/typed-array-length/-/typed-array-length-1.0.4.tgz\",\n      \"integrity\": \"sha512-KjZypGq+I/H7HI5HlOoGHkWUUGq+Q0TPhQurLbyrVrvnKTBgzLhIJ7j6J/XTQOi0d1RjyZ0wdas8bKs2p0x3Ng==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"for-each\": \"^0.3.3\",\n        \"is-typed-array\": \"^1.1.9\"\n      },\n      \"funding\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["310", {"page_content": "\"for-each\": \"^0.3.3\",\n        \"is-typed-array\": \"^1.1.9\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/typescript\": {\n      \"version\": \"4.9.5\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-4.9.5.tgz\",\n      \"integrity\": \"sha512-1FXk9E2Hm+QzZQ7z+McJiHL4NW1F2EzMu9Nq9i3zAaGqibafqYwCVU6WyWAuyQRRzOlxou8xZSyXLEN8oKj24g==\",\n      \"dev\": true,\n      \"bin\": {\n        \"tsc\": \"bin/tsc\",\n        \"tsserver\": \"bin/tsserver\"\n      },\n      \"engines\": {\n        \"node\": \">=4.2.0\"\n      }\n    },\n    \"node_modules/unbox-primitive\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/unbox-primitive/-/unbox-primitive-1.0.2.tgz\",\n      \"integrity\": \"sha512-61pPlCD9h51VoreyJ0BReideM3MDKMKnh6+V9L08331ipq6Q8OFXZYiqP6n/tbHx4s5I9uRhcye6BrbkizkBDw==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-bigints\": \"^1.0.2\",\n        \"has-symbols\": \"^1.0.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["311", {"page_content": "\"call-bind\": \"^1.0.2\",\n        \"has-bigints\": \"^1.0.2\",\n        \"has-symbols\": \"^1.0.3\",\n        \"which-boxed-primitive\": \"^1.0.2\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/uri-js\": {\n      \"version\": \"4.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz\",\n      \"integrity\": \"sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"punycode\": \"^2.1.0\"\n      }\n    },\n    \"node_modules/util-deprecate\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz\",\n      \"integrity\": \"sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==\"\n    },\n    \"node_modules/uuid\": {\n      \"version\": \"9.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-9.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["312", {"page_content": "\"version\": \"9.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-9.0.0.tgz\",\n      \"integrity\": \"sha512-MXcSTerfPa4uqyzStbRoTgt5XIe3x5+42+q1sDuy3R5MDk66URdLMOZe5aPX/SQd+kuYAh0FdP/pO28IkQyTeg==\",\n      \"bin\": {\n        \"uuid\": \"dist/bin/uuid\"\n      }\n    },\n    \"node_modules/v8-compile-cache\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz\",\n      \"integrity\": \"sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==\",\n      \"dev\": true\n    },\n    \"node_modules/wcwidth\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/wcwidth/-/wcwidth-1.0.1.tgz\",\n      \"integrity\": \"sha512-XHPEwS0q6TaxcvG85+8EYkbiCux2XtWG2mkc47Ng2A77BQu9+DqIOJldST4HgPkuea7dvKSj5VgX3P1d4rW8Tg==\",\n      \"dependencies\": {\n        \"defaults\": \"^1.0.3\"\n      }\n    },\n    \"node_modules/which\": {\n      \"version\": \"2.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["313", {"page_content": "\"defaults\": \"^1.0.3\"\n      }\n    },\n    \"node_modules/which\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n      \"integrity\": \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"isexe\": \"^2.0.0\"\n      },\n      \"bin\": {\n        \"node-which\": \"bin/node-which\"\n      },\n      \"engines\": {\n        \"node\": \">= 8\"\n      }\n    },\n    \"node_modules/which-boxed-primitive\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which-boxed-primitive/-/which-boxed-primitive-1.0.2.tgz\",\n      \"integrity\": \"sha512-bwZdv0AKLpplFY2KZRX6TvyuN7ojjr7lwkg6ml0roIy9YeuSr7JS372qlNW18UQYzgYK9ziGcerWqZOmEn9VNg==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-bigint\": \"^1.0.1\",\n        \"is-boolean-object\": \"^1.1.0\",\n        \"is-number-object\": \"^1.0.4\",\n        \"is-string\": \"^1.0.5\",\n        \"is-symbol\": \"^1.0.3\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["314", {"page_content": "\"is-string\": \"^1.0.5\",\n        \"is-symbol\": \"^1.0.3\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/which-collection\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/which-collection/-/which-collection-1.0.1.tgz\",\n      \"integrity\": \"sha512-W8xeTUwaln8i3K/cY1nGXzdnVZlidBcagyNFtBdD5kxnb4TvGKR7FfSIS3mYpwWS1QUCutfKz8IY8RjftB0+1A==\",\n      \"dev\": true,\n      \"dependencies\": {\n        \"is-map\": \"^2.0.1\",\n        \"is-set\": \"^2.0.1\",\n        \"is-weakmap\": \"^2.0.1\",\n        \"is-weakset\": \"^2.0.1\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/which-typed-array\": {\n      \"version\": \"1.1.9\",\n      \"resolved\": \"https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.9.tgz\",\n      \"integrity\": \"sha512-w9c4xkx6mPidwp7180ckYWfMmvxpjlZuIudNtDf4N/tTAUB8VJbX25qZoAsrtGuYNnGw3pa0AXgbGKRB8/EceA==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["315", {"page_content": "\"dev\": true,\n      \"dependencies\": {\n        \"available-typed-arrays\": \"^1.0.5\",\n        \"call-bind\": \"^1.0.2\",\n        \"for-each\": \"^0.3.3\",\n        \"gopd\": \"^1.0.1\",\n        \"has-tostringtag\": \"^1.0.0\",\n        \"is-typed-array\": \"^1.1.10\"\n      },\n      \"engines\": {\n        \"node\": \">= 0.4\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/ljharb\"\n      }\n    },\n    \"node_modules/word-wrap\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz\",\n      \"integrity\": \"sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==\",\n      \"dev\": true,\n      \"engines\": {\n        \"node\": \">=0.10.0\"\n      }\n    },\n    \"node_modules/wrap-ansi\": {\n      \"version\": \"8.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz\",\n      \"integrity\": \"sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["316", {"page_content": "\"dependencies\": {\n        \"ansi-styles\": \"^6.1.0\",\n        \"string-width\": \"^5.0.1\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/wrap-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi/node_modules/ansi-regex\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz\",\n      \"integrity\": \"sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==\",\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-regex?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi/node_modules/ansi-styles\": {\n      \"version\": \"6.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz\",\n      \"integrity\": \"sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["317", {"page_content": "\"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/ansi-styles?sponsor=1\"\n      }\n    },\n    \"node_modules/wrap-ansi/node_modules/string-width\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz\",\n      \"integrity\": \"sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==\",\n      \"dependencies\": {\n        \"eastasianwidth\": \"^0.2.0\",\n        \"emoji-regex\": \"^9.2.2\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/sindresorhus\"\n      }\n    },\n    \"node_modules/wrap-ansi/node_modules/strip-ansi\": {\n      \"version\": \"7.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz\",\n      \"integrity\": \"sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["318", {"page_content": "\"dependencies\": {\n        \"ansi-regex\": \"^6.0.1\"\n      },\n      \"engines\": {\n        \"node\": \">=12\"\n      },\n      \"funding\": {\n        \"url\": \"https://github.com/chalk/strip-ansi?sponsor=1\"\n      }\n    },\n    \"node_modules/wrappy\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n      \"integrity\": \"sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==\",\n      \"dev\": true\n    },\n    \"node_modules/yallist\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz\",\n      \"integrity\": \"sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==\",\n      \"dev\": true\n    },\n    \"node_modules/yaml\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/yaml/-/yaml-2.2.1.tgz\",\n      \"integrity\": \"sha512-e0WHiYql7+9wr4cWMx3TVQrNwejKaEe7/rHNmQmqRjazfOP5W8PB6Jpebb5o6fIapbz9o9+2ipcaTM2ZwDI6lw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["319", {"page_content": "\"engines\": {\n        \"node\": \">= 14\"\n      }\n    },\n    \"node_modules/zod\": {\n      \"version\": \"3.21.4\",\n      \"resolved\": \"https://registry.npmjs.org/zod/-/zod-3.21.4.tgz\",\n      \"integrity\": \"sha512-m46AKbrzKVzOzs/DZgVnG5H55N1sv1M8qZU3A8RIKbs3mrACDNeIOeilDymVb2HdmP8uwshOCF4uJ8uM9rCqJw==\",\n      \"funding\": {\n        \"url\": \"https://github.com/sponsors/colinhacks\"\n      }\n    }\n  },\n  \"dependencies\": {\n    \"@babel/code-frame\": {\n      \"version\": \"7.12.11\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.12.11.tgz\",\n      \"integrity\": \"sha512-Zt1yodBx1UcyiePMSkWnU4hPqhwq7hGi2nFL1LeA3EUl+q2LQx16MISgJ0+z7dnmgvP9QtIleuETGOiOH1RcIw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@babel/highlight\": \"^7.10.4\"\n      }\n    },\n    \"@babel/helper-validator-identifier\": {\n      \"version\": \"7.19.1\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.19.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["320", {"page_content": "\"integrity\": \"sha512-awrNfaMtnHUr653GgGEs++LlAvW6w+DcPrOliSMXWCKo597CwL5Acf/wWdNkf/tfEQE3mjkeD1YOVZOUV/od1w==\",\n      \"dev\": true\n    },\n    \"@babel/highlight\": {\n      \"version\": \"7.18.6\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/highlight/-/highlight-7.18.6.tgz\",\n      \"integrity\": \"sha512-u7stbOuYjaPezCuLj29hNW1v64M2Md2qupEKP1fHc7WdOA3DgLh37suiSrZYY7haUB7iBeQZ9P1uiRF359do3g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@babel/helper-validator-identifier\": \"^7.18.6\",\n        \"chalk\": \"^2.0.0\",\n        \"js-tokens\": \"^4.0.0\"\n      },\n      \"dependencies\": {\n        \"ansi-styles\": {\n          \"version\": \"3.2.1\",\n          \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz\",\n          \"integrity\": \"sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"color-convert\": \"^1.9.0\"\n          }\n        },\n        \"chalk\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["321", {"page_content": "\"color-convert\": \"^1.9.0\"\n          }\n        },\n        \"chalk\": {\n          \"version\": \"2.4.2\",\n          \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz\",\n          \"integrity\": \"sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==\",\n          \"dev\": true,\n          \"requires\": {\n            \"ansi-styles\": \"^3.2.1\",\n            \"escape-string-regexp\": \"^1.0.5\",\n            \"supports-color\": \"^5.3.0\"\n          }\n        },\n        \"color-convert\": {\n          \"version\": \"1.9.3\",\n          \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz\",\n          \"integrity\": \"sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==\",\n          \"dev\": true,\n          \"requires\": {\n            \"color-name\": \"1.1.3\"\n          }\n        },\n        \"color-name\": {\n          \"version\": \"1.1.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["322", {"page_content": "}\n        },\n        \"color-name\": {\n          \"version\": \"1.1.3\",\n          \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz\",\n          \"integrity\": \"sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==\",\n          \"dev\": true\n        },\n        \"escape-string-regexp\": {\n          \"version\": \"1.0.5\",\n          \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz\",\n          \"integrity\": \"sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"@babel/runtime\": {\n      \"version\": \"7.21.0\",\n      \"resolved\": \"https://registry.npmjs.org/@babel/runtime/-/runtime-7.21.0.tgz\",\n      \"integrity\": \"sha512-xwII0//EObnq89Ji5AKYQaRYiW/nZ3llSv29d49IuxPhKbtJoLP+9QUUZ4nVragQVtaVGeZrpB+ZtG/Pdy/POw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"regenerator-runtime\": \"^0.13.11\"\n      }", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["323", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"regenerator-runtime\": \"^0.13.11\"\n      }\n    },\n    \"@colors/colors\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/@colors/colors/-/colors-1.5.0.tgz\",\n      \"integrity\": \"sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==\",\n      \"optional\": true\n    },\n    \"@dqbd/tiktoken\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/@dqbd/tiktoken/-/tiktoken-1.0.2.tgz\",\n      \"integrity\": \"sha512-AjGTBRWsMoVmVeN55NLyupyM8TNamOUBl6tj5t/leLDVup3CFGO9tVagNL1jf3GyZLkWZSTmYVbPQ/M2LEcNzw==\"\n    },\n    \"@esbuild/android-arm\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.17.12.tgz\",\n      \"integrity\": \"sha512-E/sgkvwoIfj4aMAPL2e35VnUJspzVYl7+M1B2cqeubdBhADV4uPon0KCc8p2G+LqSJ6i8ocYPCqY3A4GGq0zkQ==\",\n      \"optional\": true\n    },\n    \"@esbuild/android-arm64\": {\n      \"version\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["324", {"page_content": "\"optional\": true\n    },\n    \"@esbuild/android-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-WQ9p5oiXXYJ33F2EkE3r0FRDFVpEdcDiwNX3u7Xaibxfx6vQE0Sb8ytrfQsA5WO6kDn6mDfKLh6KrPBjvkk7xA==\",\n      \"optional\": true\n    },\n    \"@esbuild/android-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-m4OsaCr5gT+se25rFPHKQXARMyAehHTQAz4XX1Vk3d27VtqiX0ALMBPoXZsGaB6JYryCLfgGwUslMqTfqeLU0w==\",\n      \"optional\": true\n    },\n    \"@esbuild/darwin-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-O3GCZghRIx+RAN0NDPhyyhRgwa19MoKlzGonIb5hgTj78krqp9XZbYCvFr9N1eUxg0ZQEpiiZ4QvsOQwBpP+lg==\",\n      \"optional\": true\n    },\n    \"@esbuild/darwin-x64\": {\n      \"version\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["325", {"page_content": "\"optional\": true\n    },\n    \"@esbuild/darwin-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-5D48jM3tW27h1qjaD9UNRuN+4v0zvksqZSPZqeSWggfMlsVdAhH3pwSfQIFJwcs9QJ9BRibPS4ViZgs3d2wsCA==\",\n      \"optional\": true\n    },\n    \"@esbuild/freebsd-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-OWvHzmLNTdF1erSvrfoEBGlN94IE6vCEaGEkEH29uo/VoONqPnoDFfShi41Ew+yKimx4vrmmAJEGNoyyP+OgOQ==\",\n      \"optional\": true\n    },\n    \"@esbuild/freebsd-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-A0Xg5CZv8MU9xh4a+7NUpi5VHBKh1RaGJKqjxe4KG87X+mTjDE6ZvlJqpWoeJxgfXHT7IMP9tDFu7IZ03OtJAw==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-arm\": {\n      \"version\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["326", {"page_content": "\"optional\": true\n    },\n    \"@esbuild/linux-arm\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.17.12.tgz\",\n      \"integrity\": \"sha512-WsHyJ7b7vzHdJ1fv67Yf++2dz3D726oO3QCu8iNYik4fb5YuuReOI9OtA+n7Mk0xyQivNTPbl181s+5oZ38gyA==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-cK3AjkEc+8v8YG02hYLQIQlOznW+v9N+OI9BAFuyqkfQFR+DnDLhEM5N8QRxAUz99cJTo1rLNXqRrvY15gbQUg==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-ia32\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.17.12.tgz\",\n      \"integrity\": \"sha512-jdOBXJqcgHlah/nYHnj3Hrnl9l63RjtQ4vn9+bohjQPI2QafASB5MtHAoEv0JQHVb/xYQTFOeuHnNYE1zF7tYw==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-loong64\": {\n      \"version\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["327", {"page_content": "\"optional\": true\n    },\n    \"@esbuild/linux-loong64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.17.12.tgz\",\n      \"integrity\": \"sha512-GTOEtj8h9qPKXCyiBBnHconSCV9LwFyx/gv3Phw0pa25qPYjVuuGZ4Dk14bGCfGX3qKF0+ceeQvwmtI+aYBbVA==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-mips64el\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.17.12.tgz\",\n      \"integrity\": \"sha512-o8CIhfBwKcxmEENOH9RwmUejs5jFiNoDw7YgS0EJTF6kgPgcqLFjgoc5kDey5cMHRVCIWc6kK2ShUePOcc7RbA==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-ppc64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.17.12.tgz\",\n      \"integrity\": \"sha512-biMLH6NR/GR4z+ap0oJYb877LdBpGac8KfZoEnDiBKd7MD/xt8eaw1SFfYRUeMVx519kVkAOL2GExdFmYnZx3A==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-riscv64\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["328", {"page_content": "\"optional\": true\n    },\n    \"@esbuild/linux-riscv64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.17.12.tgz\",\n      \"integrity\": \"sha512-jkphYUiO38wZGeWlfIBMB72auOllNA2sLfiZPGDtOBb1ELN8lmqBrlMiucgL8awBw1zBXN69PmZM6g4yTX84TA==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-s390x\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.17.12.tgz\",\n      \"integrity\": \"sha512-j3ucLdeY9HBcvODhCY4b+Ds3hWGO8t+SAidtmWu/ukfLLG/oYDMaA+dnugTVAg5fnUOGNbIYL9TOjhWgQB8W5g==\",\n      \"optional\": true\n    },\n    \"@esbuild/linux-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-uo5JL3cgaEGotaqSaJdRfFNSCUJOIliKLnDGWaVCgIKkHxwhYMm95pfMbWZ9l7GeW9kDg0tSxcy9NYdEtjwwmA==\",\n      \"optional\": true\n    },\n    \"@esbuild/netbsd-x64\": {\n      \"version\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["329", {"page_content": "\"optional\": true\n    },\n    \"@esbuild/netbsd-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-DNdoRg8JX+gGsbqt2gPgkgb00mqOgOO27KnrWZtdABl6yWTST30aibGJ6geBq3WM2TIeW6COs5AScnC7GwtGPg==\",\n      \"optional\": true\n    },\n    \"@esbuild/openbsd-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-aVsENlr7B64w8I1lhHShND5o8cW6sB9n9MUtLumFlPhG3elhNWtE7M1TFpj3m7lT3sKQUMkGFjTQBrvDDO1YWA==\",\n      \"optional\": true\n    },\n    \"@esbuild/sunos-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-qbHGVQdKSwi0JQJuZznS4SyY27tYXYF0mrgthbxXrZI3AHKuRvU+Eqbg/F0rmLDpW/jkIZBlCO1XfHUBMNJ1pg==\",\n      \"optional\": true\n    },\n    \"@esbuild/win32-arm64\": {\n      \"version\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["330", {"page_content": "\"optional\": true\n    },\n    \"@esbuild/win32-arm64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.17.12.tgz\",\n      \"integrity\": \"sha512-zsCp8Ql+96xXTVTmm6ffvoTSZSV2B/LzzkUXAY33F/76EajNw1m+jZ9zPfNJlJ3Rh4EzOszNDHsmG/fZOhtqDg==\",\n      \"optional\": true\n    },\n    \"@esbuild/win32-ia32\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.17.12.tgz\",\n      \"integrity\": \"sha512-FfrFjR4id7wcFYOdqbDfDET3tjxCozUgbqdkOABsSFzoZGFC92UK7mg4JKRc/B3NNEf1s2WHxJ7VfTdVDPN3ng==\",\n      \"optional\": true\n    },\n    \"@esbuild/win32-x64\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.17.12.tgz\",\n      \"integrity\": \"sha512-JOOxw49BVZx2/5tW3FqkdjSD/5gXYeVGPDcB0lvap0gLQshkh1Nyel1QazC+wNxus3xPlsYAgqU1BUmrmCvWtw==\",\n      \"optional\": true\n    },\n    \"@eslint-community/eslint-utils\": {\n      \"version\": \"4.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["331", {"page_content": "\"optional\": true\n    },\n    \"@eslint-community/eslint-utils\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.3.0.tgz\",\n      \"integrity\": \"sha512-v3oplH6FYCULtFuCeqyuTd9D2WKO937Dxdq+GmHOLL72TTRriLxz2VLlNfkZRsvj6PKnOPAtuT6dwrs/pA5DvA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"eslint-visitor-keys\": \"^3.3.0\"\n      }\n    },\n    \"@eslint-community/regexpp\": {\n      \"version\": \"4.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.4.1.tgz\",\n      \"integrity\": \"sha512-BISJ6ZE4xQsuL/FmsyRaiffpq977bMlsKfGHTQrOGFErfByxIe6iZTxPf/00Zon9b9a7iUykfQwejN3s2ZW/Bw==\",\n      \"dev\": true\n    },\n    \"@eslint/eslintrc\": {\n      \"version\": \"0.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.4.3.tgz\",\n      \"integrity\": \"sha512-J6KFFz5QCYUJq3pf0mjEcCJVERbzv71PUIDczuh9JkwGEzced6CO5ADLHB1rbf/+oPBtoPfMYNOpGDzCANlbXw==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["332", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"ajv\": \"^6.12.4\",\n        \"debug\": \"^4.1.1\",\n        \"espree\": \"^7.3.0\",\n        \"globals\": \"^13.9.0\",\n        \"ignore\": \"^4.0.6\",\n        \"import-fresh\": \"^3.2.1\",\n        \"js-yaml\": \"^3.13.1\",\n        \"minimatch\": \"^3.0.4\",\n        \"strip-json-comments\": \"^3.1.1\"\n      },\n      \"dependencies\": {\n        \"brace-expansion\": {\n          \"version\": \"1.1.11\",\n          \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n          \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",\n            \"concat-map\": \"0.0.1\"\n          }\n        },\n        \"ignore\": {\n          \"version\": \"4.0.6\",\n          \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["333", {"page_content": "\"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",\n          \"integrity\": \"sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==\",\n          \"dev\": true\n        },\n        \"minimatch\": {\n          \"version\": \"3.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n          \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"brace-expansion\": \"^1.1.7\"\n          }\n        }\n      }\n    },\n    \"@humanwhocodes/config-array\": {\n      \"version\": \"0.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.5.0.tgz\",\n      \"integrity\": \"sha512-FagtKFz74XrTl7y6HCzQpwDfXP0yhxe9lHLD1UZxjvZIcbyRz8zTFF/yYNfSfzU414eDwZ1SrO0Qvtyf+wFMQg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@humanwhocodes/object-schema\": \"^1.2.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["334", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"@humanwhocodes/object-schema\": \"^1.2.0\",\n        \"debug\": \"^4.1.1\",\n        \"minimatch\": \"^3.0.4\"\n      },\n      \"dependencies\": {\n        \"brace-expansion\": {\n          \"version\": \"1.1.11\",\n          \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n          \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",\n            \"concat-map\": \"0.0.1\"\n          }\n        },\n        \"minimatch\": {\n          \"version\": \"3.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n          \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"brace-expansion\": \"^1.1.7\"\n          }\n        }\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["335", {"page_content": "\"brace-expansion\": \"^1.1.7\"\n          }\n        }\n      }\n    },\n    \"@humanwhocodes/object-schema\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz\",\n      \"integrity\": \"sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==\",\n      \"dev\": true\n    },\n    \"@next/eslint-plugin-next\": {\n      \"version\": \"13.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/@next/eslint-plugin-next/-/eslint-plugin-next-13.2.4.tgz\",\n      \"integrity\": \"sha512-ck1lI+7r1mMJpqLNa3LJ5pxCfOB1lfJncKmRJeJxcJqcngaFwylreLP7da6Rrjr6u2gVRTfmnkSkjc80IiQCwQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"glob\": \"7.1.7\"\n      }\n    },\n    \"@nodelib/fs.scandir\": {\n      \"version\": \"2.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["336", {"page_content": "\"resolved\": \"https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz\",\n      \"integrity\": \"sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@nodelib/fs.stat\": \"2.0.5\",\n        \"run-parallel\": \"^1.1.9\"\n      }\n    },\n    \"@nodelib/fs.stat\": {\n      \"version\": \"2.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz\",\n      \"integrity\": \"sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==\",\n      \"dev\": true\n    },\n    \"@nodelib/fs.walk\": {\n      \"version\": \"1.2.8\",\n      \"resolved\": \"https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz\",\n      \"integrity\": \"sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@nodelib/fs.scandir\": \"2.1.5\",\n        \"fastq\": \"^1.6.0\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["337", {"page_content": "\"@nodelib/fs.scandir\": \"2.1.5\",\n        \"fastq\": \"^1.6.0\"\n      }\n    },\n    \"@pkgr/utils\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/@pkgr/utils/-/utils-2.3.1.tgz\",\n      \"integrity\": \"sha512-wfzX8kc1PMyUILA+1Z/EqoE4UCXGy0iRGMhPwdfae1+f0OXlLqCk+By+aMzgJBzR9AzS4CDizioG6Ss1gvAFJw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"cross-spawn\": \"^7.0.3\",\n        \"is-glob\": \"^4.0.3\",\n        \"open\": \"^8.4.0\",\n        \"picocolors\": \"^1.0.0\",\n        \"tiny-glob\": \"^0.2.9\",\n        \"tslib\": \"^2.4.0\"\n      }\n    },\n    \"@rushstack/eslint-patch\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/@rushstack/eslint-patch/-/eslint-patch-1.2.0.tgz\",\n      \"integrity\": \"sha512-sXo/qW2/pAcmT43VoRKOJbDOfV3cYpq3szSVfIThQXNt+E4DfKj361vaAt3c88U5tPUxzEswam7GW48PJqtKAg==\",\n      \"dev\": true\n    },\n    \"@types/commander\": {\n      \"version\": \"2.12.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/commander/-/commander-2.12.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["338", {"page_content": "\"resolved\": \"https://registry.npmjs.org/@types/commander/-/commander-2.12.2.tgz\",\n      \"integrity\": \"sha512-0QEFiR8ljcHp9bAbWxecjVRuAMr16ivPiGOw6KFQBVrVd0RQIcM3xKdRisH2EDWgVWujiYtHwhSkSUoAAGzH7Q==\",\n      \"dev\": true,\n      \"requires\": {\n        \"commander\": \"*\"\n      }\n    },\n    \"@types/figlet\": {\n      \"version\": \"1.5.5\",\n      \"resolved\": \"https://registry.npmjs.org/@types/figlet/-/figlet-1.5.5.tgz\",\n      \"integrity\": \"sha512-0sMBeFoqdGgdXoR/hgKYSWMpFufSpToosNsI2VgmkPqZJgeEXsXNu2hGr0FN401dBro2tNO5y2D6uw3UxVaxbg==\",\n      \"dev\": true\n    },\n    \"@types/inquirer\": {\n      \"version\": \"9.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/inquirer/-/inquirer-9.0.3.tgz\",\n      \"integrity\": \"sha512-CzNkWqQftcmk2jaCWdBTf9Sm7xSw4rkI1zpU/Udw3HX5//adEZUIm9STtoRP1qgWj0CWQtJ9UTvqmO2NNjhMJw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@types/through\": \"*\",\n        \"rxjs\": \"^7.2.0\"\n      }\n    },\n    \"@types/istextorbinary\": {\n      \"version\": \"2.3.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["339", {"page_content": "\"rxjs\": \"^7.2.0\"\n      }\n    },\n    \"@types/istextorbinary\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/@types/istextorbinary/-/istextorbinary-2.3.1.tgz\",\n      \"integrity\": \"sha512-Fu3zxViCkMd2oEkwQ1ITv16MCfybykq1VYjoeqLcYjeq3RhWDnwMb+Ang0MP3xwq17kDkCt8XQ7omTJ/1ukSoQ==\",\n      \"requires\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"@types/json-schema\": {\n      \"version\": \"7.0.11\",\n      \"resolved\": \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.11.tgz\",\n      \"integrity\": \"sha512-wOuvG1SN4Us4rez+tylwwwCV1psiNVOkJeM3AUWUNWg/jDQY2+HE/444y5gc+jBmRqASOm2Oeh5c1axHobwRKQ==\",\n      \"dev\": true\n    },\n    \"@types/json5\": {\n      \"version\": \"0.0.29\",\n      \"resolved\": \"https://registry.npmjs.org/@types/json5/-/json5-0.0.29.tgz\",\n      \"integrity\": \"sha512-dRLjCWHYg4oaA77cxO64oO+7JwCwnIzkZPdrrC71jQmQtlhM556pwKo5bUzqvZndkVbeFLIIi+9TC40JNF5hNQ==\",\n      \"dev\": true\n    },\n    \"@types/marked\": {\n      \"version\": \"4.0.8\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["340", {"page_content": "\"dev\": true\n    },\n    \"@types/marked\": {\n      \"version\": \"4.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/@types/marked/-/marked-4.0.8.tgz\",\n      \"integrity\": \"sha512-HVNzMT5QlWCOdeuBsgXP8EZzKUf0+AXzN+sLmjvaB3ZlLqO+e4u0uXrdw9ub69wBKFs+c6/pA4r9sy6cCDvImw==\",\n      \"dev\": true\n    },\n    \"@types/marked-terminal\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/marked-terminal/-/marked-terminal-3.1.3.tgz\",\n      \"integrity\": \"sha512-dKgOLKlI5zFb2jTbRcyQqbdrHxeU74DCOkVIZtsoB2sc1ctXZ1iB2uxG2jjAuzoLdvwHP065ijN6Q8HecWdWYg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@types/marked\": \"^3\",\n        \"chalk\": \"^2.4.1\"\n      },\n      \"dependencies\": {\n        \"@types/marked\": {\n          \"version\": \"3.0.3\",\n          \"resolved\": \"https://registry.npmjs.org/@types/marked/-/marked-3.0.3.tgz\",\n          \"integrity\": \"sha512-ZgAr847Wl68W+B0sWH7F4fDPxTzerLnRuUXjUpp1n4NjGSs8hgPAjAp7NQIXblG34MXTrf5wWkAK8PVJ2LIlVg==\",\n          \"dev\": true\n        },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["341", {"page_content": "\"dev\": true\n        },\n        \"ansi-styles\": {\n          \"version\": \"3.2.1\",\n          \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz\",\n          \"integrity\": \"sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"color-convert\": \"^1.9.0\"\n          }\n        },\n        \"chalk\": {\n          \"version\": \"2.4.2\",\n          \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz\",\n          \"integrity\": \"sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==\",\n          \"dev\": true,\n          \"requires\": {\n            \"ansi-styles\": \"^3.2.1\",\n            \"escape-string-regexp\": \"^1.0.5\",\n            \"supports-color\": \"^5.3.0\"\n          }\n        },\n        \"color-convert\": {\n          \"version\": \"1.9.3\",\n          \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["342", {"page_content": "\"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz\",\n          \"integrity\": \"sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==\",\n          \"dev\": true,\n          \"requires\": {\n            \"color-name\": \"1.1.3\"\n          }\n        },\n        \"color-name\": {\n          \"version\": \"1.1.3\",\n          \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz\",\n          \"integrity\": \"sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==\",\n          \"dev\": true\n        },\n        \"escape-string-regexp\": {\n          \"version\": \"1.0.5\",\n          \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz\",\n          \"integrity\": \"sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"@types/node\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["343", {"page_content": "\"dev\": true\n        }\n      }\n    },\n    \"@types/node\": {\n      \"version\": \"18.15.6\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-18.15.6.tgz\",\n      \"integrity\": \"sha512-YErOafCZpK4g+Rp3Q/PBgZNAsWKGunQTm9FA3/Pbcm0VCriTEzcrutQ/SxSc0rytAp0NoFWue669jmKhEtd0sA==\"\n    },\n    \"@types/semver\": {\n      \"version\": \"7.3.13\",\n      \"resolved\": \"https://registry.npmjs.org/@types/semver/-/semver-7.3.13.tgz\",\n      \"integrity\": \"sha512-21cFJr9z3g5dW8B0CVI9g2O9beqaThGQ6ZFBqHfwhzLDKUxaqTIy3vnfah/UPkfOiF2pLq+tGz+W8RyCskuslw==\",\n      \"dev\": true\n    },\n    \"@types/through\": {\n      \"version\": \"0.0.30\",\n      \"resolved\": \"https://registry.npmjs.org/@types/through/-/through-0.0.30.tgz\",\n      \"integrity\": \"sha512-FvnCJljyxhPM3gkRgWmxmDZyAQSiBQQWLI0A0VFL0K7W1oRUrPJSqNO0NvTnLkBcotdlp3lKvaT0JrnyRDkzOg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@types/node\": \"*\"\n      }\n    },\n    \"@typescript-eslint/eslint-plugin\": {\n      \"version\": \"5.56.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["344", {"page_content": "}\n    },\n    \"@typescript-eslint/eslint-plugin\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-5.56.0.tgz\",\n      \"integrity\": \"sha512-ZNW37Ccl3oMZkzxrYDUX4o7cnuPgU+YrcaYXzsRtLB16I1FR5SHMqga3zGsaSliZADCWo2v8qHWqAYIj8nWCCg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@eslint-community/regexpp\": \"^4.4.0\",\n        \"@typescript-eslint/scope-manager\": \"5.56.0\",\n        \"@typescript-eslint/type-utils\": \"5.56.0\",\n        \"@typescript-eslint/utils\": \"5.56.0\",\n        \"debug\": \"^4.3.4\",\n        \"grapheme-splitter\": \"^1.0.4\",\n        \"ignore\": \"^5.2.0\",\n        \"natural-compare-lite\": \"^1.4.0\",\n        \"semver\": \"^7.3.7\",\n        \"tsutils\": \"^3.21.0\"\n      }\n    },\n    \"@typescript-eslint/parser\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.56.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["345", {"page_content": "\"resolved\": \"https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.56.0.tgz\",\n      \"integrity\": \"sha512-sn1OZmBxUsgxMmR8a8U5QM/Wl+tyqlH//jTqCg8daTAmhAk26L2PFhcqPLlYBhYUJMZJK276qLXlHN3a83o2cg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@typescript-eslint/scope-manager\": \"5.56.0\",\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/typescript-estree\": \"5.56.0\",\n        \"debug\": \"^4.3.4\"\n      }\n    },\n    \"@typescript-eslint/scope-manager\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-5.56.0.tgz\",\n      \"integrity\": \"sha512-jGYKyt+iBakD0SA5Ww8vFqGpoV2asSjwt60Gl6YcO8ksQ8s2HlUEyHBMSa38bdLopYqGf7EYQMUIGdT/Luw+sw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/visitor-keys\": \"5.56.0\"\n      }\n    },\n    \"@typescript-eslint/type-utils\": {\n      \"version\": \"5.56.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["346", {"page_content": "}\n    },\n    \"@typescript-eslint/type-utils\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-5.56.0.tgz\",\n      \"integrity\": \"sha512-8WxgOgJjWRy6m4xg9KoSHPzBNZeQbGlQOH7l2QEhQID/+YseaFxg5J/DLwWSsi9Axj4e/cCiKx7PVzOq38tY4A==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@typescript-eslint/typescript-estree\": \"5.56.0\",\n        \"@typescript-eslint/utils\": \"5.56.0\",\n        \"debug\": \"^4.3.4\",\n        \"tsutils\": \"^3.21.0\"\n      }\n    },\n    \"@typescript-eslint/types\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/types/-/types-5.56.0.tgz\",\n      \"integrity\": \"sha512-JyAzbTJcIyhuUhogmiu+t79AkdnqgPUEsxMTMc/dCZczGMJQh1MK2wgrju++yMN6AWroVAy2jxyPcPr3SWCq5w==\",\n      \"dev\": true\n    },\n    \"@typescript-eslint/typescript-estree\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-5.56.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["347", {"page_content": "\"integrity\": \"sha512-41CH/GncsLXOJi0jb74SnC7jVPWeVJ0pxQj8bOjH1h2O26jXN3YHKDT1ejkVz5YeTEQPeLCCRY0U2r68tfNOcg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/visitor-keys\": \"5.56.0\",\n        \"debug\": \"^4.3.4\",\n        \"globby\": \"^11.1.0\",\n        \"is-glob\": \"^4.0.3\",\n        \"semver\": \"^7.3.7\",\n        \"tsutils\": \"^3.21.0\"\n      }\n    },\n    \"@typescript-eslint/utils\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/utils/-/utils-5.56.0.tgz\",\n      \"integrity\": \"sha512-XhZDVdLnUJNtbzaJeDSCIYaM+Tgr59gZGbFuELgF7m0IY03PlciidS7UQNKLE0+WpUTn1GlycEr6Ivb/afjbhA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@eslint-community/eslint-utils\": \"^4.2.0\",\n        \"@types/json-schema\": \"^7.0.9\",\n        \"@types/semver\": \"^7.3.12\",\n        \"@typescript-eslint/scope-manager\": \"5.56.0\",\n        \"@typescript-eslint/types\": \"5.56.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["348", {"page_content": "\"@typescript-eslint/scope-manager\": \"5.56.0\",\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"@typescript-eslint/typescript-estree\": \"5.56.0\",\n        \"eslint-scope\": \"^5.1.1\",\n        \"semver\": \"^7.3.7\"\n      }\n    },\n    \"@typescript-eslint/visitor-keys\": {\n      \"version\": \"5.56.0\",\n      \"resolved\": \"https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-5.56.0.tgz\",\n      \"integrity\": \"sha512-1mFdED7u5bZpX6Xxf5N9U2c18sb+8EvU3tyOIj6LQZ5OOvnmj8BVeNNP603OFPm5KkS1a7IvCIcwrdHXaEMG/Q==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@typescript-eslint/types\": \"5.56.0\",\n        \"eslint-visitor-keys\": \"^3.3.0\"\n      }\n    },\n    \"acorn\": {\n      \"version\": \"7.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz\",\n      \"integrity\": \"sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==\",\n      \"dev\": true\n    },\n    \"acorn-jsx\": {\n      \"version\": \"5.3.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["349", {"page_content": "\"dev\": true\n    },\n    \"acorn-jsx\": {\n      \"version\": \"5.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz\",\n      \"integrity\": \"sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==\",\n      \"dev\": true,\n      \"requires\": {}\n    },\n    \"ajv\": {\n      \"version\": \"6.12.6\",\n      \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz\",\n      \"integrity\": \"sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"fast-deep-equal\": \"^3.1.1\",\n        \"fast-json-stable-stringify\": \"^2.0.0\",\n        \"json-schema-traverse\": \"^0.4.1\",\n        \"uri-js\": \"^4.2.2\"\n      }\n    },\n    \"ansi-colors\": {\n      \"version\": \"4.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.3.tgz\",\n      \"integrity\": \"sha512-/6w/C21Pm1A7aZitlI5Ni/2J6FFQN8i1Cvz3kHABAAbw93v/NlvKdVOqz7CCWz/3iv/JplRSEEZ83XION15ovw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["350", {"page_content": "\"dev\": true\n    },\n    \"ansi-escapes\": {\n      \"version\": \"6.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-6.1.0.tgz\",\n      \"integrity\": \"sha512-bQyg9bzRntwR/8b89DOEhGwctcwCrbWW/TuqTQnpqpy5Fz3aovcOTj5i8NJV6AHc8OGNdMaqdxAWww8pz2kiKg==\",\n      \"requires\": {\n        \"type-fest\": \"^3.0.0\"\n      },\n      \"dependencies\": {\n        \"type-fest\": {\n          \"version\": \"3.7.0\",\n          \"resolved\": \"https://registry.npmjs.org/type-fest/-/type-fest-3.7.0.tgz\",\n          \"integrity\": \"sha512-A2qUJ/j8vkKIT+UorxayZjFJoEdNkIPZkjOJSWezoAbRQd7QEhnz2iJlfVy4Or0GuEnCXts5cNorQNUvdLkaSQ==\"\n        }\n      }\n    },\n    \"ansi-regex\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\",\n      \"integrity\": \"sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\"\n    },\n    \"ansi-styles\": {\n      \"version\": \"4.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["351", {"page_content": "},\n    \"ansi-styles\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz\",\n      \"integrity\": \"sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"color-convert\": \"^2.0.1\"\n      }\n    },\n    \"ansicolors\": {\n      \"version\": \"0.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/ansicolors/-/ansicolors-0.3.2.tgz\",\n      \"integrity\": \"sha512-QXu7BPrP29VllRxH8GwB7x5iX5qWKAAMLqKQGWTeLWVlNHNOpVMJ91dsxQAIWXpjuW5wqvxu3Jd/nRjrJ+0pqg==\"\n    },\n    \"argparse\": {\n      \"version\": \"1.0.10\",\n      \"resolved\": \"https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz\",\n      \"integrity\": \"sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"sprintf-js\": \"~1.0.2\"\n      }\n    },\n    \"aria-query\": {\n      \"version\": \"5.1.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["352", {"page_content": "\"sprintf-js\": \"~1.0.2\"\n      }\n    },\n    \"aria-query\": {\n      \"version\": \"5.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/aria-query/-/aria-query-5.1.3.tgz\",\n      \"integrity\": \"sha512-R5iJ5lkuHybztUfuOAznmboyjWq8O6sqNqtK7CLOqdydi54VNbORp49mb14KbWgG1QD3JFO9hJdZ+y4KutfdOQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"deep-equal\": \"^2.0.5\"\n      }\n    },\n    \"array-buffer-byte-length\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/array-buffer-byte-length/-/array-buffer-byte-length-1.0.0.tgz\",\n      \"integrity\": \"sha512-LPuwb2P+NrQw3XhxGc36+XSvuBPopovXYTR9Ew++Du9Yb/bx5AzBfrIsBoj0EZUifjQU+sHL21sseZ3jerWO/A==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"is-array-buffer\": \"^3.0.1\"\n      }\n    },\n    \"array-includes\": {\n      \"version\": \"3.1.6\",\n      \"resolved\": \"https://registry.npmjs.org/array-includes/-/array-includes-3.1.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["353", {"page_content": "\"resolved\": \"https://registry.npmjs.org/array-includes/-/array-includes-3.1.6.tgz\",\n      \"integrity\": \"sha512-sgTbLvL6cNnw24FnbaDyjmvddQ2ML8arZsgaJhoABMoplz/4QRhtrYS+alr1BUM1Bwp6dhx8vVCBSLG+StwOFw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"is-string\": \"^1.0.7\"\n      }\n    },\n    \"array-keyed-map\": {\n      \"version\": \"2.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/array-keyed-map/-/array-keyed-map-2.1.3.tgz\",\n      \"integrity\": \"sha512-JIUwuFakO+jHjxyp4YgSiKXSZeC0U+R1jR94bXWBcVlFRBycqXlb+kH9JHxBGcxnVuSqx5bnn0Qz9xtSeKOjiA==\"\n    },\n    \"array-union\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz\",\n      \"integrity\": \"sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["354", {"page_content": "\"dev\": true\n    },\n    \"array.prototype.flat\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/array.prototype.flat/-/array.prototype.flat-1.3.1.tgz\",\n      \"integrity\": \"sha512-roTU0KWIOmJ4DRLmwKd19Otg0/mT3qPNt0Qb3GWW8iObuZXxrjB/pzn0R3hqpRSWg4HCwqx+0vwOnWnvlOyeIA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"es-shim-unscopables\": \"^1.0.0\"\n      }\n    },\n    \"array.prototype.flatmap\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/array.prototype.flatmap/-/array.prototype.flatmap-1.3.1.tgz\",\n      \"integrity\": \"sha512-8UGn9O1FDVvMNB0UlLv4voxRMze7+FpHyF5mSMRjWHUMlpoDViniy05870VlxhfgTnLbpuwTzvD76MTtWxB/mQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"es-shim-unscopables\": \"^1.0.0\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["355", {"page_content": "\"es-abstract\": \"^1.20.4\",\n        \"es-shim-unscopables\": \"^1.0.0\"\n      }\n    },\n    \"array.prototype.tosorted\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/array.prototype.tosorted/-/array.prototype.tosorted-1.1.1.tgz\",\n      \"integrity\": \"sha512-pZYPXPRl2PqWcsUs6LOMn+1f1532nEoPTYowBtqLwAW+W8vSVhkIGnmOX1t/UQjD6YGI0vcD2B1U7ZFGQH9jnQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"es-shim-unscopables\": \"^1.0.0\",\n        \"get-intrinsic\": \"^1.1.3\"\n      }\n    },\n    \"ast-types-flow\": {\n      \"version\": \"0.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/ast-types-flow/-/ast-types-flow-0.0.7.tgz\",\n      \"integrity\": \"sha512-eBvWn1lvIApYMhzQMsu9ciLfkBY499mFZlNqG+/9WR7PVlroQw0vG30cOQQbaKz3sCEc44TAOu2ykzqXSNnwag==\",\n      \"dev\": true\n    },\n    \"astral-regex\": {\n      \"version\": \"2.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["356", {"page_content": "\"dev\": true\n    },\n    \"astral-regex\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz\",\n      \"integrity\": \"sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==\",\n      \"dev\": true\n    },\n    \"asynckit\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz\",\n      \"integrity\": \"sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==\"\n    },\n    \"available-typed-arrays\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/available-typed-arrays/-/available-typed-arrays-1.0.5.tgz\",\n      \"integrity\": \"sha512-DMD0KiN46eipeziST1LPP/STfDU0sufISXmjSgvVsoU2tqxctQeASejWcfNtxYKqETM1UxQ8sp2OrSBWpHY6sw==\",\n      \"dev\": true\n    },\n    \"axe-core\": {\n      \"version\": \"4.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/axe-core/-/axe-core-4.6.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["357", {"page_content": "\"resolved\": \"https://registry.npmjs.org/axe-core/-/axe-core-4.6.3.tgz\",\n      \"integrity\": \"sha512-/BQzOX780JhsxDnPpH4ZiyrJAzcd8AfzFPkv+89veFSr1rcMjuq2JDCwypKaPeB6ljHp9KjXhPpjgCvQlWYuqg==\",\n      \"dev\": true\n    },\n    \"axios\": {\n      \"version\": \"0.26.1\",\n      \"resolved\": \"https://registry.npmjs.org/axios/-/axios-0.26.1.tgz\",\n      \"integrity\": \"sha512-fPwcX4EvnSHuInCMItEhAGnaSEXRBjtzh9fOtsE6E1G6p7vl7edEeZe11QHf18+6+9gR5PbKV/sGKNaD8YaMeA==\",\n      \"requires\": {\n        \"follow-redirects\": \"^1.14.8\"\n      }\n    },\n    \"axobject-query\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/axobject-query/-/axobject-query-3.1.1.tgz\",\n      \"integrity\": \"sha512-goKlv8DZrK9hUh975fnHzhNIO4jUnFCfv/dszV5VwUGDFjI6vQ2VwoyjYjYNEbBE8AH87TduWP5uyDR1D+Iteg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"deep-equal\": \"^2.0.5\"\n      }\n    },\n    \"balanced-match\": {\n      \"version\": \"1.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["358", {"page_content": "\"deep-equal\": \"^2.0.5\"\n      }\n    },\n    \"balanced-match\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n      \"integrity\": \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\"\n    },\n    \"base64-js\": {\n      \"version\": \"1.5.1\",\n      \"resolved\": \"https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz\",\n      \"integrity\": \"sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==\"\n    },\n    \"binary-extensions\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz\",\n      \"integrity\": \"sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==\"\n    },\n    \"binaryextensions\": {\n      \"version\": \"4.18.0\",\n      \"resolved\": \"https://registry.npmjs.org/binaryextensions/-/binaryextensions-4.18.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["359", {"page_content": "\"resolved\": \"https://registry.npmjs.org/binaryextensions/-/binaryextensions-4.18.0.tgz\",\n      \"integrity\": \"sha512-PQu3Kyv9dM4FnwB7XGj1+HucW+ShvJzJqjuw1JkKVs1mWdwOKVcRjOi+pV9X52A0tNvrPCsPkbFFQb+wE1EAXw==\"\n    },\n    \"bindings\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/bindings/-/bindings-1.5.0.tgz\",\n      \"integrity\": \"sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==\",\n      \"requires\": {\n        \"file-uri-to-path\": \"1.0.0\"\n      }\n    },\n    \"bl\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/bl/-/bl-5.1.0.tgz\",\n      \"integrity\": \"sha512-tv1ZJHLfTDnXE6tMHv73YgSJaWR2AFuPwMntBe7XL/GBFHnT0CLnsHMogfk5+GzCDC5ZWarSCYaIGATZt9dNsQ==\",\n      \"requires\": {\n        \"buffer\": \"^6.0.3\",\n        \"inherits\": \"^2.0.4\",\n        \"readable-stream\": \"^3.4.0\"\n      }\n    },\n    \"brace-expansion\": {\n      \"version\": \"2.0.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["360", {"page_content": "}\n    },\n    \"brace-expansion\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz\",\n      \"integrity\": \"sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==\",\n      \"requires\": {\n        \"balanced-match\": \"^1.0.0\"\n      }\n    },\n    \"braces\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/braces/-/braces-3.0.2.tgz\",\n      \"integrity\": \"sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==\",\n      \"dev\": true,\n      \"requires\": {\n        \"fill-range\": \"^7.0.1\"\n      }\n    },\n    \"browser-or-node\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/browser-or-node/-/browser-or-node-2.1.1.tgz\",\n      \"integrity\": \"sha512-8CVjaLJGuSKMVTxJ2DpBl5XnlNDiT4cQFeuCJJrvJmts9YrTZDizTX7PjC2s6W4x+MBGZeEY6dGMrF04/6Hgqg==\"\n    },\n    \"buffer\": {\n      \"version\": \"6.0.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["361", {"page_content": "},\n    \"buffer\": {\n      \"version\": \"6.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz\",\n      \"integrity\": \"sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==\",\n      \"requires\": {\n        \"base64-js\": \"^1.3.1\",\n        \"ieee754\": \"^1.2.1\"\n      }\n    },\n    \"call-bind\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz\",\n      \"integrity\": \"sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"function-bind\": \"^1.1.1\",\n        \"get-intrinsic\": \"^1.0.2\"\n      }\n    },\n    \"callsites\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz\",\n      \"integrity\": \"sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==\",\n      \"dev\": true\n    },\n    \"cardinal\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["362", {"page_content": "\"dev\": true\n    },\n    \"cardinal\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/cardinal/-/cardinal-2.1.1.tgz\",\n      \"integrity\": \"sha512-JSr5eOgoEymtYHBjNWyjrMqet9Am2miJhlfKNdqLp6zoeAh0KN5dRAcxlecj5mAJrmQomgiOBj35xHLrFjqBpw==\",\n      \"requires\": {\n        \"ansicolors\": \"~0.3.2\",\n        \"redeyed\": \"~2.1.0\"\n      }\n    },\n    \"chalk\": {\n      \"version\": \"5.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-5.2.0.tgz\",\n      \"integrity\": \"sha512-ree3Gqw/nazQAPuJJEy+avdl7QfZMcUvmHIKgEZkGL+xOBzRvup5Hxo6LHuMceSxOabuJLJm5Yp/92R9eMmMvA==\"\n    },\n    \"chardet\": {\n      \"version\": \"0.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/chardet/-/chardet-0.7.0.tgz\",\n      \"integrity\": \"sha512-mT8iDcrh03qDGRRmoA2hmBJnxpllMR+0/0qlzjqZES6NdiWDcZkCNAk4rPFZ9Q85r27unkiNNg8ZOiwZXBHwcA==\"\n    },\n    \"cli-cursor\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-cursor/-/cli-cursor-4.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["363", {"page_content": "\"resolved\": \"https://registry.npmjs.org/cli-cursor/-/cli-cursor-4.0.0.tgz\",\n      \"integrity\": \"sha512-VGtlMu3x/4DOtIUwEkRezxUZ2lBacNJCHash0N0WeZDBS+7Ux1dm3XWAgWYxLJFMMdOeXMHXorshEFhbMSGelg==\",\n      \"requires\": {\n        \"restore-cursor\": \"^4.0.0\"\n      }\n    },\n    \"cli-progress\": {\n      \"version\": \"3.12.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-progress/-/cli-progress-3.12.0.tgz\",\n      \"integrity\": \"sha512-tRkV3HJ1ASwm19THiiLIXLO7Im7wlTuKnvkYaTkyoAPefqjNg7W7DHKUlGRxy9vxDvbyCYQkQozvptuMkGCg8A==\",\n      \"requires\": {\n        \"string-width\": \"^4.2.3\"\n      }\n    },\n    \"cli-spinners\": {\n      \"version\": \"2.7.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-spinners/-/cli-spinners-2.7.0.tgz\",\n      \"integrity\": \"sha512-qu3pN8Y3qHNgE2AFweciB1IfMnmZ/fsNTEE+NOFjmGB2F/7rLhnhzppvpCnN4FovtP26k8lHyy9ptEbNwWFLzw==\"\n    },\n    \"cli-table3\": {\n      \"version\": \"0.6.3\",\n      \"resolved\": \"https://registry.npmjs.org/cli-table3/-/cli-table3-0.6.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["364", {"page_content": "\"resolved\": \"https://registry.npmjs.org/cli-table3/-/cli-table3-0.6.3.tgz\",\n      \"integrity\": \"sha512-w5Jac5SykAeZJKntOxJCrm63Eg5/4dhMWIcuTbo9rpE+brgaSZo0RuNJZeOyMgsUdhDeojvgyQLmjI+K50ZGyg==\",\n      \"requires\": {\n        \"@colors/colors\": \"1.5.0\",\n        \"string-width\": \"^4.2.0\"\n      }\n    },\n    \"cli-width\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/cli-width/-/cli-width-4.0.0.tgz\",\n      \"integrity\": \"sha512-ZksGS2xpa/bYkNzN3BAw1wEjsLV/ZKOf/CCrJ/QOBsxx6fOARIkwTutxp1XIOIohi6HKmOFjMoK/XaqDVUpEEw==\"\n    },\n    \"clone\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/clone/-/clone-1.0.4.tgz\",\n      \"integrity\": \"sha512-JQHZ2QMW6l3aH/j6xCqQThY/9OH4D/9ls34cgkUBiEeocRTU04tHfKPBsUK1PqZCUQM7GiA0IIXJSuXHI64Kbg==\"\n    },\n    \"color-convert\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["365", {"page_content": "\"resolved\": \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\",\n      \"integrity\": \"sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"color-name\": \"~1.1.4\"\n      }\n    },\n    \"color-name\": {\n      \"version\": \"1.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\",\n      \"integrity\": \"sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\",\n      \"dev\": true\n    },\n    \"combined-stream\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz\",\n      \"integrity\": \"sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==\",\n      \"requires\": {\n        \"delayed-stream\": \"~1.0.0\"\n      }\n    },\n    \"commander\": {\n      \"version\": \"10.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["366", {"page_content": "\"delayed-stream\": \"~1.0.0\"\n      }\n    },\n    \"commander\": {\n      \"version\": \"10.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/commander/-/commander-10.0.0.tgz\",\n      \"integrity\": \"sha512-zS5PnTI22FIRM6ylNW8G4Ap0IEOyk62fhLSD0+uHRT9McRCLGpkVNvao4bjimpK/GShynyQkFFxHhwMcETmduA==\"\n    },\n    \"concat-map\": {\n      \"version\": \"0.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n      \"integrity\": \"sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==\",\n      \"dev\": true\n    },\n    \"cross-spawn\": {\n      \"version\": \"7.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz\",\n      \"integrity\": \"sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==\",\n      \"dev\": true,\n      \"requires\": {\n        \"path-key\": \"^3.1.0\",\n        \"shebang-command\": \"^2.0.0\",\n        \"which\": \"^2.0.1\"\n      }\n    },\n    \"damerau-levenshtein\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["367", {"page_content": "\"which\": \"^2.0.1\"\n      }\n    },\n    \"damerau-levenshtein\": {\n      \"version\": \"1.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/damerau-levenshtein/-/damerau-levenshtein-1.0.8.tgz\",\n      \"integrity\": \"sha512-sdQSFB7+llfUcQHUQO3+B8ERRj0Oa4w9POWMI/puGtuf7gFywGmkaLCElnudfTiKZV+NvHqL0ifzdrI8Ro7ESA==\",\n      \"dev\": true\n    },\n    \"debug\": {\n      \"version\": \"4.3.4\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-4.3.4.tgz\",\n      \"integrity\": \"sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"ms\": \"2.1.2\"\n      }\n    },\n    \"deep-equal\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/deep-equal/-/deep-equal-2.2.0.tgz\",\n      \"integrity\": \"sha512-RdpzE0Hv4lhowpIUKKMJfeH6C1pXdtT1/it80ubgWqwI3qpuxUBpC1S4hnHg+zjnuOoDkzUtUCEEkG+XG5l3Mw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"es-get-iterator\": \"^1.1.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["368", {"page_content": "\"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"es-get-iterator\": \"^1.1.2\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"is-arguments\": \"^1.1.1\",\n        \"is-array-buffer\": \"^3.0.1\",\n        \"is-date-object\": \"^1.0.5\",\n        \"is-regex\": \"^1.1.4\",\n        \"is-shared-array-buffer\": \"^1.0.2\",\n        \"isarray\": \"^2.0.5\",\n        \"object-is\": \"^1.1.5\",\n        \"object-keys\": \"^1.1.1\",\n        \"object.assign\": \"^4.1.4\",\n        \"regexp.prototype.flags\": \"^1.4.3\",\n        \"side-channel\": \"^1.0.4\",\n        \"which-boxed-primitive\": \"^1.0.2\",\n        \"which-collection\": \"^1.0.1\",\n        \"which-typed-array\": \"^1.1.9\"\n      }\n    },\n    \"deep-is\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz\",\n      \"integrity\": \"sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==\",\n      \"dev\": true\n    },\n    \"defaults\": {\n      \"version\": \"1.0.4\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["369", {"page_content": "\"dev\": true\n    },\n    \"defaults\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/defaults/-/defaults-1.0.4.tgz\",\n      \"integrity\": \"sha512-eFuaLoy/Rxalv2kr+lqMlUnrDWV+3j4pljOIJgLIhI058IQfWJ7vXhyEIHu+HtC738klGALYxOKDO0bQP3tg8A==\",\n      \"requires\": {\n        \"clone\": \"^1.0.2\"\n      }\n    },\n    \"define-lazy-prop\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/define-lazy-prop/-/define-lazy-prop-2.0.0.tgz\",\n      \"integrity\": \"sha512-Ds09qNh8yw3khSjiJjiUInaGX9xlqZDY7JVryGxdxV7NPeuqQfplOpQ66yJFZut3jLa5zOwkXw1g9EI2uKh4Og==\",\n      \"dev\": true\n    },\n    \"define-properties\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/define-properties/-/define-properties-1.2.0.tgz\",\n      \"integrity\": \"sha512-xvqAVKGfT1+UAvPwKTVw/njhdQ8ZhXK4lI0bCIuCMrp2up9nPnaDftrLtmpTazqd1o+UY4zgzU+avtMbDP+ldA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-property-descriptors\": \"^1.0.0\",\n        \"object-keys\": \"^1.1.1\"", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["370", {"page_content": "\"requires\": {\n        \"has-property-descriptors\": \"^1.0.0\",\n        \"object-keys\": \"^1.1.1\"\n      }\n    },\n    \"delayed-stream\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz\",\n      \"integrity\": \"sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==\"\n    },\n    \"dir-glob\": {\n      \"version\": \"3.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz\",\n      \"integrity\": \"sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"path-type\": \"^4.0.0\"\n      }\n    },\n    \"doctrine\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz\",\n      \"integrity\": \"sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==\",\n      \"dev\": true,\n      \"requires\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["371", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"esutils\": \"^2.0.2\"\n      }\n    },\n    \"eastasianwidth\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz\",\n      \"integrity\": \"sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==\"\n    },\n    \"emoji-regex\": {\n      \"version\": \"9.2.2\",\n      \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz\",\n      \"integrity\": \"sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==\"\n    },\n    \"enhanced-resolve\": {\n      \"version\": \"5.12.0\",\n      \"resolved\": \"https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.12.0.tgz\",\n      \"integrity\": \"sha512-QHTXI/sZQmko1cbDoNAa3mJ5qhWUUNAq3vR0/YiD379fWQrcfuoX1+HW2S0MTt7XmoPLapdaDKUtelUSPic7hQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"graceful-fs\": \"^4.2.4\",\n        \"tapable\": \"^2.2.0\"\n      }\n    },\n    \"enquirer\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["372", {"page_content": "\"graceful-fs\": \"^4.2.4\",\n        \"tapable\": \"^2.2.0\"\n      }\n    },\n    \"enquirer\": {\n      \"version\": \"2.3.6\",\n      \"resolved\": \"https://registry.npmjs.org/enquirer/-/enquirer-2.3.6.tgz\",\n      \"integrity\": \"sha512-yjNnPr315/FjS4zIsUxYguYUPP2e1NK4d7E7ZOLiyYCcbFBiTMyID+2wvm2w6+pZ/odMA7cRkjhsPbltwBOrLg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"ansi-colors\": \"^4.1.1\"\n      }\n    },\n    \"es-abstract\": {\n      \"version\": \"1.21.2\",\n      \"resolved\": \"https://registry.npmjs.org/es-abstract/-/es-abstract-1.21.2.tgz\",\n      \"integrity\": \"sha512-y/B5POM2iBnIxCiernH1G7rC9qQoM77lLIMQLuob0zhp8C56Po81+2Nj0WFKnd0pNReDTnkYryc+zhOzpEIROg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"array-buffer-byte-length\": \"^1.0.0\",\n        \"available-typed-arrays\": \"^1.0.5\",\n        \"call-bind\": \"^1.0.2\",\n        \"es-set-tostringtag\": \"^2.0.1\",\n        \"es-to-primitive\": \"^1.2.1\",\n        \"function.prototype.name\": \"^1.1.5\",\n        \"get-intrinsic\": \"^1.2.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["373", {"page_content": "\"function.prototype.name\": \"^1.1.5\",\n        \"get-intrinsic\": \"^1.2.0\",\n        \"get-symbol-description\": \"^1.0.0\",\n        \"globalthis\": \"^1.0.3\",\n        \"gopd\": \"^1.0.1\",\n        \"has\": \"^1.0.3\",\n        \"has-property-descriptors\": \"^1.0.0\",\n        \"has-proto\": \"^1.0.1\",\n        \"has-symbols\": \"^1.0.3\",\n        \"internal-slot\": \"^1.0.5\",\n        \"is-array-buffer\": \"^3.0.2\",\n        \"is-callable\": \"^1.2.7\",\n        \"is-negative-zero\": \"^2.0.2\",\n        \"is-regex\": \"^1.1.4\",\n        \"is-shared-array-buffer\": \"^1.0.2\",\n        \"is-string\": \"^1.0.7\",\n        \"is-typed-array\": \"^1.1.10\",\n        \"is-weakref\": \"^1.0.2\",\n        \"object-inspect\": \"^1.12.3\",\n        \"object-keys\": \"^1.1.1\",\n        \"object.assign\": \"^4.1.4\",\n        \"regexp.prototype.flags\": \"^1.4.3\",\n        \"safe-regex-test\": \"^1.0.0\",\n        \"string.prototype.trim\": \"^1.2.7\",\n        \"string.prototype.trimend\": \"^1.0.6\",\n        \"string.prototype.trimstart\": \"^1.0.6\",\n        \"typed-array-length\": \"^1.0.4\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["374", {"page_content": "\"string.prototype.trimstart\": \"^1.0.6\",\n        \"typed-array-length\": \"^1.0.4\",\n        \"unbox-primitive\": \"^1.0.2\",\n        \"which-typed-array\": \"^1.1.9\"\n      }\n    },\n    \"es-get-iterator\": {\n      \"version\": \"1.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/es-get-iterator/-/es-get-iterator-1.1.3.tgz\",\n      \"integrity\": \"sha512-sPZmqHBe6JIiTfN5q2pEi//TwxmAFHwj/XEuYjTuse78i8KxaqMTTzxPoFKuzRpDpTJ+0NAbpfenkmH2rePtuw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"has-symbols\": \"^1.0.3\",\n        \"is-arguments\": \"^1.1.1\",\n        \"is-map\": \"^2.0.2\",\n        \"is-set\": \"^2.0.2\",\n        \"is-string\": \"^1.0.7\",\n        \"isarray\": \"^2.0.5\",\n        \"stop-iteration-iterator\": \"^1.0.0\"\n      }\n    },\n    \"es-set-tostringtag\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["375", {"page_content": "\"resolved\": \"https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.0.1.tgz\",\n      \"integrity\": \"sha512-g3OMbtlwY3QewlqAiMLI47KywjWZoEytKr8pf6iTC8uJq5bIAH52Z9pnQ8pVL6whrCto53JZDuUIsifGeLorTg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"get-intrinsic\": \"^1.1.3\",\n        \"has\": \"^1.0.3\",\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"es-shim-unscopables\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/es-shim-unscopables/-/es-shim-unscopables-1.0.0.tgz\",\n      \"integrity\": \"sha512-Jm6GPcCdC30eMLbZ2x8z2WuRwAws3zTBBKuusffYVUrNj/GVSUAZ+xKMaUpfNDR5IbyNA5LJbaecoUVbmUcB1w==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has\": \"^1.0.3\"\n      }\n    },\n    \"es-to-primitive\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/es-to-primitive/-/es-to-primitive-1.2.1.tgz\",\n      \"integrity\": \"sha512-QCOllgZJtaUo9miYBcLChTUaHNjJF3PYs1VidD7AwiEj1kYxKeQTctLAezAOH5ZKRH0g2IgPn6KwB4IT8iRpvA==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["376", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"is-callable\": \"^1.1.4\",\n        \"is-date-object\": \"^1.0.1\",\n        \"is-symbol\": \"^1.0.2\"\n      }\n    },\n    \"esbuild\": {\n      \"version\": \"0.17.12\",\n      \"resolved\": \"https://registry.npmjs.org/esbuild/-/esbuild-0.17.12.tgz\",\n      \"integrity\": \"sha512-bX/zHl7Gn2CpQwcMtRogTTBf9l1nl+H6R8nUbjk+RuKqAE3+8FDulLA+pHvX7aA7Xe07Iwa+CWvy9I8Y2qqPKQ==\",\n      \"requires\": {\n        \"@esbuild/android-arm\": \"0.17.12\",\n        \"@esbuild/android-arm64\": \"0.17.12\",\n        \"@esbuild/android-x64\": \"0.17.12\",\n        \"@esbuild/darwin-arm64\": \"0.17.12\",\n        \"@esbuild/darwin-x64\": \"0.17.12\",\n        \"@esbuild/freebsd-arm64\": \"0.17.12\",\n        \"@esbuild/freebsd-x64\": \"0.17.12\",\n        \"@esbuild/linux-arm\": \"0.17.12\",\n        \"@esbuild/linux-arm64\": \"0.17.12\",\n        \"@esbuild/linux-ia32\": \"0.17.12\",\n        \"@esbuild/linux-loong64\": \"0.17.12\",\n        \"@esbuild/linux-mips64el\": \"0.17.12\",\n        \"@esbuild/linux-ppc64\": \"0.17.12\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["377", {"page_content": "\"@esbuild/linux-mips64el\": \"0.17.12\",\n        \"@esbuild/linux-ppc64\": \"0.17.12\",\n        \"@esbuild/linux-riscv64\": \"0.17.12\",\n        \"@esbuild/linux-s390x\": \"0.17.12\",\n        \"@esbuild/linux-x64\": \"0.17.12\",\n        \"@esbuild/netbsd-x64\": \"0.17.12\",\n        \"@esbuild/openbsd-x64\": \"0.17.12\",\n        \"@esbuild/sunos-x64\": \"0.17.12\",\n        \"@esbuild/win32-arm64\": \"0.17.12\",\n        \"@esbuild/win32-ia32\": \"0.17.12\",\n        \"@esbuild/win32-x64\": \"0.17.12\"\n      }\n    },\n    \"escape-string-regexp\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz\",\n      \"integrity\": \"sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==\",\n      \"dev\": true\n    },\n    \"eslint\": {\n      \"version\": \"7.32.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["378", {"page_content": "\"resolved\": \"https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz\",\n      \"integrity\": \"sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@babel/code-frame\": \"7.12.11\",\n        \"@eslint/eslintrc\": \"^0.4.3\",\n        \"@humanwhocodes/config-array\": \"^0.5.0\",\n        \"ajv\": \"^6.10.0\",\n        \"chalk\": \"^4.0.0\",\n        \"cross-spawn\": \"^7.0.2\",\n        \"debug\": \"^4.0.1\",\n        \"doctrine\": \"^3.0.0\",\n        \"enquirer\": \"^2.3.5\",\n        \"escape-string-regexp\": \"^4.0.0\",\n        \"eslint-scope\": \"^5.1.1\",\n        \"eslint-utils\": \"^2.1.0\",\n        \"eslint-visitor-keys\": \"^2.0.0\",\n        \"espree\": \"^7.3.1\",\n        \"esquery\": \"^1.4.0\",\n        \"esutils\": \"^2.0.2\",\n        \"fast-deep-equal\": \"^3.1.3\",\n        \"file-entry-cache\": \"^6.0.1\",\n        \"functional-red-black-tree\": \"^1.0.1\",\n        \"glob-parent\": \"^5.1.2\",\n        \"globals\": \"^13.6.0\",\n        \"ignore\": \"^4.0.6\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["379", {"page_content": "\"glob-parent\": \"^5.1.2\",\n        \"globals\": \"^13.6.0\",\n        \"ignore\": \"^4.0.6\",\n        \"import-fresh\": \"^3.0.0\",\n        \"imurmurhash\": \"^0.1.4\",\n        \"is-glob\": \"^4.0.0\",\n        \"js-yaml\": \"^3.13.1\",\n        \"json-stable-stringify-without-jsonify\": \"^1.0.1\",\n        \"levn\": \"^0.4.1\",\n        \"lodash.merge\": \"^4.6.2\",\n        \"minimatch\": \"^3.0.4\",\n        \"natural-compare\": \"^1.4.0\",\n        \"optionator\": \"^0.9.1\",\n        \"progress\": \"^2.0.0\",\n        \"regexpp\": \"^3.1.0\",\n        \"semver\": \"^7.2.1\",\n        \"strip-ansi\": \"^6.0.0\",\n        \"strip-json-comments\": \"^3.1.0\",\n        \"table\": \"^6.0.9\",\n        \"text-table\": \"^0.2.0\",\n        \"v8-compile-cache\": \"^2.0.3\"\n      },\n      \"dependencies\": {\n        \"brace-expansion\": {\n          \"version\": \"1.1.11\",\n          \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["380", {"page_content": "\"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n          \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",\n            \"concat-map\": \"0.0.1\"\n          }\n        },\n        \"chalk\": {\n          \"version\": \"4.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz\",\n          \"integrity\": \"sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"ansi-styles\": \"^4.1.0\",\n            \"supports-color\": \"^7.1.0\"\n          }\n        },\n        \"eslint-visitor-keys\": {\n          \"version\": \"2.1.0\",\n          \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["381", {"page_content": "\"integrity\": \"sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==\",\n          \"dev\": true\n        },\n        \"has-flag\": {\n          \"version\": \"4.0.0\",\n          \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n          \"integrity\": \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\",\n          \"dev\": true\n        },\n        \"ignore\": {\n          \"version\": \"4.0.6\",\n          \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz\",\n          \"integrity\": \"sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==\",\n          \"dev\": true\n        },\n        \"minimatch\": {\n          \"version\": \"3.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n          \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["382", {"page_content": "\"dev\": true,\n          \"requires\": {\n            \"brace-expansion\": \"^1.1.7\"\n          }\n        },\n        \"supports-color\": {\n          \"version\": \"7.2.0\",\n          \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",\n          \"integrity\": \"sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"has-flag\": \"^4.0.0\"\n          }\n        }\n      }\n    },\n    \"eslint-config-next\": {\n      \"version\": \"13.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-config-next/-/eslint-config-next-13.2.4.tgz\",\n      \"integrity\": \"sha512-lunIBhsoeqw6/Lfkd6zPt25w1bn0znLA/JCL+au1HoEpSb4/PpsOYsYtgV/q+YPsoKIOzFyU5xnb04iZnXjUvg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@next/eslint-plugin-next\": \"13.2.4\",\n        \"@rushstack/eslint-patch\": \"^1.1.3\",\n        \"@typescript-eslint/parser\": \"^5.42.0\",\n        \"eslint-import-resolver-node\": \"^0.3.6\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["383", {"page_content": "\"@typescript-eslint/parser\": \"^5.42.0\",\n        \"eslint-import-resolver-node\": \"^0.3.6\",\n        \"eslint-import-resolver-typescript\": \"^3.5.2\",\n        \"eslint-plugin-import\": \"^2.26.0\",\n        \"eslint-plugin-jsx-a11y\": \"^6.5.1\",\n        \"eslint-plugin-react\": \"^7.31.7\",\n        \"eslint-plugin-react-hooks\": \"^4.5.0\"\n      }\n    },\n    \"eslint-config-prettier\": {\n      \"version\": \"8.8.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-8.8.0.tgz\",\n      \"integrity\": \"sha512-wLbQiFre3tdGgpDv67NQKnJuTlcUVYHas3k+DZCc2U2BadthoEY4B7hLPvAxaqdyOGCzuLfii2fqGph10va7oA==\",\n      \"dev\": true,\n      \"requires\": {}\n    },\n    \"eslint-import-resolver-node\": {\n      \"version\": \"0.3.7\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-import-resolver-node/-/eslint-import-resolver-node-0.3.7.tgz\",\n      \"integrity\": \"sha512-gozW2blMLJCeFpBwugLTGyvVjNoeo1knonXAcatC6bjPBZitotxdWf7Gimr25N4c0AAOo4eOUfaG82IJPDpqCA==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["384", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"debug\": \"^3.2.7\",\n        \"is-core-module\": \"^2.11.0\",\n        \"resolve\": \"^1.22.1\"\n      },\n      \"dependencies\": {\n        \"debug\": {\n          \"version\": \"3.2.7\",\n          \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.7.tgz\",\n          \"integrity\": \"sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==\",\n          \"dev\": true,\n          \"requires\": {\n            \"ms\": \"^2.1.1\"\n          }\n        }\n      }\n    },\n    \"eslint-import-resolver-typescript\": {\n      \"version\": \"3.5.3\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-import-resolver-typescript/-/eslint-import-resolver-typescript-3.5.3.tgz\",\n      \"integrity\": \"sha512-njRcKYBc3isE42LaTcJNVANR3R99H9bAxBDMNDr2W7yq5gYPxbU3MkdhsQukxZ/Xg9C2vcyLlDsbKfRDg0QvCQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"debug\": \"^4.3.4\",\n        \"enhanced-resolve\": \"^5.10.0\",\n        \"get-tsconfig\": \"^4.2.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["385", {"page_content": "\"debug\": \"^4.3.4\",\n        \"enhanced-resolve\": \"^5.10.0\",\n        \"get-tsconfig\": \"^4.2.0\",\n        \"globby\": \"^13.1.2\",\n        \"is-core-module\": \"^2.10.0\",\n        \"is-glob\": \"^4.0.3\",\n        \"synckit\": \"^0.8.4\"\n      },\n      \"dependencies\": {\n        \"globby\": {\n          \"version\": \"13.1.3\",\n          \"resolved\": \"https://registry.npmjs.org/globby/-/globby-13.1.3.tgz\",\n          \"integrity\": \"sha512-8krCNHXvlCgHDpegPzleMq07yMYTO2sXKASmZmquEYWEmCx6J5UTRbp5RwMJkTJGtcQ44YpiUYUiN0b9mzy8Bw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"dir-glob\": \"^3.0.1\",\n            \"fast-glob\": \"^3.2.11\",\n            \"ignore\": \"^5.2.0\",\n            \"merge2\": \"^1.4.1\",\n            \"slash\": \"^4.0.0\"\n          }\n        },\n        \"slash\": {\n          \"version\": \"4.0.0\",\n          \"resolved\": \"https://registry.npmjs.org/slash/-/slash-4.0.0.tgz\",\n          \"integrity\": \"sha512-3dOsAHXXUkQTpOYcoAxLIorMTp4gIQr5IW3iVb7A7lFIp0VHhnynm9izx6TssdrIcVIESAlVjtnO2K8bg+Coew==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["386", {"page_content": "\"dev\": true\n        }\n      }\n    },\n    \"eslint-module-utils\": {\n      \"version\": \"2.7.4\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-module-utils/-/eslint-module-utils-2.7.4.tgz\",\n      \"integrity\": \"sha512-j4GT+rqzCoRKHwURX7pddtIPGySnX9Si/cgMI5ztrcqOPtk5dDEeZ34CQVPphnqkJytlc97Vuk05Um2mJ3gEQA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"debug\": \"^3.2.7\"\n      },\n      \"dependencies\": {\n        \"debug\": {\n          \"version\": \"3.2.7\",\n          \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.7.tgz\",\n          \"integrity\": \"sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==\",\n          \"dev\": true,\n          \"requires\": {\n            \"ms\": \"^2.1.1\"\n          }\n        }\n      }\n    },\n    \"eslint-plugin-import\": {\n      \"version\": \"2.27.5\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-import/-/eslint-plugin-import-2.27.5.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["387", {"page_content": "\"integrity\": \"sha512-LmEt3GVofgiGuiE+ORpnvP+kAm3h6MLZJ4Q5HCyHADofsb4VzXFsRiWj3c0OFiV+3DWFh0qg3v9gcPlfc3zRow==\",\n      \"dev\": true,\n      \"requires\": {\n        \"array-includes\": \"^3.1.6\",\n        \"array.prototype.flat\": \"^1.3.1\",\n        \"array.prototype.flatmap\": \"^1.3.1\",\n        \"debug\": \"^3.2.7\",\n        \"doctrine\": \"^2.1.0\",\n        \"eslint-import-resolver-node\": \"^0.3.7\",\n        \"eslint-module-utils\": \"^2.7.4\",\n        \"has\": \"^1.0.3\",\n        \"is-core-module\": \"^2.11.0\",\n        \"is-glob\": \"^4.0.3\",\n        \"minimatch\": \"^3.1.2\",\n        \"object.values\": \"^1.1.6\",\n        \"resolve\": \"^1.22.1\",\n        \"semver\": \"^6.3.0\",\n        \"tsconfig-paths\": \"^3.14.1\"\n      },\n      \"dependencies\": {\n        \"brace-expansion\": {\n          \"version\": \"1.1.11\",\n          \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n          \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["388", {"page_content": "\"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",\n            \"concat-map\": \"0.0.1\"\n          }\n        },\n        \"debug\": {\n          \"version\": \"3.2.7\",\n          \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.2.7.tgz\",\n          \"integrity\": \"sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==\",\n          \"dev\": true,\n          \"requires\": {\n            \"ms\": \"^2.1.1\"\n          }\n        },\n        \"doctrine\": {\n          \"version\": \"2.1.0\",\n          \"resolved\": \"https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz\",\n          \"integrity\": \"sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"esutils\": \"^2.0.2\"\n          }\n        },\n        \"minimatch\": {\n          \"version\": \"3.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["389", {"page_content": "\"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n          \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"brace-expansion\": \"^1.1.7\"\n          }\n        },\n        \"semver\": {\n          \"version\": \"6.3.0\",\n          \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",\n          \"integrity\": \"sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"eslint-plugin-jsx-a11y\": {\n      \"version\": \"6.7.1\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-jsx-a11y/-/eslint-plugin-jsx-a11y-6.7.1.tgz\",\n      \"integrity\": \"sha512-63Bog4iIethyo8smBklORknVjB0T2dwB8Mr/hIC+fBS0uyHdYYpzM/Ed+YC8VxTjlXHEWFOdmgwcDn1U2L9VCA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@babel/runtime\": \"^7.20.7\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["390", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"@babel/runtime\": \"^7.20.7\",\n        \"aria-query\": \"^5.1.3\",\n        \"array-includes\": \"^3.1.6\",\n        \"array.prototype.flatmap\": \"^1.3.1\",\n        \"ast-types-flow\": \"^0.0.7\",\n        \"axe-core\": \"^4.6.2\",\n        \"axobject-query\": \"^3.1.1\",\n        \"damerau-levenshtein\": \"^1.0.8\",\n        \"emoji-regex\": \"^9.2.2\",\n        \"has\": \"^1.0.3\",\n        \"jsx-ast-utils\": \"^3.3.3\",\n        \"language-tags\": \"=1.0.5\",\n        \"minimatch\": \"^3.1.2\",\n        \"object.entries\": \"^1.1.6\",\n        \"object.fromentries\": \"^2.0.6\",\n        \"semver\": \"^6.3.0\"\n      },\n      \"dependencies\": {\n        \"brace-expansion\": {\n          \"version\": \"1.1.11\",\n          \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n          \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["391", {"page_content": "\"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",\n            \"concat-map\": \"0.0.1\"\n          }\n        },\n        \"minimatch\": {\n          \"version\": \"3.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n          \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"brace-expansion\": \"^1.1.7\"\n          }\n        },\n        \"semver\": {\n          \"version\": \"6.3.0\",\n          \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",\n          \"integrity\": \"sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"eslint-plugin-prettier\": {\n      \"version\": \"4.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-prettier/-/eslint-plugin-prettier-4.2.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["392", {"page_content": "\"integrity\": \"sha512-f/0rXLXUt0oFYs8ra4w49wYZBG5GKZpAYsJSm6rnYL5uVDjd+zowwMwVZHnAjf4edNrKpCDYfXDgmRE/Ak7QyQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"prettier-linter-helpers\": \"^1.0.0\"\n      }\n    },\n    \"eslint-plugin-react\": {\n      \"version\": \"7.32.2\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-react/-/eslint-plugin-react-7.32.2.tgz\",\n      \"integrity\": \"sha512-t2fBMa+XzonrrNkyVirzKlvn5RXzzPwRHtMvLAtVZrt8oxgnTQaYbU6SXTOO1mwQgp1y5+toMSKInnzGr0Knqg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"array-includes\": \"^3.1.6\",\n        \"array.prototype.flatmap\": \"^1.3.1\",\n        \"array.prototype.tosorted\": \"^1.1.1\",\n        \"doctrine\": \"^2.1.0\",\n        \"estraverse\": \"^5.3.0\",\n        \"jsx-ast-utils\": \"^2.4.1 || ^3.0.0\",\n        \"minimatch\": \"^3.1.2\",\n        \"object.entries\": \"^1.1.6\",\n        \"object.fromentries\": \"^2.0.6\",\n        \"object.hasown\": \"^1.1.2\",\n        \"object.values\": \"^1.1.6\",\n        \"prop-types\": \"^15.8.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["393", {"page_content": "\"object.values\": \"^1.1.6\",\n        \"prop-types\": \"^15.8.1\",\n        \"resolve\": \"^2.0.0-next.4\",\n        \"semver\": \"^6.3.0\",\n        \"string.prototype.matchall\": \"^4.0.8\"\n      },\n      \"dependencies\": {\n        \"brace-expansion\": {\n          \"version\": \"1.1.11\",\n          \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n          \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",\n            \"concat-map\": \"0.0.1\"\n          }\n        },\n        \"doctrine\": {\n          \"version\": \"2.1.0\",\n          \"resolved\": \"https://registry.npmjs.org/doctrine/-/doctrine-2.1.0.tgz\",\n          \"integrity\": \"sha512-35mSku4ZXK0vfCuHEDAwt55dg2jNajHZ1odvF+8SSr82EsZY4QmXfuWso8oEd8zRhVObSN18aM0CjSdoBX7zIw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"esutils\": \"^2.0.2\"\n          }\n        },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["394", {"page_content": "\"requires\": {\n            \"esutils\": \"^2.0.2\"\n          }\n        },\n        \"minimatch\": {\n          \"version\": \"3.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n          \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"brace-expansion\": \"^1.1.7\"\n          }\n        },\n        \"resolve\": {\n          \"version\": \"2.0.0-next.4\",\n          \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-2.0.0-next.4.tgz\",\n          \"integrity\": \"sha512-iMDbmAWtfU+MHpxt/I5iWI7cY6YVEZUQ3MBgPQ++XD1PELuJHIl82xBmObyP2KyQmkNB2dsqF7seoQQiAn5yDQ==\",\n          \"dev\": true,\n          \"requires\": {\n            \"is-core-module\": \"^2.9.0\",\n            \"path-parse\": \"^1.0.7\",\n            \"supports-preserve-symlinks-flag\": \"^1.0.0\"\n          }\n        },\n        \"semver\": {\n          \"version\": \"6.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["395", {"page_content": "}\n        },\n        \"semver\": {\n          \"version\": \"6.3.0\",\n          \"resolved\": \"https://registry.npmjs.org/semver/-/semver-6.3.0.tgz\",\n          \"integrity\": \"sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"eslint-plugin-react-hooks\": {\n      \"version\": \"4.6.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-4.6.0.tgz\",\n      \"integrity\": \"sha512-oFc7Itz9Qxh2x4gNHStv3BqJq54ExXmfC+a1NjAta66IAN87Wu0R/QArgIS9qKzX3dXKPI9H5crl9QchNMY9+g==\",\n      \"dev\": true,\n      \"requires\": {}\n    },\n    \"eslint-scope\": {\n      \"version\": \"5.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz\",\n      \"integrity\": \"sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"esrecurse\": \"^4.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["396", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"esrecurse\": \"^4.3.0\",\n        \"estraverse\": \"^4.1.1\"\n      },\n      \"dependencies\": {\n        \"estraverse\": {\n          \"version\": \"4.3.0\",\n          \"resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz\",\n          \"integrity\": \"sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"eslint-utils\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz\",\n      \"integrity\": \"sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"eslint-visitor-keys\": \"^1.1.0\"\n      },\n      \"dependencies\": {\n        \"eslint-visitor-keys\": {\n          \"version\": \"1.3.0\",\n          \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["397", {"page_content": "\"integrity\": \"sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"eslint-visitor-keys\": {\n      \"version\": \"3.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.3.0.tgz\",\n      \"integrity\": \"sha512-mQ+suqKJVyeuwGYHAdjMFqjCyfl8+Ldnxuyp3ldiMBFKkvytrXUZWaiPCEav8qDHKty44bD+qV1IP4T+w+xXRA==\",\n      \"dev\": true\n    },\n    \"espree\": {\n      \"version\": \"7.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/espree/-/espree-7.3.1.tgz\",\n      \"integrity\": \"sha512-v3JCNCE64umkFpmkFGqzVKsOT0tN1Zr+ueqLZfpV1Ob8e+CEgPWa+OxCoGH3tnhimMKIaBm4m/vaRpJ/krRz2g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"acorn\": \"^7.4.0\",\n        \"acorn-jsx\": \"^5.3.1\",\n        \"eslint-visitor-keys\": \"^1.3.0\"\n      },\n      \"dependencies\": {\n        \"eslint-visitor-keys\": {\n          \"version\": \"1.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["398", {"page_content": "},\n      \"dependencies\": {\n        \"eslint-visitor-keys\": {\n          \"version\": \"1.3.0\",\n          \"resolved\": \"https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz\",\n          \"integrity\": \"sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"esprima\": {\n      \"version\": \"4.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz\",\n      \"integrity\": \"sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==\"\n    },\n    \"esquery\": {\n      \"version\": \"1.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/esquery/-/esquery-1.5.0.tgz\",\n      \"integrity\": \"sha512-YQLXUplAwJgCydQ78IMJywZCceoqk1oH01OERdSAJc/7U2AylwjhSCLDEtqwg811idIS/9fIU5GjG73IgjKMVg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"estraverse\": \"^5.1.0\"\n      }\n    },\n    \"esrecurse\": {\n      \"version\": \"4.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["399", {"page_content": "\"estraverse\": \"^5.1.0\"\n      }\n    },\n    \"esrecurse\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz\",\n      \"integrity\": \"sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==\",\n      \"dev\": true,\n      \"requires\": {\n        \"estraverse\": \"^5.2.0\"\n      }\n    },\n    \"estraverse\": {\n      \"version\": \"5.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz\",\n      \"integrity\": \"sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==\",\n      \"dev\": true\n    },\n    \"esutils\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz\",\n      \"integrity\": \"sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==\",\n      \"dev\": true\n    },\n    \"eventemitter3\": {\n      \"version\": \"4.0.7\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["400", {"page_content": "\"dev\": true\n    },\n    \"eventemitter3\": {\n      \"version\": \"4.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz\",\n      \"integrity\": \"sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==\"\n    },\n    \"eventsource-parser\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/eventsource-parser/-/eventsource-parser-0.1.0.tgz\",\n      \"integrity\": \"sha512-M9QjFtEIkwytUarnx113HGmgtk52LSn3jNAtnWKi3V+b9rqSfQeVdLsaD5AG/O4IrGQwmAAHBIsqbmURPTd2rA==\"\n    },\n    \"exponential-backoff\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/exponential-backoff/-/exponential-backoff-3.1.1.tgz\",\n      \"integrity\": \"sha512-dX7e/LHVJ6W3DE1MHWi9S1EYzDESENfLrYohG2G++ovZrYOkm4Knwa0mc1cn84xJOR4KEU0WSchhLbd0UklbHw==\"\n    },\n    \"expr-eval\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/expr-eval/-/expr-eval-2.0.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["401", {"page_content": "\"resolved\": \"https://registry.npmjs.org/expr-eval/-/expr-eval-2.0.2.tgz\",\n      \"integrity\": \"sha512-4EMSHGOPSwAfBiibw3ndnP0AvjDWLsMvGOvWEZ2F96IGk0bIVdjQisOHxReSkE13mHcfbuCiXw+G4y0zv6N8Eg==\"\n    },\n    \"external-editor\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/external-editor/-/external-editor-3.1.0.tgz\",\n      \"integrity\": \"sha512-hMQ4CX1p1izmuLYyZqLMO/qGNw10wSv9QDCPfzXfyFrOaCSSoRfqE1Kf1s5an66J5JZC62NewG+mK49jOCtQew==\",\n      \"requires\": {\n        \"chardet\": \"^0.7.0\",\n        \"iconv-lite\": \"^0.4.24\",\n        \"tmp\": \"^0.0.33\"\n      }\n    },\n    \"fast-deep-equal\": {\n      \"version\": \"3.1.3\",\n      \"resolved\": \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\",\n      \"integrity\": \"sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\",\n      \"dev\": true\n    },\n    \"fast-diff\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/fast-diff/-/fast-diff-1.2.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["402", {"page_content": "\"resolved\": \"https://registry.npmjs.org/fast-diff/-/fast-diff-1.2.0.tgz\",\n      \"integrity\": \"sha512-xJuoT5+L99XlZ8twedaRf6Ax2TgQVxvgZOYoPKqZufmJib0tL2tegPBOZb1pVNgIhlqDlA0eO0c3wBvQcmzx4w==\",\n      \"dev\": true\n    },\n    \"fast-glob\": {\n      \"version\": \"3.2.12\",\n      \"resolved\": \"https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.12.tgz\",\n      \"integrity\": \"sha512-DVj4CQIYYow0BlaelwK1pHl5n5cRSJfM60UA0zK891sVInoPri2Ekj7+e1CT3/3qxXenpI+nBBmQAcJPJgaj4w==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@nodelib/fs.stat\": \"^2.0.2\",\n        \"@nodelib/fs.walk\": \"^1.2.3\",\n        \"glob-parent\": \"^5.1.2\",\n        \"merge2\": \"^1.3.0\",\n        \"micromatch\": \"^4.0.4\"\n      }\n    },\n    \"fast-json-stable-stringify\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz\",\n      \"integrity\": \"sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["403", {"page_content": "\"dev\": true\n    },\n    \"fast-levenshtein\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz\",\n      \"integrity\": \"sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==\",\n      \"dev\": true\n    },\n    \"fastq\": {\n      \"version\": \"1.15.0\",\n      \"resolved\": \"https://registry.npmjs.org/fastq/-/fastq-1.15.0.tgz\",\n      \"integrity\": \"sha512-wBrocU2LCXXa+lWBt8RoIRD89Fi8OdABODa/kEnyeyjS5aZO5/GNvI5sEINADqP/h8M29UHTHUb53sUu5Ihqdw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"reusify\": \"^1.0.4\"\n      }\n    },\n    \"figures\": {\n      \"version\": \"5.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/figures/-/figures-5.0.0.tgz\",\n      \"integrity\": \"sha512-ej8ksPF4x6e5wvK9yevct0UCXh8TTFlWGVLlgjZuoBH1HwjIfKE/IdL5mq89sFA7zELi1VhKpmtDnrs7zWyeyg==\",\n      \"requires\": {\n        \"escape-string-regexp\": \"^5.0.0\",\n        \"is-unicode-supported\": \"^1.2.0\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["404", {"page_content": "\"escape-string-regexp\": \"^5.0.0\",\n        \"is-unicode-supported\": \"^1.2.0\"\n      },\n      \"dependencies\": {\n        \"escape-string-regexp\": {\n          \"version\": \"5.0.0\",\n          \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-5.0.0.tgz\",\n          \"integrity\": \"sha512-/veY75JbMK4j1yjvuUxuVsiS/hr/4iHs9FTT6cgTexxdE0Ly/glccBAkloH/DofkjRbZU3bnoj38mOmhkZ0lHw==\"\n        }\n      }\n    },\n    \"file-entry-cache\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz\",\n      \"integrity\": \"sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"flat-cache\": \"^3.0.4\"\n      }\n    },\n    \"file-uri-to-path\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["405", {"page_content": "\"resolved\": \"https://registry.npmjs.org/file-uri-to-path/-/file-uri-to-path-1.0.0.tgz\",\n      \"integrity\": \"sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==\"\n    },\n    \"fill-range\": {\n      \"version\": \"7.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz\",\n      \"integrity\": \"sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"to-regex-range\": \"^5.0.1\"\n      }\n    },\n    \"flat-cache\": {\n      \"version\": \"3.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz\",\n      \"integrity\": \"sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"flatted\": \"^3.1.0\",\n        \"rimraf\": \"^3.0.2\"\n      }\n    },\n    \"flatted\": {\n      \"version\": \"3.2.7\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["406", {"page_content": "\"rimraf\": \"^3.0.2\"\n      }\n    },\n    \"flatted\": {\n      \"version\": \"3.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/flatted/-/flatted-3.2.7.tgz\",\n      \"integrity\": \"sha512-5nqDSxl8nn5BSNxyR3n4I6eDmbolI6WT+QqR547RwxQapgjQBmtktdP+HTBb/a/zLsbzERTONyUB5pefh5TtjQ==\",\n      \"dev\": true\n    },\n    \"follow-redirects\": {\n      \"version\": \"1.15.2\",\n      \"resolved\": \"https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.2.tgz\",\n      \"integrity\": \"sha512-VQLG33o04KaQ8uYi2tVNbdrWp1QWxNNea+nmIB4EVM28v0hmP17z7aG1+wAkNzVq4KeXTq3221ye5qTJP91JwA==\"\n    },\n    \"for-each\": {\n      \"version\": \"0.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/for-each/-/for-each-0.3.3.tgz\",\n      \"integrity\": \"sha512-jqYfLp7mo9vIyQf8ykW2v7A+2N4QjeCeI5+Dz9XraiO1ign81wjiH7Fb9vSOWvQfNtmSa4H2RoQTrrXivdUZmw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"is-callable\": \"^1.1.3\"\n      }\n    },\n    \"form-data\": {\n      \"version\": \"4.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["407", {"page_content": "\"is-callable\": \"^1.1.3\"\n      }\n    },\n    \"form-data\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/form-data/-/form-data-4.0.0.tgz\",\n      \"integrity\": \"sha512-ETEklSGi5t0QMZuiXoA/Q6vcnxcLQP5vdugSpuAyi6SVGi2clPPp+xgEhuMaHC+zGgn31Kd235W35f7Hykkaww==\",\n      \"requires\": {\n        \"asynckit\": \"^0.4.0\",\n        \"combined-stream\": \"^1.0.8\",\n        \"mime-types\": \"^2.1.12\"\n      }\n    },\n    \"fs.realpath\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n      \"integrity\": \"sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==\",\n      \"dev\": true\n    },\n    \"function-bind\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz\",\n      \"integrity\": \"sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["408", {"page_content": "\"dev\": true\n    },\n    \"function.prototype.name\": {\n      \"version\": \"1.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/function.prototype.name/-/function.prototype.name-1.1.5.tgz\",\n      \"integrity\": \"sha512-uN7m/BzVKQnCUF/iW8jYea67v++2u7m5UgENbHRtdDVclOUP+FMPlCNdmk0h/ysGyo2tavMJEDqJAkJdRa1vMA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.3\",\n        \"es-abstract\": \"^1.19.0\",\n        \"functions-have-names\": \"^1.2.2\"\n      }\n    },\n    \"functional-red-black-tree\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz\",\n      \"integrity\": \"sha512-dsKNQNdj6xA3T+QlADDA7mOSlX0qiMINjn0cgr+eGHGsbSHzTabcIogz2+p/iqP1Xs6EP/sS2SbqH+brGTbq0g==\",\n      \"dev\": true\n    },\n    \"functions-have-names\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/functions-have-names/-/functions-have-names-1.2.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["409", {"page_content": "\"integrity\": \"sha512-xckBUXyTIqT97tq2x2AMb+g163b5JFysYk0x4qxNFwbfQkmNZoiRHb6sPzI9/QV33WeuvVYBUIiD4NzNIyqaRQ==\",\n      \"dev\": true\n    },\n    \"get-intrinsic\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.2.0.tgz\",\n      \"integrity\": \"sha512-L049y6nFOuom5wGyRc3/gdTLO94dySVKRACj1RmJZBQXlbTMhtNIgkWkUHq+jYmZvKf14EW1EoJnnjbmoHij0Q==\",\n      \"dev\": true,\n      \"requires\": {\n        \"function-bind\": \"^1.1.1\",\n        \"has\": \"^1.0.3\",\n        \"has-symbols\": \"^1.0.3\"\n      }\n    },\n    \"get-symbol-description\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-symbol-description/-/get-symbol-description-1.0.0.tgz\",\n      \"integrity\": \"sha512-2EmdH1YvIQiZpltCNgkuiUnyukzxM/R6NDJX31Ke3BG1Nq5b0S2PhX59UKi9vZpPDQVdqn+1IcaAwnzTT5vCjw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.1\"\n      }\n    },\n    \"get-tsconfig\": {\n      \"version\": \"4.4.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["410", {"page_content": "\"get-intrinsic\": \"^1.1.1\"\n      }\n    },\n    \"get-tsconfig\": {\n      \"version\": \"4.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.4.0.tgz\",\n      \"integrity\": \"sha512-0Gdjo/9+FzsYhXCEFueo2aY1z1tpXrxWZzP7k8ul9qt1U5o8rYJwTJYmaeHdrVosYIVYkOy2iwCJ9FdpocJhPQ==\",\n      \"dev\": true\n    },\n    \"glob\": {\n      \"version\": \"7.1.7\",\n      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.1.7.tgz\",\n      \"integrity\": \"sha512-OvD9ENzPLbegENnYP5UUfJIirTg4+XwMWGaQfQTY0JenxNvvIKP3U3/tAQSPIu/lHxXYSZmpXlUHeqAIdKzBLQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"fs.realpath\": \"^1.0.0\",\n        \"inflight\": \"^1.0.4\",\n        \"inherits\": \"2\",\n        \"minimatch\": \"^3.0.4\",\n        \"once\": \"^1.3.0\",\n        \"path-is-absolute\": \"^1.0.0\"\n      },\n      \"dependencies\": {\n        \"brace-expansion\": {\n          \"version\": \"1.1.11\",\n          \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["411", {"page_content": "\"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n          \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"balanced-match\": \"^1.0.0\",\n            \"concat-map\": \"0.0.1\"\n          }\n        },\n        \"minimatch\": {\n          \"version\": \"3.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n          \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n          \"dev\": true,\n          \"requires\": {\n            \"brace-expansion\": \"^1.1.7\"\n          }\n        }\n      }\n    },\n    \"glob-parent\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz\",\n      \"integrity\": \"sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["412", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"is-glob\": \"^4.0.1\"\n      }\n    },\n    \"globals\": {\n      \"version\": \"13.20.0\",\n      \"resolved\": \"https://registry.npmjs.org/globals/-/globals-13.20.0.tgz\",\n      \"integrity\": \"sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"type-fest\": \"^0.20.2\"\n      }\n    },\n    \"globalthis\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/globalthis/-/globalthis-1.0.3.tgz\",\n      \"integrity\": \"sha512-sFdI5LyBiNTHjRd7cGPWapiHWMOXKyuBNX/cWJ3NfzrZQVa8GI/8cofCl74AOVqq9W5kNmguTIzJ/1s2gyI9wA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"define-properties\": \"^1.1.3\"\n      }\n    },\n    \"globalyzer\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/globalyzer/-/globalyzer-0.1.0.tgz\",\n      \"integrity\": \"sha512-40oNTM9UfG6aBmuKxk/giHn5nQ8RVz/SS4Ir6zgzOv9/qC3kKZ9v4etGTcJbEl/NyVQH7FGU7d+X1egr57Md2Q==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["413", {"page_content": "\"dev\": true\n    },\n    \"globby\": {\n      \"version\": \"11.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/globby/-/globby-11.1.0.tgz\",\n      \"integrity\": \"sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"array-union\": \"^2.1.0\",\n        \"dir-glob\": \"^3.0.1\",\n        \"fast-glob\": \"^3.2.9\",\n        \"ignore\": \"^5.2.0\",\n        \"merge2\": \"^1.4.1\",\n        \"slash\": \"^3.0.0\"\n      }\n    },\n    \"globrex\": {\n      \"version\": \"0.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/globrex/-/globrex-0.1.2.tgz\",\n      \"integrity\": \"sha512-uHJgbwAMwNFf5mLst7IWLNg14x1CkeqglJb/K3doi4dw6q2IvAAmM/Y81kevy83wP+Sst+nutFTYOGg3d1lsxg==\",\n      \"dev\": true\n    },\n    \"gopd\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/gopd/-/gopd-1.0.1.tgz\",\n      \"integrity\": \"sha512-d65bNlIadxvpb/A2abVdlqKqV563juRnZ1Wtk6s1sIR8uNsXR70xqIzVqxVf1eTqDunwT2MkczEeaezCKTZhwA==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["414", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"get-intrinsic\": \"^1.1.3\"\n      }\n    },\n    \"gpt3-tokenizer\": {\n      \"version\": \"1.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/gpt3-tokenizer/-/gpt3-tokenizer-1.1.5.tgz\",\n      \"integrity\": \"sha512-O9iCL8MqGR0Oe9wTh0YftzIbysypNQmS5a5JG3cB3M4LMYjlAVvNnf8LUzVY9MrI7tj+YLY356uHtO2lLX2HpA==\",\n      \"requires\": {\n        \"array-keyed-map\": \"^2.1.3\"\n      }\n    },\n    \"graceful-fs\": {\n      \"version\": \"4.2.11\",\n      \"resolved\": \"https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz\",\n      \"integrity\": \"sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==\",\n      \"dev\": true\n    },\n    \"grapheme-splitter\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/grapheme-splitter/-/grapheme-splitter-1.0.4.tgz\",\n      \"integrity\": \"sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ==\",\n      \"dev\": true\n    },\n    \"has\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["415", {"page_content": "\"dev\": true\n    },\n    \"has\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/has/-/has-1.0.3.tgz\",\n      \"integrity\": \"sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"function-bind\": \"^1.1.1\"\n      }\n    },\n    \"has-bigints\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/has-bigints/-/has-bigints-1.0.2.tgz\",\n      \"integrity\": \"sha512-tSvCKtBr9lkF0Ex0aQiP9N+OpV4zi2r/Nee5VkRDbaqv35RLYMzbwQfFSZZH0kR+Rd6302UJZ2p/bJCEoR3VoQ==\",\n      \"dev\": true\n    },\n    \"has-flag\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz\",\n      \"integrity\": \"sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==\",\n      \"dev\": true\n    },\n    \"has-property-descriptors\": {\n      \"version\": \"1.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["416", {"page_content": "\"dev\": true\n    },\n    \"has-property-descriptors\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-property-descriptors/-/has-property-descriptors-1.0.0.tgz\",\n      \"integrity\": \"sha512-62DVLZGoiEBDHQyqG4w9xCuZ7eJEwNmJRWw2VY84Oedb7WFcA27fiEVe8oUQx9hAUJ4ekurquucTGwsyO1XGdQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"get-intrinsic\": \"^1.1.1\"\n      }\n    },\n    \"has-proto\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/has-proto/-/has-proto-1.0.1.tgz\",\n      \"integrity\": \"sha512-7qE+iP+O+bgF9clE5+UoBFzE65mlBiVj3tKCrlNQ0Ogwm0BjpT/gK4SlLYDMybDh5I3TCTKnPPa0oMG7JDYrhg==\",\n      \"dev\": true\n    },\n    \"has-symbols\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz\",\n      \"integrity\": \"sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==\",\n      \"dev\": true\n    },\n    \"has-tostringtag\": {\n      \"version\": \"1.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["417", {"page_content": "\"dev\": true\n    },\n    \"has-tostringtag\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.0.tgz\",\n      \"integrity\": \"sha512-kFjcSNhnlGV1kyoGk7OXKSawH5JOb/LzUc5w9B02hOTO0dfFRjbHQKvg1d6cf3HbeUmtU9VbbV3qzZ2Teh97WQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-symbols\": \"^1.0.2\"\n      }\n    },\n    \"hnswlib-node\": {\n      \"version\": \"1.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/hnswlib-node/-/hnswlib-node-1.4.2.tgz\",\n      \"integrity\": \"sha512-76PIzOaNcX8kOpKwlFPl07uelpctqDMzbiC+Qsk2JWNVkzeU/6iXRk4tfE9z3DoK1RCBrOaFXmQ6RFb1BVF9LA==\",\n      \"requires\": {\n        \"bindings\": \"^1.5.0\",\n        \"node-addon-api\": \"^6.0.0\"\n      }\n    },\n    \"iconv-lite\": {\n      \"version\": \"0.4.24\",\n      \"resolved\": \"https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz\",\n      \"integrity\": \"sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==\",\n      \"requires\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["418", {"page_content": "\"requires\": {\n        \"safer-buffer\": \">= 2.1.2 < 3\"\n      }\n    },\n    \"ieee754\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz\",\n      \"integrity\": \"sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==\"\n    },\n    \"ignore\": {\n      \"version\": \"5.2.4\",\n      \"resolved\": \"https://registry.npmjs.org/ignore/-/ignore-5.2.4.tgz\",\n      \"integrity\": \"sha512-MAb38BcSbH0eHNBxn7ql2NH/kX33OkB3lZ1BNdh7ENeRChHTYsTvWrMubiIAMNS2llXEEgZ1MUOBtXChP3kaFQ==\",\n      \"dev\": true\n    },\n    \"import-fresh\": {\n      \"version\": \"3.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz\",\n      \"integrity\": \"sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"parent-module\": \"^1.0.0\",\n        \"resolve-from\": \"^4.0.0\"\n      }\n    },\n    \"imurmurhash\": {\n      \"version\": \"0.1.4\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["419", {"page_content": "\"resolve-from\": \"^4.0.0\"\n      }\n    },\n    \"imurmurhash\": {\n      \"version\": \"0.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz\",\n      \"integrity\": \"sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==\",\n      \"dev\": true\n    },\n    \"inflight\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n      \"integrity\": \"sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"once\": \"^1.3.0\",\n        \"wrappy\": \"1\"\n      }\n    },\n    \"inherits\": {\n      \"version\": \"2.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\"\n    },\n    \"inquirer\": {\n      \"version\": \"9.1.5\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["420", {"page_content": "},\n    \"inquirer\": {\n      \"version\": \"9.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/inquirer/-/inquirer-9.1.5.tgz\",\n      \"integrity\": \"sha512-3ygAIh8gcZavV9bj6MTdYddG2zPSYswP808fKS46NOwlF0zZljVpnLCHODDqItWJDbDpLb3aouAxGaJbkxoppA==\",\n      \"requires\": {\n        \"ansi-escapes\": \"^6.0.0\",\n        \"chalk\": \"^5.2.0\",\n        \"cli-cursor\": \"^4.0.0\",\n        \"cli-width\": \"^4.0.0\",\n        \"external-editor\": \"^3.0.3\",\n        \"figures\": \"^5.0.0\",\n        \"lodash\": \"^4.17.21\",\n        \"mute-stream\": \"1.0.0\",\n        \"ora\": \"^6.1.2\",\n        \"run-async\": \"^2.4.0\",\n        \"rxjs\": \"^7.8.0\",\n        \"string-width\": \"^5.1.2\",\n        \"strip-ansi\": \"^7.0.1\",\n        \"through\": \"^2.3.6\",\n        \"wrap-ansi\": \"^8.1.0\"\n      },\n      \"dependencies\": {\n        \"ansi-regex\": {\n          \"version\": \"6.0.1\",\n          \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["421", {"page_content": "\"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz\",\n          \"integrity\": \"sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==\"\n        },\n        \"string-width\": {\n          \"version\": \"5.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz\",\n          \"integrity\": \"sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==\",\n          \"requires\": {\n            \"eastasianwidth\": \"^0.2.0\",\n            \"emoji-regex\": \"^9.2.2\",\n            \"strip-ansi\": \"^7.0.1\"\n          }\n        },\n        \"strip-ansi\": {\n          \"version\": \"7.0.1\",\n          \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz\",\n          \"integrity\": \"sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==\",\n          \"requires\": {\n            \"ansi-regex\": \"^6.0.1\"\n          }\n        }\n      }", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["422", {"page_content": "\"requires\": {\n            \"ansi-regex\": \"^6.0.1\"\n          }\n        }\n      }\n    },\n    \"internal-slot\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/internal-slot/-/internal-slot-1.0.5.tgz\",\n      \"integrity\": \"sha512-Y+R5hJrzs52QCG2laLn4udYVnxsfny9CpOhNhUvk/SSSVyF6T27FzRbF0sroPidSu3X8oEAkOn2K804mjpt6UQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"get-intrinsic\": \"^1.2.0\",\n        \"has\": \"^1.0.3\",\n        \"side-channel\": \"^1.0.4\"\n      }\n    },\n    \"is-arguments\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-arguments/-/is-arguments-1.1.1.tgz\",\n      \"integrity\": \"sha512-8Q7EARjzEnKpt/PCD7e1cgUS0a6X8u5tdSiMqXhojOdoV9TsMsiO+9VLC5vAmO8N7/GmXn7yjR8qnA6bVAEzfA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-array-buffer\": {\n      \"version\": \"3.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["423", {"page_content": "}\n    },\n    \"is-array-buffer\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-array-buffer/-/is-array-buffer-3.0.2.tgz\",\n      \"integrity\": \"sha512-y+FyyR/w8vfIRq4eQcM1EYgSTnmHXPqaF+IgzgraytCFq5Xh8lllDVmAZolPJiZttZLeFSINPYMaEJ7/vWUa1w==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.2.0\",\n        \"is-typed-array\": \"^1.1.10\"\n      }\n    },\n    \"is-bigint\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/is-bigint/-/is-bigint-1.0.4.tgz\",\n      \"integrity\": \"sha512-zB9CruMamjym81i2JZ3UMn54PKGsQzsJeo6xvN3HJJ4CAsQNB6iRutp2To77OfCNuoxspsIhzaPoO1zyCEhFOg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-bigints\": \"^1.0.1\"\n      }\n    },\n    \"is-binary-path\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["424", {"page_content": "\"resolved\": \"https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz\",\n      \"integrity\": \"sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==\",\n      \"requires\": {\n        \"binary-extensions\": \"^2.0.0\"\n      }\n    },\n    \"is-boolean-object\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-boolean-object/-/is-boolean-object-1.1.2.tgz\",\n      \"integrity\": \"sha512-gDYaKHJmnj4aWxyj6YHyXVpdQawtVLHU5cb+eztPGczf6cjuTdwve5ZIEfgXqH4e57An1D1AKf8CZ3kYrQRqYA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-callable\": {\n      \"version\": \"1.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/is-callable/-/is-callable-1.2.7.tgz\",\n      \"integrity\": \"sha512-1BC0BVFhS/p0qtw6enp8e+8OD0UrK0oFLztSjNzhcKA3WDuJxxAPXzPuPtKkjEY9UUoEWlX/8fgKeu2S8i9JTA==\",\n      \"dev\": true\n    },\n    \"is-core-module\": {\n      \"version\": \"2.11.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["425", {"page_content": "\"dev\": true\n    },\n    \"is-core-module\": {\n      \"version\": \"2.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-core-module/-/is-core-module-2.11.0.tgz\",\n      \"integrity\": \"sha512-RRjxlvLDkD1YJwDbroBHMb+cukurkDWNyHx7D3oNB5x9rb5ogcksMC5wHCadcXoo67gVr/+3GFySh3134zi6rw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has\": \"^1.0.3\"\n      }\n    },\n    \"is-date-object\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/is-date-object/-/is-date-object-1.0.5.tgz\",\n      \"integrity\": \"sha512-9YQaSxsAiSwcvS33MBk3wTCVnWK+HhF8VZR2jRxehM16QcVOdHqPn4VPHmRK4lSr38n9JriurInLcP90xsYNfQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-docker\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-docker/-/is-docker-2.2.1.tgz\",\n      \"integrity\": \"sha512-F+i2BKsFrH66iaUFc0woD8sLy8getkwTwtOBjvs56Cx4CgJDeKQeqfz8wAYiSb8JOprWhHH5p77PbmYCvvUuXQ==\",\n      \"dev\": true\n    },\n    \"is-extglob\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["426", {"page_content": "\"dev\": true\n    },\n    \"is-extglob\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz\",\n      \"integrity\": \"sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==\",\n      \"dev\": true\n    },\n    \"is-fullwidth-code-point\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz\",\n      \"integrity\": \"sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==\"\n    },\n    \"is-glob\": {\n      \"version\": \"4.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz\",\n      \"integrity\": \"sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"is-extglob\": \"^2.1.1\"\n      }\n    },\n    \"is-interactive\": {\n      \"version\": \"2.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["427", {"page_content": "\"is-extglob\": \"^2.1.1\"\n      }\n    },\n    \"is-interactive\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-interactive/-/is-interactive-2.0.0.tgz\",\n      \"integrity\": \"sha512-qP1vozQRI+BMOPcjFzrjXuQvdak2pHNUMZoeG2eRbiSqyvbEf/wQtEOTOX1guk6E3t36RkaqiSt8A/6YElNxLQ==\"\n    },\n    \"is-map\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-map/-/is-map-2.0.2.tgz\",\n      \"integrity\": \"sha512-cOZFQQozTha1f4MxLFzlgKYPTyj26picdZTx82hbc/Xf4K/tZOOXSCkMvU4pKioRXGDLJRn0GM7Upe7kR721yg==\",\n      \"dev\": true\n    },\n    \"is-negative-zero\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-negative-zero/-/is-negative-zero-2.0.2.tgz\",\n      \"integrity\": \"sha512-dqJvarLawXsFbNDeJW7zAz8ItJ9cd28YufuuFzh0G8pNHjJMnY08Dv7sYX2uF5UpQOwieAeOExEYAWWfu7ZZUA==\",\n      \"dev\": true\n    },\n    \"is-number\": {\n      \"version\": \"7.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["428", {"page_content": "\"resolved\": \"https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz\",\n      \"integrity\": \"sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==\",\n      \"dev\": true\n    },\n    \"is-number-object\": {\n      \"version\": \"1.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/is-number-object/-/is-number-object-1.0.7.tgz\",\n      \"integrity\": \"sha512-k1U0IRzLMo7ZlYIfzRu23Oh6MiIFasgpb9X76eqfFZAqwH44UI4KTBvBYIZ1dSL9ZzChTB9ShHfLkR4pdW5krQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-regex\": {\n      \"version\": \"1.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/is-regex/-/is-regex-1.1.4.tgz\",\n      \"integrity\": \"sha512-kvRdxDsxZjhzUX07ZnLydzS1TU/TJlTUHHY4YLL87e37oUA49DfkLqgy+VjFocowy29cKvcSiu+kIv728jTTVg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-set\": {\n      \"version\": \"2.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["429", {"page_content": "\"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-set\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-set/-/is-set-2.0.2.tgz\",\n      \"integrity\": \"sha512-+2cnTEZeY5z/iXGbLhPrOAaK/Mau5k5eXq9j14CpRTftq0pAJu2MwVRSZhyZWBzx3o6X795Lz6Bpb6R0GKf37g==\",\n      \"dev\": true\n    },\n    \"is-shared-array-buffer\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-shared-array-buffer/-/is-shared-array-buffer-1.0.2.tgz\",\n      \"integrity\": \"sha512-sqN2UDu1/0y6uvXyStCOzyhAjCSlHceFoMKJW8W9EU9cvic/QdsZ0kEU93HEy3IUEFZIiH/3w+AH/UQbPHNdhA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\"\n      }\n    },\n    \"is-string\": {\n      \"version\": \"1.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/is-string/-/is-string-1.0.7.tgz\",\n      \"integrity\": \"sha512-tE2UXzivje6ofPW7l23cjDOMa09gb7xlAqG6jG5ej6uPV32TlWP3NKPigtaGeHNu9fohccRYvIiZMfOOnOYUtg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-tostringtag\": \"^1.0.0\"", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["430", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-symbol\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/is-symbol/-/is-symbol-1.0.4.tgz\",\n      \"integrity\": \"sha512-C/CPBqKWnvdcxqIARxyOh4v1UUEOCHpgDa0WYgpKDFMszcrPcffg5uhwSgPCLD2WWxmq6isisz87tzT01tuGhg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-symbols\": \"^1.0.2\"\n      }\n    },\n    \"is-typed-array\": {\n      \"version\": \"1.1.10\",\n      \"resolved\": \"https://registry.npmjs.org/is-typed-array/-/is-typed-array-1.1.10.tgz\",\n      \"integrity\": \"sha512-PJqgEHiWZvMpaFZ3uTc8kHPM4+4ADTlDniuQL7cU/UDA0Ql7F70yGfHph3cLNe+c9toaigv+DFzTJKhc2CtO6A==\",\n      \"dev\": true,\n      \"requires\": {\n        \"available-typed-arrays\": \"^1.0.5\",\n        \"call-bind\": \"^1.0.2\",\n        \"for-each\": \"^0.3.3\",\n        \"gopd\": \"^1.0.1\",\n        \"has-tostringtag\": \"^1.0.0\"\n      }\n    },\n    \"is-unicode-supported\": {\n      \"version\": \"1.3.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["431", {"page_content": "}\n    },\n    \"is-unicode-supported\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-1.3.0.tgz\",\n      \"integrity\": \"sha512-43r2mRvz+8JRIKnWJ+3j8JtjRKZ6GmjzfaE/qiBJnikNnYv/6bagRJ1kUhNk8R5EX/GkobD+r+sfxCPJsiKBLQ==\"\n    },\n    \"is-weakmap\": {\n      \"version\": \"2.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/is-weakmap/-/is-weakmap-2.0.1.tgz\",\n      \"integrity\": \"sha512-NSBR4kH5oVj1Uwvv970ruUkCV7O1mzgVFO4/rev2cLRda9Tm9HrL70ZPut4rOHgY0FNrUu9BCbXA2sdQ+x0chA==\",\n      \"dev\": true\n    },\n    \"is-weakref\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-weakref/-/is-weakref-1.0.2.tgz\",\n      \"integrity\": \"sha512-qctsuLZmIQ0+vSSMfoVvyFe2+GSEvnmZ2ezTup1SBse9+twCCeial6EEi3Nc2KFcf6+qz2FBPnjXsk8xhKSaPQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\"\n      }\n    },\n    \"is-weakset\": {\n      \"version\": \"2.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["432", {"page_content": "\"call-bind\": \"^1.0.2\"\n      }\n    },\n    \"is-weakset\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/is-weakset/-/is-weakset-2.0.2.tgz\",\n      \"integrity\": \"sha512-t2yVvttHkQktwnNNmBQ98AhENLdPUTDTE21uPqAQ0ARwQfGeQKRVS0NNurH7bTf7RrvcVn1OOge45CnBeHCSmg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.1\"\n      }\n    },\n    \"is-wsl\": {\n      \"version\": \"2.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/is-wsl/-/is-wsl-2.2.0.tgz\",\n      \"integrity\": \"sha512-fKzAra0rGJUUBwGBgNkHZuToZcn+TtXHpeCgmkMJMMYx1sQDYaCSyjJBSCa2nH1DGm7s3n1oBnohoVTBaN7Lww==\",\n      \"dev\": true,\n      \"requires\": {\n        \"is-docker\": \"^2.0.0\"\n      }\n    },\n    \"isarray\": {\n      \"version\": \"2.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/isarray/-/isarray-2.0.5.tgz\",\n      \"integrity\": \"sha512-xHjhDr3cNBK0BzdUJSPXZntQUx/mwMS5Rw4A7lPJ90XGAO6ISP/ePDNuo0vhqOZU+UD5JoodwCAAoZQd3FeAKw==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["433", {"page_content": "\"dev\": true\n    },\n    \"isexe\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\",\n      \"integrity\": \"sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==\",\n      \"dev\": true\n    },\n    \"istextorbinary\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/istextorbinary/-/istextorbinary-6.0.0.tgz\",\n      \"integrity\": \"sha512-4j3UqQCa06GAf6QHlN3giz2EeFU7qc6Q5uB/aY7Gmb3xmLDLepDOtsZqkb4sCfJgFvTbLUinNw0kHgHs8XOHoQ==\",\n      \"requires\": {\n        \"binaryextensions\": \"^4.18.0\",\n        \"textextensions\": \"^5.14.0\"\n      }\n    },\n    \"js-tokens\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz\",\n      \"integrity\": \"sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\",\n      \"dev\": true\n    },\n    \"js-yaml\": {\n      \"version\": \"3.14.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["434", {"page_content": "\"dev\": true\n    },\n    \"js-yaml\": {\n      \"version\": \"3.14.1\",\n      \"resolved\": \"https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz\",\n      \"integrity\": \"sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"argparse\": \"^1.0.7\",\n        \"esprima\": \"^4.0.0\"\n      }\n    },\n    \"json-schema-traverse\": {\n      \"version\": \"0.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz\",\n      \"integrity\": \"sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==\",\n      \"dev\": true\n    },\n    \"json-stable-stringify-without-jsonify\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["435", {"page_content": "\"integrity\": \"sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==\",\n      \"dev\": true\n    },\n    \"json5\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/json5/-/json5-1.0.2.tgz\",\n      \"integrity\": \"sha512-g1MWMLBiz8FKi1e4w0UyVL3w+iJceWAFBAaBnnGKOpNa5f8TLktkbre1+s6oICydWAm+HRUGTmI+//xv2hvXYA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"minimist\": \"^1.2.0\"\n      }\n    },\n    \"jsonpointer\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/jsonpointer/-/jsonpointer-5.0.1.tgz\",\n      \"integrity\": \"sha512-p/nXbhSEcu3pZRdkW1OfJhpsVtW1gd4Wa1fnQc9YLiTfAjn0312eMKimbdIQzuZl9aa9xUGaRlP9T/CJE/ditQ==\"\n    },\n    \"jsx-ast-utils\": {\n      \"version\": \"3.3.3\",\n      \"resolved\": \"https://registry.npmjs.org/jsx-ast-utils/-/jsx-ast-utils-3.3.3.tgz\",\n      \"integrity\": \"sha512-fYQHZTZ8jSfmWZ0iyzfwiU4WDX4HpHbMCZ3gPlWYiCl3BoeOTsqKBqnTVfH2rYT7eP5c3sVbeSPHnnJOaTrWiw==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["436", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"array-includes\": \"^3.1.5\",\n        \"object.assign\": \"^4.1.3\"\n      }\n    },\n    \"langchain\": {\n      \"version\": \"0.0.39\",\n      \"resolved\": \"https://registry.npmjs.org/langchain/-/langchain-0.0.39.tgz\",\n      \"integrity\": \"sha512-vBdCHYWtP05j6/trnVKZ+tic6oF2GOJKnCtm4/cxgHrdAkxq2eQ3dju4eYuXI4jIVyeGYsFCg3R7t2P8mdv1eg==\",\n      \"requires\": {\n        \"browser-or-node\": \"^2.1.1\",\n        \"eventsource-parser\": \"^0.1.0\",\n        \"exponential-backoff\": \"^3.1.0\",\n        \"expr-eval\": \"^2.0.2\",\n        \"gpt3-tokenizer\": \"^1.1.5\",\n        \"is-binary-path\": \"^2.1.0\",\n        \"jsonpointer\": \"^5.0.1\",\n        \"object-hash\": \"^3.0.0\",\n        \"openai\": \"^3.2.0\",\n        \"p-queue\": \"^7.3.4\",\n        \"uuid\": \"^9.0.0\",\n        \"yaml\": \"^2.2.1\",\n        \"zod\": \"^3.21.4\"\n      }\n    },\n    \"language-subtag-registry\": {\n      \"version\": \"0.3.22\",\n      \"resolved\": \"https://registry.npmjs.org/language-subtag-registry/-/language-subtag-registry-0.3.22.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["437", {"page_content": "\"integrity\": \"sha512-tN0MCzyWnoz/4nHS6uxdlFWoUZT7ABptwKPQ52Ea7URk6vll88bWBVhodtnlfEuCcKWNGoc+uGbw1cwa9IKh/w==\",\n      \"dev\": true\n    },\n    \"language-tags\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/language-tags/-/language-tags-1.0.5.tgz\",\n      \"integrity\": \"sha512-qJhlO9cGXi6hBGKoxEG/sKZDAHD5Hnu9Hs4WbOY3pCWXDhw0N8x1NenNzm2EnNLkLkk7J2SdxAkDSbb6ftT+UQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"language-subtag-registry\": \"~0.3.2\"\n      }\n    },\n    \"levn\": {\n      \"version\": \"0.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/levn/-/levn-0.4.1.tgz\",\n      \"integrity\": \"sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"prelude-ls\": \"^1.2.1\",\n        \"type-check\": \"~0.4.0\"\n      }\n    },\n    \"lodash\": {\n      \"version\": \"4.17.21\",\n      \"resolved\": \"https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["438", {"page_content": "\"resolved\": \"https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz\",\n      \"integrity\": \"sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==\"\n    },\n    \"lodash.merge\": {\n      \"version\": \"4.6.2\",\n      \"resolved\": \"https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz\",\n      \"integrity\": \"sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==\",\n      \"dev\": true\n    },\n    \"lodash.truncate\": {\n      \"version\": \"4.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/lodash.truncate/-/lodash.truncate-4.4.2.tgz\",\n      \"integrity\": \"sha512-jttmRe7bRse52OsWIMDLaXxWqRAmtIUccAQ3garviCqJjafXOfNMO0yMfNpdD6zbGaTU0P5Nz7e7gAT6cKmJRw==\",\n      \"dev\": true\n    },\n    \"log-symbols\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/log-symbols/-/log-symbols-5.1.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["439", {"page_content": "\"resolved\": \"https://registry.npmjs.org/log-symbols/-/log-symbols-5.1.0.tgz\",\n      \"integrity\": \"sha512-l0x2DvrW294C9uDCoQe1VSU4gf529FkSZ6leBl4TiqZH/e+0R7hSfHQBNut2mNygDgHwvYHfFLn6Oxb3VWj2rA==\",\n      \"requires\": {\n        \"chalk\": \"^5.0.0\",\n        \"is-unicode-supported\": \"^1.1.0\"\n      }\n    },\n    \"loose-envify\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz\",\n      \"integrity\": \"sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==\",\n      \"dev\": true,\n      \"requires\": {\n        \"js-tokens\": \"^3.0.0 || ^4.0.0\"\n      }\n    },\n    \"lru-cache\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz\",\n      \"integrity\": \"sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"yallist\": \"^4.0.0\"\n      }\n    },\n    \"marked\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["440", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"yallist\": \"^4.0.0\"\n      }\n    },\n    \"marked\": {\n      \"version\": \"4.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/marked/-/marked-4.3.0.tgz\",\n      \"integrity\": \"sha512-PRsaiG84bK+AMvxziE/lCFss8juXjNaWzVbN5tXAm4XjeaS9NAHhop+PjQxz2A9h8Q4M/xGmzP8vqNwy6JeK0A==\"\n    },\n    \"marked-terminal\": {\n      \"version\": \"5.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/marked-terminal/-/marked-terminal-5.1.1.tgz\",\n      \"integrity\": \"sha512-+cKTOx9P4l7HwINYhzbrBSyzgxO2HaHKGZGuB1orZsMIgXYaJyfidT81VXRdpelW/PcHEWxywscePVgI/oUF6g==\",\n      \"requires\": {\n        \"ansi-escapes\": \"^5.0.0\",\n        \"cardinal\": \"^2.1.1\",\n        \"chalk\": \"^5.0.0\",\n        \"cli-table3\": \"^0.6.1\",\n        \"node-emoji\": \"^1.11.0\",\n        \"supports-hyperlinks\": \"^2.2.0\"\n      },\n      \"dependencies\": {\n        \"ansi-escapes\": {\n          \"version\": \"5.0.0\",\n          \"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-5.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["441", {"page_content": "\"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-5.0.0.tgz\",\n          \"integrity\": \"sha512-5GFMVX8HqE/TB+FuBJGuO5XG0WrsA6ptUqoODaT/n9mmUaZFkqnBueB4leqGBCmrUHnCnC4PCZTCd0E7QQ83bA==\",\n          \"requires\": {\n            \"type-fest\": \"^1.0.2\"\n          }\n        },\n        \"type-fest\": {\n          \"version\": \"1.4.0\",\n          \"resolved\": \"https://registry.npmjs.org/type-fest/-/type-fest-1.4.0.tgz\",\n          \"integrity\": \"sha512-yGSza74xk0UG8k+pLh5oeoYirvIiWo5t0/o3zHHAO2tRDiZcxWP7fywNlXhqb6/r6sWvwi+RsyQMWhVLe4BVuA==\"\n        }\n      }\n    },\n    \"merge2\": {\n      \"version\": \"1.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz\",\n      \"integrity\": \"sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==\",\n      \"dev\": true\n    },\n    \"micromatch\": {\n      \"version\": \"4.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["442", {"page_content": "\"resolved\": \"https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz\",\n      \"integrity\": \"sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"braces\": \"^3.0.2\",\n        \"picomatch\": \"^2.3.1\"\n      }\n    },\n    \"mime-db\": {\n      \"version\": \"1.52.0\",\n      \"resolved\": \"https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz\",\n      \"integrity\": \"sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==\"\n    },\n    \"mime-types\": {\n      \"version\": \"2.1.35\",\n      \"resolved\": \"https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz\",\n      \"integrity\": \"sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==\",\n      \"requires\": {\n        \"mime-db\": \"1.52.0\"\n      }\n    },\n    \"mimic-fn\": {\n      \"version\": \"2.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["443", {"page_content": "\"resolved\": \"https://registry.npmjs.org/mimic-fn/-/mimic-fn-2.1.0.tgz\",\n      \"integrity\": \"sha512-OqbOk5oEQeAZ8WXWydlu9HJjz9WVdEIvamMCcXmuqUYjTknH/sqsWvhQ3vgwKFRR1HpjvNBKQ37nbJgYzGqGcg==\"\n    },\n    \"minimatch\": {\n      \"version\": \"7.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-7.4.3.tgz\",\n      \"integrity\": \"sha512-5UB4yYusDtkRPbRiy1cqZ1IpGNcJCGlEMG17RKzPddpyiPKoCdwohbED8g4QXT0ewCt8LTkQXuljsUfQ3FKM4A==\",\n      \"requires\": {\n        \"brace-expansion\": \"^2.0.1\"\n      }\n    },\n    \"minimist\": {\n      \"version\": \"1.2.8\",\n      \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz\",\n      \"integrity\": \"sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==\",\n      \"dev\": true\n    },\n    \"ms\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["444", {"page_content": "\"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\",\n      \"integrity\": \"sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==\",\n      \"dev\": true\n    },\n    \"mute-stream\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/mute-stream/-/mute-stream-1.0.0.tgz\",\n      \"integrity\": \"sha512-avsJQhyd+680gKXyG/sQc0nXaC6rBkPOfyHYcFb9+hdkqQkR9bdnkJ0AMZhke0oesPqIO+mFFJ+IdBc7mst4IA==\"\n    },\n    \"natural-compare\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz\",\n      \"integrity\": \"sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==\",\n      \"dev\": true\n    },\n    \"natural-compare-lite\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/natural-compare-lite/-/natural-compare-lite-1.4.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["445", {"page_content": "\"integrity\": \"sha512-Tj+HTDSJJKaZnfiuw+iaF9skdPpTo2GtEly5JHnWV/hfv2Qj/9RKsGISQtLh2ox3l5EAGw487hnBee0sIJ6v2g==\",\n      \"dev\": true\n    },\n    \"node-addon-api\": {\n      \"version\": \"6.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/node-addon-api/-/node-addon-api-6.0.0.tgz\",\n      \"integrity\": \"sha512-GyHvgPvUXBvAkXa0YvYnhilSB1A+FRYMpIVggKzPZqdaZfevZOuzfWzyvgzOwRLHBeo/MMswmJFsrNF4Nw1pmA==\"\n    },\n    \"node-emoji\": {\n      \"version\": \"1.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/node-emoji/-/node-emoji-1.11.0.tgz\",\n      \"integrity\": \"sha512-wo2DpQkQp7Sjm2A0cq+sN7EHKO6Sl0ctXeBdFZrL9T9+UywORbufTcTZxom8YqpLQt/FqNMUkOpkZrJVYSKD3A==\",\n      \"requires\": {\n        \"lodash\": \"^4.17.21\"\n      }\n    },\n    \"object-assign\": {\n      \"version\": \"4.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz\",\n      \"integrity\": \"sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["446", {"page_content": "\"dev\": true\n    },\n    \"object-hash\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/object-hash/-/object-hash-3.0.0.tgz\",\n      \"integrity\": \"sha512-RSn9F68PjH9HqtltsSnqYC1XXoWe9Bju5+213R98cNGttag9q9yAOTzdbsqvIa7aNm5WffBZFpWYr2aWrklWAw==\"\n    },\n    \"object-inspect\": {\n      \"version\": \"1.12.3\",\n      \"resolved\": \"https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.3.tgz\",\n      \"integrity\": \"sha512-geUvdk7c+eizMNUDkRpW1wJwgfOiOeHbxBR/hLXK1aT6zmVSO0jsQcs7fj6MGw89jC/cjGfLcNOrtMYtGqm81g==\",\n      \"dev\": true\n    },\n    \"object-is\": {\n      \"version\": \"1.1.5\",\n      \"resolved\": \"https://registry.npmjs.org/object-is/-/object-is-1.1.5.tgz\",\n      \"integrity\": \"sha512-3cyDsyHgtmi7I7DfSSI2LDp6SK2lwvtbg0p0R1e0RvTqF5ceGx+K2dfSjm1bKDMVCFEDAQvy+o8c6a7VujOddw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.3\"\n      }\n    },\n    \"object-keys\": {\n      \"version\": \"1.1.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["447", {"page_content": "\"define-properties\": \"^1.1.3\"\n      }\n    },\n    \"object-keys\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/object-keys/-/object-keys-1.1.1.tgz\",\n      \"integrity\": \"sha512-NuAESUOUMrlIXOfHKzD6bpPu3tYt3xvjNdRIQ+FeT0lNb4K8WR70CaDxhuNguS2XG+GjkyMwOzsN5ZktImfhLA==\",\n      \"dev\": true\n    },\n    \"object.assign\": {\n      \"version\": \"4.1.4\",\n      \"resolved\": \"https://registry.npmjs.org/object.assign/-/object.assign-4.1.4.tgz\",\n      \"integrity\": \"sha512-1mxKf0e58bvyjSCtKYY4sRe9itRk3PJpquJOjeIkz885CczcI4IvJJDLPS72oowuSh+pBxUFROpX+TU++hxhZQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"has-symbols\": \"^1.0.3\",\n        \"object-keys\": \"^1.1.1\"\n      }\n    },\n    \"object.entries\": {\n      \"version\": \"1.1.6\",\n      \"resolved\": \"https://registry.npmjs.org/object.entries/-/object.entries-1.1.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["448", {"page_content": "\"resolved\": \"https://registry.npmjs.org/object.entries/-/object.entries-1.1.6.tgz\",\n      \"integrity\": \"sha512-leTPzo4Zvg3pmbQ3rDK69Rl8GQvIqMWubrkxONG9/ojtFE2rD9fjMKfSI5BxW3osRH1m6VdzmqK8oAY9aT4x5w==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      }\n    },\n    \"object.fromentries\": {\n      \"version\": \"2.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/object.fromentries/-/object.fromentries-2.0.6.tgz\",\n      \"integrity\": \"sha512-VciD13dswC4j1Xt5394WR4MzmAQmlgN72phd/riNp9vtD7tp4QQWJ0R4wvclXcafgcYK8veHRed2W6XeGBvcfg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      }\n    },\n    \"object.hasown\": {\n      \"version\": \"1.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/object.hasown/-/object.hasown-1.1.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["449", {"page_content": "\"resolved\": \"https://registry.npmjs.org/object.hasown/-/object.hasown-1.1.2.tgz\",\n      \"integrity\": \"sha512-B5UIT3J1W+WuWIU55h0mjlwaqxiE5vYENJXIXZ4VFe05pNYrkKuK0U/6aFcb0pKywYJh7IhfoqUfKVmrJJHZHw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      }\n    },\n    \"object.values\": {\n      \"version\": \"1.1.6\",\n      \"resolved\": \"https://registry.npmjs.org/object.values/-/object.values-1.1.6.tgz\",\n      \"integrity\": \"sha512-FVVTkD1vENCsAcwNs9k6jea2uHC/X0+JcjG8YA60FN5CMaJmG95wT9jek/xX9nornqGRrBkKtzuAu2wuHpKqvw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      }\n    },\n    \"once\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n      \"integrity\": \"sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["450", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"wrappy\": \"1\"\n      }\n    },\n    \"onetime\": {\n      \"version\": \"5.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/onetime/-/onetime-5.1.2.tgz\",\n      \"integrity\": \"sha512-kbpaSSGJTWdAY5KPVeMOKXSrPtr8C8C7wodJbcsd51jRnmD+GZu8Y0VoU6Dm5Z4vWr0Ig/1NKuWRKf7j5aaYSg==\",\n      \"requires\": {\n        \"mimic-fn\": \"^2.1.0\"\n      }\n    },\n    \"open\": {\n      \"version\": \"8.4.2\",\n      \"resolved\": \"https://registry.npmjs.org/open/-/open-8.4.2.tgz\",\n      \"integrity\": \"sha512-7x81NCL719oNbsq/3mh+hVrAWmFuEYUqrq/Iw3kUzH8ReypT9QQ0BLoJS7/G9k6N81XjW4qHWtjWwe/9eLy1EQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"define-lazy-prop\": \"^2.0.0\",\n        \"is-docker\": \"^2.1.1\",\n        \"is-wsl\": \"^2.2.0\"\n      }\n    },\n    \"openai\": {\n      \"version\": \"3.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/openai/-/openai-3.2.1.tgz\",\n      \"integrity\": \"sha512-762C9BNlJPbjjlWZi4WYK9iM2tAVAv0uUp1UmI34vb0CN5T2mjB/qM6RYBmNKMh/dN9fC+bxqPwWJZUTWW052A==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["451", {"page_content": "\"requires\": {\n        \"axios\": \"^0.26.0\",\n        \"form-data\": \"^4.0.0\"\n      }\n    },\n    \"optionator\": {\n      \"version\": \"0.9.1\",\n      \"resolved\": \"https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz\",\n      \"integrity\": \"sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"deep-is\": \"^0.1.3\",\n        \"fast-levenshtein\": \"^2.0.6\",\n        \"levn\": \"^0.4.1\",\n        \"prelude-ls\": \"^1.2.1\",\n        \"type-check\": \"^0.4.0\",\n        \"word-wrap\": \"^1.2.3\"\n      }\n    },\n    \"ora\": {\n      \"version\": \"6.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/ora/-/ora-6.2.0.tgz\",\n      \"integrity\": \"sha512-c1qb/1rdE+EFDYiLXh10VY459uMh7DN9zlgd8mZJLoeiPpYllN8eAOiih2Rkah5ywxRm5tHN5C9zPheDq8d1MA==\",\n      \"requires\": {\n        \"chalk\": \"^5.0.0\",\n        \"cli-cursor\": \"^4.0.0\",\n        \"cli-spinners\": \"^2.6.1\",\n        \"is-interactive\": \"^2.0.0\",\n        \"is-unicode-supported\": \"^1.1.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["452", {"page_content": "\"is-interactive\": \"^2.0.0\",\n        \"is-unicode-supported\": \"^1.1.0\",\n        \"log-symbols\": \"^5.1.0\",\n        \"stdin-discarder\": \"^0.1.0\",\n        \"strip-ansi\": \"^7.0.1\",\n        \"wcwidth\": \"^1.0.1\"\n      },\n      \"dependencies\": {\n        \"ansi-regex\": {\n          \"version\": \"6.0.1\",\n          \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz\",\n          \"integrity\": \"sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==\"\n        },\n        \"strip-ansi\": {\n          \"version\": \"7.0.1\",\n          \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz\",\n          \"integrity\": \"sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==\",\n          \"requires\": {\n            \"ansi-regex\": \"^6.0.1\"\n          }\n        }\n      }\n    },\n    \"os-tmpdir\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["453", {"page_content": "\"resolved\": \"https://registry.npmjs.org/os-tmpdir/-/os-tmpdir-1.0.2.tgz\",\n      \"integrity\": \"sha512-D2FR03Vir7FIu45XBY20mTb+/ZSWB00sjU9jdQXt83gDrI4Ztz5Fs7/yy74g2N5SVQY4xY1qDr4rNddwYRVX0g==\"\n    },\n    \"p-queue\": {\n      \"version\": \"7.3.4\",\n      \"resolved\": \"https://registry.npmjs.org/p-queue/-/p-queue-7.3.4.tgz\",\n      \"integrity\": \"sha512-esox8CWt0j9EZECFvkFl2WNPat8LN4t7WWeXq73D9ha0V96qPRufApZi4ZhPwXAln1uVVal429HVVKPa2X0yQg==\",\n      \"requires\": {\n        \"eventemitter3\": \"^4.0.7\",\n        \"p-timeout\": \"^5.0.2\"\n      }\n    },\n    \"p-timeout\": {\n      \"version\": \"5.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/p-timeout/-/p-timeout-5.1.0.tgz\",\n      \"integrity\": \"sha512-auFDyzzzGZZZdHz3BtET9VEz0SE/uMEAx7uWfGPucfzEwwe/xH0iVeZibQmANYE/hp9T2+UUZT5m+BKyrDp3Ew==\"\n    },\n    \"parent-module\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["454", {"page_content": "\"resolved\": \"https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz\",\n      \"integrity\": \"sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"callsites\": \"^3.0.0\"\n      }\n    },\n    \"path-is-absolute\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n      \"integrity\": \"sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==\",\n      \"dev\": true\n    },\n    \"path-key\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz\",\n      \"integrity\": \"sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==\",\n      \"dev\": true\n    },\n    \"path-parse\": {\n      \"version\": \"1.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["455", {"page_content": "\"resolved\": \"https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz\",\n      \"integrity\": \"sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==\",\n      \"dev\": true\n    },\n    \"path-type\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz\",\n      \"integrity\": \"sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==\",\n      \"dev\": true\n    },\n    \"picocolors\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/picocolors/-/picocolors-1.0.0.tgz\",\n      \"integrity\": \"sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==\",\n      \"dev\": true\n    },\n    \"picomatch\": {\n      \"version\": \"2.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["456", {"page_content": "\"resolved\": \"https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz\",\n      \"integrity\": \"sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==\",\n      \"dev\": true\n    },\n    \"prelude-ls\": {\n      \"version\": \"1.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz\",\n      \"integrity\": \"sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==\",\n      \"dev\": true\n    },\n    \"prettier\": {\n      \"version\": \"2.8.6\",\n      \"resolved\": \"https://registry.npmjs.org/prettier/-/prettier-2.8.6.tgz\",\n      \"integrity\": \"sha512-mtuzdiBbHwPEgl7NxWlqOkithPyp4VN93V7VeHVWBF+ad3I5avc0RVDT4oImXQy9H/AqxA2NSQH8pSxHW6FYbQ==\",\n      \"dev\": true\n    },\n    \"prettier-linter-helpers\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/prettier-linter-helpers/-/prettier-linter-helpers-1.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["457", {"page_content": "\"integrity\": \"sha512-GbK2cP9nraSSUF9N2XwUwqfzlAFlMNYYl+ShE/V+H8a9uNl/oUqB1w2EL54Jh0OlyRSd8RfWYJ3coVS4TROP2w==\",\n      \"dev\": true,\n      \"requires\": {\n        \"fast-diff\": \"^1.1.2\"\n      }\n    },\n    \"progress\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/progress/-/progress-2.0.3.tgz\",\n      \"integrity\": \"sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==\",\n      \"dev\": true\n    },\n    \"prop-types\": {\n      \"version\": \"15.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz\",\n      \"integrity\": \"sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"loose-envify\": \"^1.4.0\",\n        \"object-assign\": \"^4.1.1\",\n        \"react-is\": \"^16.13.1\"\n      }\n    },\n    \"punycode\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/punycode/-/punycode-2.3.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["458", {"page_content": "\"resolved\": \"https://registry.npmjs.org/punycode/-/punycode-2.3.0.tgz\",\n      \"integrity\": \"sha512-rRV+zQD8tVFys26lAGR9WUuS4iUAngJScM+ZRSKtvl5tKeZ2t5bvdNFdNHBW9FWR4guGHlgmsZ1G7BSm2wTbuA==\",\n      \"dev\": true\n    },\n    \"queue-microtask\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz\",\n      \"integrity\": \"sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==\",\n      \"dev\": true\n    },\n    \"react-is\": {\n      \"version\": \"16.13.1\",\n      \"resolved\": \"https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz\",\n      \"integrity\": \"sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==\",\n      \"dev\": true\n    },\n    \"readable-stream\": {\n      \"version\": \"3.6.2\",\n      \"resolved\": \"https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["459", {"page_content": "\"resolved\": \"https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz\",\n      \"integrity\": \"sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==\",\n      \"requires\": {\n        \"inherits\": \"^2.0.3\",\n        \"string_decoder\": \"^1.1.1\",\n        \"util-deprecate\": \"^1.0.1\"\n      }\n    },\n    \"redeyed\": {\n      \"version\": \"2.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/redeyed/-/redeyed-2.1.1.tgz\",\n      \"integrity\": \"sha512-FNpGGo1DycYAdnrKFxCMmKYgo/mILAqtRYbkdQD8Ep/Hk2PQ5+aEAEx+IU713RTDmuBaH0c8P5ZozurNu5ObRQ==\",\n      \"requires\": {\n        \"esprima\": \"~4.0.0\"\n      }\n    },\n    \"regenerator-runtime\": {\n      \"version\": \"0.13.11\",\n      \"resolved\": \"https://registry.npmjs.org/regenerator-runtime/-/regenerator-runtime-0.13.11.tgz\",\n      \"integrity\": \"sha512-kY1AZVr2Ra+t+piVaJ4gxaFaReZVH40AKNo7UCX6W+dEwBo/2oZJzqfuN1qLq1oL45o56cPaTXELwrTh8Fpggg==\",\n      \"dev\": true\n    },\n    \"regexp.prototype.flags\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["460", {"page_content": "\"dev\": true\n    },\n    \"regexp.prototype.flags\": {\n      \"version\": \"1.4.3\",\n      \"resolved\": \"https://registry.npmjs.org/regexp.prototype.flags/-/regexp.prototype.flags-1.4.3.tgz\",\n      \"integrity\": \"sha512-fjggEOO3slI6Wvgjwflkc4NFRCTZAu5CnNfBd5qOMYhWdn67nJBBu34/TkD++eeFmd8C9r9jfXJ27+nSiRkSUA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.3\",\n        \"functions-have-names\": \"^1.2.2\"\n      }\n    },\n    \"regexpp\": {\n      \"version\": \"3.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz\",\n      \"integrity\": \"sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==\",\n      \"dev\": true\n    },\n    \"require-from-string\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["461", {"page_content": "\"resolved\": \"https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz\",\n      \"integrity\": \"sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==\",\n      \"dev\": true\n    },\n    \"resolve\": {\n      \"version\": \"1.22.1\",\n      \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-1.22.1.tgz\",\n      \"integrity\": \"sha512-nBpuuYuY5jFsli/JIs1oldw6fOQCBioohqWZg/2hiaOybXOft4lonv85uDOKXdf8rhyK159cxU5cDcK/NKk8zw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"is-core-module\": \"^2.9.0\",\n        \"path-parse\": \"^1.0.7\",\n        \"supports-preserve-symlinks-flag\": \"^1.0.0\"\n      }\n    },\n    \"resolve-from\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz\",\n      \"integrity\": \"sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==\",\n      \"dev\": true\n    },\n    \"restore-cursor\": {\n      \"version\": \"4.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["462", {"page_content": "\"dev\": true\n    },\n    \"restore-cursor\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/restore-cursor/-/restore-cursor-4.0.0.tgz\",\n      \"integrity\": \"sha512-I9fPXU9geO9bHOt9pHHOhOkYerIMsmVaWB0rA2AI9ERh/+x/i7MV5HKBNrg+ljO5eoPVgCcnFuRjJ9uH6I/3eg==\",\n      \"requires\": {\n        \"onetime\": \"^5.1.0\",\n        \"signal-exit\": \"^3.0.2\"\n      }\n    },\n    \"reusify\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz\",\n      \"integrity\": \"sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==\",\n      \"dev\": true\n    },\n    \"rimraf\": {\n      \"version\": \"3.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz\",\n      \"integrity\": \"sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"glob\": \"^7.1.3\"\n      }\n    },\n    \"run-async\": {\n      \"version\": \"2.4.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["463", {"page_content": "\"glob\": \"^7.1.3\"\n      }\n    },\n    \"run-async\": {\n      \"version\": \"2.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/run-async/-/run-async-2.4.1.tgz\",\n      \"integrity\": \"sha512-tvVnVv01b8c1RrA6Ep7JkStj85Guv/YrMcwqYQnwjsAS2cTmmPGBBjAjpCW7RrSodNSoE2/qg9O4bceNvUuDgQ==\"\n    },\n    \"run-parallel\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz\",\n      \"integrity\": \"sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"queue-microtask\": \"^1.2.2\"\n      }\n    },\n    \"rxjs\": {\n      \"version\": \"7.8.0\",\n      \"resolved\": \"https://registry.npmjs.org/rxjs/-/rxjs-7.8.0.tgz\",\n      \"integrity\": \"sha512-F2+gxDshqmIub1KdvZkaEfGDwLNpPvk9Fs6LD/MyQxNgMds/WH9OdDDXOmxUZpME+iSK3rQCctkL0DYyytUqMg==\",\n      \"requires\": {\n        \"tslib\": \"^2.1.0\"\n      }\n    },\n    \"safe-buffer\": {\n      \"version\": \"5.2.1\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["464", {"page_content": "\"tslib\": \"^2.1.0\"\n      }\n    },\n    \"safe-buffer\": {\n      \"version\": \"5.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz\",\n      \"integrity\": \"sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==\"\n    },\n    \"safe-regex-test\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/safe-regex-test/-/safe-regex-test-1.0.0.tgz\",\n      \"integrity\": \"sha512-JBUUzyOgEwXQY1NuPtvcj/qcBDbDmEvWufhlnXZIm75DEHp+afM1r1ujJpJsV/gSM4t59tpDyPi1sd6ZaPFfsA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"is-regex\": \"^1.1.4\"\n      }\n    },\n    \"safer-buffer\": {\n      \"version\": \"2.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz\",\n      \"integrity\": \"sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\"\n    },\n    \"semver\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["465", {"page_content": "},\n    \"semver\": {\n      \"version\": \"7.3.8\",\n      \"resolved\": \"https://registry.npmjs.org/semver/-/semver-7.3.8.tgz\",\n      \"integrity\": \"sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==\",\n      \"dev\": true,\n      \"requires\": {\n        \"lru-cache\": \"^6.0.0\"\n      }\n    },\n    \"shebang-command\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz\",\n      \"integrity\": \"sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"shebang-regex\": \"^3.0.0\"\n      }\n    },\n    \"shebang-regex\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz\",\n      \"integrity\": \"sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==\",\n      \"dev\": true\n    },\n    \"side-channel\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["466", {"page_content": "\"dev\": true\n    },\n    \"side-channel\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/side-channel/-/side-channel-1.0.4.tgz\",\n      \"integrity\": \"sha512-q5XPytqFEIKHkGdiMIrY10mvLRvnQh42/+GoBlFW3b2LXLE2xxJpZFdm94we0BaoV3RwJyGqg5wS7epxTv0Zvw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.0\",\n        \"get-intrinsic\": \"^1.0.2\",\n        \"object-inspect\": \"^1.9.0\"\n      }\n    },\n    \"signal-exit\": {\n      \"version\": \"3.0.7\",\n      \"resolved\": \"https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz\",\n      \"integrity\": \"sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==\"\n    },\n    \"slash\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/slash/-/slash-3.0.0.tgz\",\n      \"integrity\": \"sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==\",\n      \"dev\": true\n    },\n    \"slice-ansi\": {\n      \"version\": \"4.0.0\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["467", {"page_content": "\"dev\": true\n    },\n    \"slice-ansi\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz\",\n      \"integrity\": \"sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"ansi-styles\": \"^4.0.0\",\n        \"astral-regex\": \"^2.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\"\n      }\n    },\n    \"sprintf-js\": {\n      \"version\": \"1.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz\",\n      \"integrity\": \"sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==\",\n      \"dev\": true\n    },\n    \"stdin-discarder\": {\n      \"version\": \"0.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/stdin-discarder/-/stdin-discarder-0.1.0.tgz\",\n      \"integrity\": \"sha512-xhV7w8S+bUwlPTb4bAOUQhv8/cSS5offJuX8GQGq32ONF0ZtDWKfkdomM3HMRA+LhX6um/FZ0COqlwsjD53LeQ==\",\n      \"requires\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["468", {"page_content": "\"requires\": {\n        \"bl\": \"^5.0.0\"\n      }\n    },\n    \"stop-iteration-iterator\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/stop-iteration-iterator/-/stop-iteration-iterator-1.0.0.tgz\",\n      \"integrity\": \"sha512-iCGQj+0l0HOdZ2AEeBADlsRC+vsnDsZsbdSiH1yNSjcfKM7fdpCMfqAL/dwF5BLiw/XhRft/Wax6zQbhq2BcjQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"internal-slot\": \"^1.0.4\"\n      }\n    },\n    \"string_decoder\": {\n      \"version\": \"1.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz\",\n      \"integrity\": \"sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==\",\n      \"requires\": {\n        \"safe-buffer\": \"~5.2.0\"\n      }\n    },\n    \"string-width\": {\n      \"version\": \"4.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["469", {"page_content": "\"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz\",\n      \"integrity\": \"sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==\",\n      \"requires\": {\n        \"emoji-regex\": \"^8.0.0\",\n        \"is-fullwidth-code-point\": \"^3.0.0\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"dependencies\": {\n        \"emoji-regex\": {\n          \"version\": \"8.0.0\",\n          \"resolved\": \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz\",\n          \"integrity\": \"sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==\"\n        }\n      }\n    },\n    \"string.prototype.matchall\": {\n      \"version\": \"4.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.matchall/-/string.prototype.matchall-4.0.8.tgz\",\n      \"integrity\": \"sha512-6zOCOcJ+RJAQshcTvXPHoxoQGONa3e/Lqx90wUA+wEzX78sg5Bo+1tQo4N0pohS0erG9qtCqJDjNCQBjeWVxyg==\",\n      \"dev\": true,\n      \"requires\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["470", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\",\n        \"get-intrinsic\": \"^1.1.3\",\n        \"has-symbols\": \"^1.0.3\",\n        \"internal-slot\": \"^1.0.3\",\n        \"regexp.prototype.flags\": \"^1.4.3\",\n        \"side-channel\": \"^1.0.4\"\n      }\n    },\n    \"string.prototype.trim\": {\n      \"version\": \"1.2.7\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.trim/-/string.prototype.trim-1.2.7.tgz\",\n      \"integrity\": \"sha512-p6TmeT1T3411M8Cgg9wBTMRtY2q9+PNy9EV1i2lIXUN/btt763oIfxwN3RR8VU6wHX8j/1CFy0L+YuThm6bgOg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      }\n    },\n    \"string.prototype.trimend\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.trimend/-/string.prototype.trimend-1.0.6.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["471", {"page_content": "\"integrity\": \"sha512-JySq+4mrPf9EsDBEDYMOb/lM7XQLulwg5R/m1r0PXEFqrV0qHvl58sdTilSXtKOflCsK2E8jxf+GKC0T07RWwQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      }\n    },\n    \"string.prototype.trimstart\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/string.prototype.trimstart/-/string.prototype.trimstart-1.0.6.tgz\",\n      \"integrity\": \"sha512-omqjMDaY92pbn5HOX7f9IccLA+U1tA9GvtU4JrodiXFfYB7jPzzHpRzpglLAjtUV6bB557zwClJezTqnAiYnQA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"define-properties\": \"^1.1.4\",\n        \"es-abstract\": \"^1.20.4\"\n      }\n    },\n    \"strip-ansi\": {\n      \"version\": \"6.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz\",\n      \"integrity\": \"sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==\",\n      \"requires\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["472", {"page_content": "\"requires\": {\n        \"ansi-regex\": \"^5.0.1\"\n      }\n    },\n    \"strip-bom\": {\n      \"version\": \"3.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz\",\n      \"integrity\": \"sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==\",\n      \"dev\": true\n    },\n    \"strip-json-comments\": {\n      \"version\": \"3.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz\",\n      \"integrity\": \"sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==\",\n      \"dev\": true\n    },\n    \"supports-color\": {\n      \"version\": \"5.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz\",\n      \"integrity\": \"sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==\",\n      \"dev\": true,\n      \"requires\": {\n        \"has-flag\": \"^3.0.0\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["473", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"has-flag\": \"^3.0.0\"\n      }\n    },\n    \"supports-hyperlinks\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-hyperlinks/-/supports-hyperlinks-2.3.0.tgz\",\n      \"integrity\": \"sha512-RpsAZlpWcDwOPQA22aCH4J0t7L8JmAvsCxfOSEwm7cQs3LshN36QaTkwd70DnBOXDWGssw2eUoc8CaRWT0XunA==\",\n      \"requires\": {\n        \"has-flag\": \"^4.0.0\",\n        \"supports-color\": \"^7.0.0\"\n      },\n      \"dependencies\": {\n        \"has-flag\": {\n          \"version\": \"4.0.0\",\n          \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\",\n          \"integrity\": \"sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\"\n        },\n        \"supports-color\": {\n          \"version\": \"7.2.0\",\n          \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["474", {"page_content": "\"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\",\n          \"integrity\": \"sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\",\n          \"requires\": {\n            \"has-flag\": \"^4.0.0\"\n          }\n        }\n      }\n    },\n    \"supports-preserve-symlinks-flag\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz\",\n      \"integrity\": \"sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==\",\n      \"dev\": true\n    },\n    \"synckit\": {\n      \"version\": \"0.8.5\",\n      \"resolved\": \"https://registry.npmjs.org/synckit/-/synckit-0.8.5.tgz\",\n      \"integrity\": \"sha512-L1dapNV6vu2s/4Sputv8xGsCdAVlb5nRDMFU/E27D44l5U6cw1g0dGd45uLc+OXjNMmF4ntiMdCimzcjFKQI8Q==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@pkgr/utils\": \"^2.3.1\",\n        \"tslib\": \"^2.5.0\"\n      }\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["475", {"page_content": "\"requires\": {\n        \"@pkgr/utils\": \"^2.3.1\",\n        \"tslib\": \"^2.5.0\"\n      }\n    },\n    \"table\": {\n      \"version\": \"6.8.1\",\n      \"resolved\": \"https://registry.npmjs.org/table/-/table-6.8.1.tgz\",\n      \"integrity\": \"sha512-Y4X9zqrCftUhMeH2EptSSERdVKt/nEdijTOacGD/97EKjhQ/Qs8RTlEGABSJNNN8lac9kheH+af7yAkEWlgneA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"ajv\": \"^8.0.1\",\n        \"lodash.truncate\": \"^4.4.2\",\n        \"slice-ansi\": \"^4.0.0\",\n        \"string-width\": \"^4.2.3\",\n        \"strip-ansi\": \"^6.0.1\"\n      },\n      \"dependencies\": {\n        \"ajv\": {\n          \"version\": \"8.12.0\",\n          \"resolved\": \"https://registry.npmjs.org/ajv/-/ajv-8.12.0.tgz\",\n          \"integrity\": \"sha512-sRu1kpcO9yLtYxBKvqfTeh9KzZEwO3STyX1HT+4CaDzC6HpTGYhIhPIzj9XuKU7KYDwnaeh5hcOwjy1QuJzBPA==\",\n          \"dev\": true,\n          \"requires\": {\n            \"fast-deep-equal\": \"^3.1.1\",\n            \"json-schema-traverse\": \"^1.0.0\",\n            \"require-from-string\": \"^2.0.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["476", {"page_content": "\"json-schema-traverse\": \"^1.0.0\",\n            \"require-from-string\": \"^2.0.2\",\n            \"uri-js\": \"^4.2.2\"\n          }\n        },\n        \"json-schema-traverse\": {\n          \"version\": \"1.0.0\",\n          \"resolved\": \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz\",\n          \"integrity\": \"sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"tapable\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/tapable/-/tapable-2.2.1.tgz\",\n      \"integrity\": \"sha512-GNzQvQTOIP6RyTfE2Qxb8ZVlNmw0n88vp1szwWRimP02mnTsx3Wtn5qRdqY9w2XduFNUgvOwhNnQsjwCp+kqaQ==\",\n      \"dev\": true\n    },\n    \"text-table\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz\",\n      \"integrity\": \"sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["477", {"page_content": "\"dev\": true\n    },\n    \"textextensions\": {\n      \"version\": \"5.15.0\",\n      \"resolved\": \"https://registry.npmjs.org/textextensions/-/textextensions-5.15.0.tgz\",\n      \"integrity\": \"sha512-MeqZRHLuaGamUXGuVn2ivtU3LA3mLCCIO5kUGoohTCoGmCBg/+8yPhWVX9WSl9telvVd8erftjFk9Fwb2dD6rw==\"\n    },\n    \"through\": {\n      \"version\": \"2.3.8\",\n      \"resolved\": \"https://registry.npmjs.org/through/-/through-2.3.8.tgz\",\n      \"integrity\": \"sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg==\"\n    },\n    \"tiny-glob\": {\n      \"version\": \"0.2.9\",\n      \"resolved\": \"https://registry.npmjs.org/tiny-glob/-/tiny-glob-0.2.9.tgz\",\n      \"integrity\": \"sha512-g/55ssRPUjShh+xkfx9UPDXqhckHEsHr4Vd9zX55oSdGZc/MD0m3sferOkwWtp98bv+kcVfEHtRJgBVJzelrzg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"globalyzer\": \"0.1.0\",\n        \"globrex\": \"^0.1.2\"\n      }\n    },\n    \"tmp\": {\n      \"version\": \"0.0.33\",\n      \"resolved\": \"https://registry.npmjs.org/tmp/-/tmp-0.0.33.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["478", {"page_content": "\"version\": \"0.0.33\",\n      \"resolved\": \"https://registry.npmjs.org/tmp/-/tmp-0.0.33.tgz\",\n      \"integrity\": \"sha512-jRCJlojKnZ3addtTOjdIqoRuPEKBvNXcGYqzO6zWZX8KfKEpnGY5jfggJQ3EjKuu8D4bJRr0y+cYJFmYbImXGw==\",\n      \"requires\": {\n        \"os-tmpdir\": \"~1.0.2\"\n      }\n    },\n    \"to-regex-range\": {\n      \"version\": \"5.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz\",\n      \"integrity\": \"sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==\",\n      \"dev\": true,\n      \"requires\": {\n        \"is-number\": \"^7.0.0\"\n      }\n    },\n    \"ts-md5\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/ts-md5/-/ts-md5-1.3.1.tgz\",\n      \"integrity\": \"sha512-DiwiXfwvcTeZ5wCE0z+2A9EseZsztaiZtGrtSaY5JOD7ekPnR/GoIVD5gXZAlK9Na9Kvpo9Waz5rW64WKAWApg==\"\n    },\n    \"tsconfig-paths\": {\n      \"version\": \"3.14.2\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["479", {"page_content": "},\n    \"tsconfig-paths\": {\n      \"version\": \"3.14.2\",\n      \"resolved\": \"https://registry.npmjs.org/tsconfig-paths/-/tsconfig-paths-3.14.2.tgz\",\n      \"integrity\": \"sha512-o/9iXgCYc5L/JxCHPe3Hvh8Q/2xm5Z+p18PESBU6Ff33695QnCHBEjcytY2q19ua7Mbl/DavtBOLq+oG0RCL+g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@types/json5\": \"^0.0.29\",\n        \"json5\": \"^1.0.2\",\n        \"minimist\": \"^1.2.6\",\n        \"strip-bom\": \"^3.0.0\"\n      }\n    },\n    \"tslib\": {\n      \"version\": \"2.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-2.5.0.tgz\",\n      \"integrity\": \"sha512-336iVw3rtn2BUK7ORdIAHTyxHGRIHVReokCR3XjbckJMK7ms8FysBfhLR8IXnAgy7T0PTPNBWKiH514FOW/WSg==\"\n    },\n    \"tsutils\": {\n      \"version\": \"3.21.0\",\n      \"resolved\": \"https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz\",\n      \"integrity\": \"sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"tslib\": \"^1.8.1\"\n      },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["480", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"tslib\": \"^1.8.1\"\n      },\n      \"dependencies\": {\n        \"tslib\": {\n          \"version\": \"1.14.1\",\n          \"resolved\": \"https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz\",\n          \"integrity\": \"sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==\",\n          \"dev\": true\n        }\n      }\n    },\n    \"type-check\": {\n      \"version\": \"0.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz\",\n      \"integrity\": \"sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==\",\n      \"dev\": true,\n      \"requires\": {\n        \"prelude-ls\": \"^1.2.1\"\n      }\n    },\n    \"type-fest\": {\n      \"version\": \"0.20.2\",\n      \"resolved\": \"https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz\",\n      \"integrity\": \"sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==\",\n      \"dev\": true\n    },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["481", {"page_content": "\"dev\": true\n    },\n    \"typed-array-length\": {\n      \"version\": \"1.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/typed-array-length/-/typed-array-length-1.0.4.tgz\",\n      \"integrity\": \"sha512-KjZypGq+I/H7HI5HlOoGHkWUUGq+Q0TPhQurLbyrVrvnKTBgzLhIJ7j6J/XTQOi0d1RjyZ0wdas8bKs2p0x3Ng==\",\n      \"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"for-each\": \"^0.3.3\",\n        \"is-typed-array\": \"^1.1.9\"\n      }\n    },\n    \"typescript\": {\n      \"version\": \"4.9.5\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-4.9.5.tgz\",\n      \"integrity\": \"sha512-1FXk9E2Hm+QzZQ7z+McJiHL4NW1F2EzMu9Nq9i3zAaGqibafqYwCVU6WyWAuyQRRzOlxou8xZSyXLEN8oKj24g==\",\n      \"dev\": true\n    },\n    \"unbox-primitive\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/unbox-primitive/-/unbox-primitive-1.0.2.tgz\",\n      \"integrity\": \"sha512-61pPlCD9h51VoreyJ0BReideM3MDKMKnh6+V9L08331ipq6Q8OFXZYiqP6n/tbHx4s5I9uRhcye6BrbkizkBDw==\",\n      \"dev\": true,", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["482", {"page_content": "\"dev\": true,\n      \"requires\": {\n        \"call-bind\": \"^1.0.2\",\n        \"has-bigints\": \"^1.0.2\",\n        \"has-symbols\": \"^1.0.3\",\n        \"which-boxed-primitive\": \"^1.0.2\"\n      }\n    },\n    \"uri-js\": {\n      \"version\": \"4.4.1\",\n      \"resolved\": \"https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz\",\n      \"integrity\": \"sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"punycode\": \"^2.1.0\"\n      }\n    },\n    \"util-deprecate\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz\",\n      \"integrity\": \"sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==\"\n    },\n    \"uuid\": {\n      \"version\": \"9.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-9.0.0.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["483", {"page_content": "\"version\": \"9.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-9.0.0.tgz\",\n      \"integrity\": \"sha512-MXcSTerfPa4uqyzStbRoTgt5XIe3x5+42+q1sDuy3R5MDk66URdLMOZe5aPX/SQd+kuYAh0FdP/pO28IkQyTeg==\"\n    },\n    \"v8-compile-cache\": {\n      \"version\": \"2.3.0\",\n      \"resolved\": \"https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.3.0.tgz\",\n      \"integrity\": \"sha512-l8lCEmLcLYZh4nbunNZvQCJc5pv7+RCwa8q/LdUx8u7lsWvPDKmpodJAJNwkAhJC//dFY48KuIEmjtd4RViDrA==\",\n      \"dev\": true\n    },\n    \"wcwidth\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/wcwidth/-/wcwidth-1.0.1.tgz\",\n      \"integrity\": \"sha512-XHPEwS0q6TaxcvG85+8EYkbiCux2XtWG2mkc47Ng2A77BQu9+DqIOJldST4HgPkuea7dvKSj5VgX3P1d4rW8Tg==\",\n      \"requires\": {\n        \"defaults\": \"^1.0.3\"\n      }\n    },\n    \"which\": {\n      \"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["484", {"page_content": "\"version\": \"2.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\",\n      \"integrity\": \"sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"isexe\": \"^2.0.0\"\n      }\n    },\n    \"which-boxed-primitive\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/which-boxed-primitive/-/which-boxed-primitive-1.0.2.tgz\",\n      \"integrity\": \"sha512-bwZdv0AKLpplFY2KZRX6TvyuN7ojjr7lwkg6ml0roIy9YeuSr7JS372qlNW18UQYzgYK9ziGcerWqZOmEn9VNg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"is-bigint\": \"^1.0.1\",\n        \"is-boolean-object\": \"^1.1.0\",\n        \"is-number-object\": \"^1.0.4\",\n        \"is-string\": \"^1.0.5\",\n        \"is-symbol\": \"^1.0.3\"\n      }\n    },\n    \"which-collection\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/which-collection/-/which-collection-1.0.1.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["485", {"page_content": "\"resolved\": \"https://registry.npmjs.org/which-collection/-/which-collection-1.0.1.tgz\",\n      \"integrity\": \"sha512-W8xeTUwaln8i3K/cY1nGXzdnVZlidBcagyNFtBdD5kxnb4TvGKR7FfSIS3mYpwWS1QUCutfKz8IY8RjftB0+1A==\",\n      \"dev\": true,\n      \"requires\": {\n        \"is-map\": \"^2.0.1\",\n        \"is-set\": \"^2.0.1\",\n        \"is-weakmap\": \"^2.0.1\",\n        \"is-weakset\": \"^2.0.1\"\n      }\n    },\n    \"which-typed-array\": {\n      \"version\": \"1.1.9\",\n      \"resolved\": \"https://registry.npmjs.org/which-typed-array/-/which-typed-array-1.1.9.tgz\",\n      \"integrity\": \"sha512-w9c4xkx6mPidwp7180ckYWfMmvxpjlZuIudNtDf4N/tTAUB8VJbX25qZoAsrtGuYNnGw3pa0AXgbGKRB8/EceA==\",\n      \"dev\": true,\n      \"requires\": {\n        \"available-typed-arrays\": \"^1.0.5\",\n        \"call-bind\": \"^1.0.2\",\n        \"for-each\": \"^0.3.3\",\n        \"gopd\": \"^1.0.1\",\n        \"has-tostringtag\": \"^1.0.0\",\n        \"is-typed-array\": \"^1.1.10\"\n      }\n    },\n    \"word-wrap\": {\n      \"version\": \"1.2.3\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["486", {"page_content": "\"is-typed-array\": \"^1.1.10\"\n      }\n    },\n    \"word-wrap\": {\n      \"version\": \"1.2.3\",\n      \"resolved\": \"https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz\",\n      \"integrity\": \"sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==\",\n      \"dev\": true\n    },\n    \"wrap-ansi\": {\n      \"version\": \"8.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz\",\n      \"integrity\": \"sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==\",\n      \"requires\": {\n        \"ansi-styles\": \"^6.1.0\",\n        \"string-width\": \"^5.0.1\",\n        \"strip-ansi\": \"^7.0.1\"\n      },\n      \"dependencies\": {\n        \"ansi-regex\": {\n          \"version\": \"6.0.1\",\n          \"resolved\": \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz\",\n          \"integrity\": \"sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==\"\n        },", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["487", {"page_content": "},\n        \"ansi-styles\": {\n          \"version\": \"6.2.1\",\n          \"resolved\": \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz\",\n          \"integrity\": \"sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==\"\n        },\n        \"string-width\": {\n          \"version\": \"5.1.2\",\n          \"resolved\": \"https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz\",\n          \"integrity\": \"sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==\",\n          \"requires\": {\n            \"eastasianwidth\": \"^0.2.0\",\n            \"emoji-regex\": \"^9.2.2\",\n            \"strip-ansi\": \"^7.0.1\"\n          }\n        },\n        \"strip-ansi\": {\n          \"version\": \"7.0.1\",\n          \"resolved\": \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz\",\n          \"integrity\": \"sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==\",\n          \"requires\": {", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["488", {"page_content": "\"requires\": {\n            \"ansi-regex\": \"^6.0.1\"\n          }\n        }\n      }\n    },\n    \"wrappy\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n      \"integrity\": \"sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==\",\n      \"dev\": true\n    },\n    \"yallist\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz\",\n      \"integrity\": \"sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==\",\n      \"dev\": true\n    },\n    \"yaml\": {\n      \"version\": \"2.2.1\",\n      \"resolved\": \"https://registry.npmjs.org/yaml/-/yaml-2.2.1.tgz\",\n      \"integrity\": \"sha512-e0WHiYql7+9wr4cWMx3TVQrNwejKaEe7/rHNmQmqRjazfOP5W8PB6Jpebb5o6fIapbz9o9+2ipcaTM2ZwDI6lw==\"\n    },\n    \"zod\": {\n      \"version\": \"3.21.4\",\n      \"resolved\": \"https://registry.npmjs.org/zod/-/zod-3.21.4.tgz\",", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["489", {"page_content": "\"version\": \"3.21.4\",\n      \"resolved\": \"https://registry.npmjs.org/zod/-/zod-3.21.4.tgz\",\n      \"integrity\": \"sha512-m46AKbrzKVzOzs/DZgVnG5H55N1sv1M8qZU3A8RIKbs3mrACDNeIOeilDymVb2HdmP8uwshOCF4uJ8uM9rCqJw==\"\n    }\n  }\n}", "metadata": {"source": "autodoc/package-lock.json"}, "type": "Document"}], ["490", {"page_content": "The MIT License\n\nCopyright (c) Sam Heutmaker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.", "metadata": {"source": "autodoc/LICENSE"}, "type": "Document"}], ["491", {"page_content": "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.", "metadata": {"source": "autodoc/LICENSE"}, "type": "Document"}], ["492", {"page_content": "{\n  \"fileName\": \"types.ts\",\n  \"filePath\": \"src\\\\types.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\types.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/types.json"}, "type": "Document"}], ["493", {"page_content": "\"summary\": \"This code defines the types and interfaces for the `autodoc` project, which aims to automatically generate documentation for a given code repository. The project uses OpenAI's language models (LLMs) to process and generate summaries, questions, and other relevant information for files and folders in the repository.\\n\\nThe `AutodocUserConfig` and `AutodocRepoConfig` types define the configuration options for the user and repository, respectively. These include settings such as the LLM models to use, repository URL, output directory, and content type.\\n\\n`FileSummary` and `FolderSummary` types represent the generated summaries for files and folders, including their paths, URLs, and checksums. The `ProcessFileParams` and `ProcessFolderParams` types define the parameters required for processing files and folders, such as the file or folder name, path, and content type.\\n\\n`ProcessFile` and `ProcessFolder` are function types that take the respective parameters and return a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/types.json"}, "type": "Document"}], ["494", {"page_content": "and `ProcessFolder` are function types that take the respective parameters and return a promise. These functions are responsible for processing the files and folders, generating summaries, and updating the documentation.\\n\\n`TraverseFileSystemParams` type defines the parameters for traversing the file system, including the input path, project name, and optional `processFile` and `processFolder` functions. It also includes settings for ignoring certain files or folders and content type preferences.\\n\\nThe `LLMModels` enum lists the available language models, such as GPT-3.5 Turbo, GPT-4, and GPT-4 32k. The `LLMModelDetails` type provides information about each model, including the cost per 1K tokens, maximum length, and success/failure statistics.\\n\\nIn the larger project, these types and interfaces would be used to configure and run the `autodoc` tool, allowing users to automatically generate documentation for their code repositories using OpenAI's language models. For example, a user", "metadata": {"source": "autodoc/.autodoc/docs/json/src/types.json"}, "type": "Document"}], ["495", {"page_content": "documentation for their code repositories using OpenAI's language models. For example, a user could provide an `AutodocRepoConfig` object to configure the tool, and then use the `TraverseFileSystem` function to process the repository and generate the documentation.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/types.json"}, "type": "Document"}], ["496", {"page_content": "\"questions\": \"1. **What is the purpose of the `AutodocUserConfig` and `AutodocRepoConfig` types?**\\n\\n   The `AutodocUserConfig` type is used to define the user configuration for the autodoc project, which includes an array of LLMModels. The `AutodocRepoConfig` type is used to define the repository configuration for the autodoc project, which includes various properties such as name, repository URL, root, output, LLMModels, and more.\\n\\n2. **What are the different LLMModels available in the `LLMModels` enum?**\\n\\n   The `LLMModels` enum lists the available language models for the autodoc project. Currently, there are three models: GPT3 (gpt-3.5-turbo), GPT4 (gpt-4), and GPT432k (gpt-4-32k).\\n\\n3. **What is the purpose of the `ProcessFile` and `ProcessFolder` types?**\\n\\n   The `ProcessFile` type is a function type that takes a `ProcessFileParams` object as input and returns a Promise. It is used to process a single file in the autodoc project. The `ProcessFolder` type is a function", "metadata": {"source": "autodoc/.autodoc/docs/json/src/types.json"}, "type": "Document"}], ["497", {"page_content": "It is used to process a single file in the autodoc project. The `ProcessFolder` type is a function type that takes a `ProcessFolderParams` object as input and returns a Promise. It is used to process a folder in the autodoc project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/types.json"}, "type": "Document"}], ["498", {"page_content": "\"checksum\": \"796822d4da09cce719cb86b540d2fb66\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/types.json"}, "type": "Document"}], ["499", {"page_content": "{\n  \"fileName\": \"const.ts\",\n  \"filePath\": \"src\\\\const.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\const.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/const.json"}, "type": "Document"}], ["500", {"page_content": "\"summary\": \"The code in this file is responsible for managing the user configuration file for the autodoc project. It imports two Node.js built-in modules, `path` and `os`, which are used to handle file paths and operating system-related utility functions, respectively.\\n\\nThe `userConfigFileName` constant is defined as `'autodoc.user.json'`, which represents the name of the user configuration file. This file is expected to store user-specific settings for the autodoc project in JSON format.\\n\\nThe `userConfigFilePath` constant is created using the `path.resolve()` function, which combines the provided arguments into an absolute file path. The `os.homedir()` function is used to get the current user's home directory, and `./.config/autodoc/` is appended to it as the folder where the user configuration file should be stored. Finally, the `userConfigFileName` constant is appended to the path, resulting in the complete file path for the user configuration file.\\n\\nBy exporting both", "metadata": {"source": "autodoc/.autodoc/docs/json/src/const.json"}, "type": "Document"}], ["501", {"page_content": "the path, resulting in the complete file path for the user configuration file.\\n\\nBy exporting both `userConfigFileName` and `userConfigFilePath`, other parts of the autodoc project can easily access and use these constants to read or write user-specific settings. For example, when the autodoc application starts, it can read the user configuration file from the specified path, and apply the settings accordingly.\\n\\nHere's a code example of how these constants might be used in another part of the autodoc project:\\n\\n```javascript\\nimport { userConfigFilePath } from './path/to/this/file';\\n\\n// Read user configuration from the file\\nconst userConfig = JSON.parse(fs.readFileSync(userConfigFilePath, 'utf-8'));\\n\\n// Apply user settings\\napplyUserSettings(userConfig);\\n```\\n\\nIn summary, this code is responsible for defining the name and file path of the user configuration file for the autodoc project, allowing other parts of the project to easily access and manage user-specific", "metadata": {"source": "autodoc/.autodoc/docs/json/src/const.json"}, "type": "Document"}], ["502", {"page_content": "the autodoc project, allowing other parts of the project to easily access and manage user-specific settings.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/const.json"}, "type": "Document"}], ["503", {"page_content": "\"questions\": \"1. **What is the purpose of the `userConfigFileName` and `userConfigFilePath` constants?**\\n\\n   The `userConfigFileName` constant defines the name of the user configuration file for the autodoc project, while the `userConfigFilePath` constant defines the absolute path to this file, which is located in the user's home directory under the `.config/autodoc/` folder.\\n\\n2. **Why are the `node:path` and `node:os` modules being imported?**\\n\\n   The `node:path` module is imported to provide utilities for working with file and directory paths, such as resolving the absolute path to the user configuration file. The `node:os` module is imported to provide operating system-related utility methods, such as getting the user's home directory.\\n\\n3. **Is this code compatible with different operating systems?**\\n\\n   Yes, this code is compatible with different operating systems. The `os.homedir()` method returns the home directory of the current user, which is platform-specific, and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/const.json"}, "type": "Document"}], ["504", {"page_content": "method returns the home directory of the current user, which is platform-specific, and the `path.resolve()` method takes care of handling the correct path separators for the current operating system.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/const.json"}, "type": "Document"}], ["505", {"page_content": "\"checksum\": \"ce40980fffc58e17b13690b9e37a6015\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/const.json"}, "type": "Document"}], ["506", {"page_content": "{\n  \"fileName\": \"spinner.ts\",\n  \"filePath\": \"src\\\\cli\\\\spinner.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\spinner.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/spinner.json"}, "type": "Document"}], ["507", {"page_content": "\"summary\": \"This code is responsible for managing a spinner, which is a visual element that indicates a process is running in the background. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\\n\\nThe code starts by importing the `ora` library and creating a singleton spinner instance with the 'dots' style. This ensures that there will only be one spinner active at any given time.\\n\\nThere are several functions exported by this module to interact with the spinner:\\n\\n1. `updateSpinnerText(message: string)`: This function updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\\n\\n   Example usage:\\n   ```javascript\\n   updateSpinnerText('Loading data...');\\n   ```\\n\\n2. `stopSpinner()`: This function stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/spinner.json"}, "type": "Document"}], ["508", {"page_content": "This function stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   stopSpinner();\\n   ```\\n\\n3. `spinnerError(message?: string)`: This function stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerError('Failed to load data');\\n   ```\\n\\n4. `spinnerSuccess(message?: string)`: This function stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerSuccess('Data loaded successfully');\\n   ```\\n\\n5. `spinnerInfo(message: string)`: This function displays an informational message without affecting the spinner's state.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerInfo('Connecting to server...');\\n   ```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/spinner.json"}, "type": "Document"}], ["509", {"page_content": "```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/spinner.json"}, "type": "Document"}], ["510", {"page_content": "\"questions\": \"1. **What is the purpose of the `ora` package in this code?**\\n\\n   The `ora` package is used to create a spinner in the command line interface, providing a visual indication of a running process. In this code, it is used to create a singleton spinner with the 'dots' style.\\n\\n2. **How does the `updateSpinnerText` function work?**\\n\\n   The `updateSpinnerText` function takes a message as an input and updates the spinner's text with the given message. If the spinner is already spinning, it updates the text directly; otherwise, it starts the spinner with the new message.\\n\\n3. **What are the differences between `spinnerError`, `spinnerSuccess`, and `spinnerInfo` functions?**\\n\\n   These functions are used to update the spinner's state and message based on the outcome of a process. `spinnerError` is called when there is an error, and it stops the spinner with a failure message. `spinnerSuccess` is called when the process is successful, and it stops the spinner with a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/spinner.json"}, "type": "Document"}], ["511", {"page_content": "message. `spinnerSuccess` is called when the process is successful, and it stops the spinner with a success message. `spinnerInfo` is used to display an informational message without stopping the spinner.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/spinner.json"}, "type": "Document"}], ["512", {"page_content": "\"checksum\": \"d93ad7e714ce5446916bb1d63cbb6031\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/spinner.json"}, "type": "Document"}], ["513", {"page_content": "{\n  \"folderName\": \"cli\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\",\n  \"files\": [\n    {\n      \"fileName\": \"spinner.ts\",\n      \"filePath\": \"src\\\\cli\\\\spinner.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\spinner.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["514", {"page_content": "\"summary\": \"This code is responsible for managing a spinner, which is a visual element that indicates a process is running in the background. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\\n\\nThe code starts by importing the `ora` library and creating a singleton spinner instance with the 'dots' style. This ensures that there will only be one spinner active at any given time.\\n\\nThere are several functions exported by this module to interact with the spinner:\\n\\n1. `updateSpinnerText(message: string)`: This function updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\\n\\n   Example usage:\\n   ```javascript\\n   updateSpinnerText('Loading data...');\\n   ```\\n\\n2. `stopSpinner()`: This function stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["515", {"page_content": "This function stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   stopSpinner();\\n   ```\\n\\n3. `spinnerError(message?: string)`: This function stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerError('Failed to load data');\\n   ```\\n\\n4. `spinnerSuccess(message?: string)`: This function stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerSuccess('Data loaded successfully');\\n   ```\\n\\n5. `spinnerInfo(message: string)`: This function displays an informational message without affecting the spinner's state.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerInfo('Connecting to server...');\\n   ```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["516", {"page_content": "```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["517", {"page_content": "\"questions\": \"1. **What is the purpose of the `ora` package in this code?**\\n\\n   The `ora` package is used to create a spinner in the command line interface, providing a visual indication of a running process. In this code, it is used to create a singleton spinner with the 'dots' style.\\n\\n2. **How does the `updateSpinnerText` function work?**\\n\\n   The `updateSpinnerText` function takes a message as an input and updates the spinner's text with the given message. If the spinner is already spinning, it updates the text directly; otherwise, it starts the spinner with the new message.\\n\\n3. **What are the differences between `spinnerError`, `spinnerSuccess`, and `spinnerInfo` functions?**\\n\\n   These functions are used to update the spinner's state and message based on the outcome of a process. `spinnerError` is called when there is an error, and it stops the spinner with a failure message. `spinnerSuccess` is called when the process is successful, and it stops the spinner with a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["518", {"page_content": "message. `spinnerSuccess` is called when the process is successful, and it stops the spinner with a success message. `spinnerInfo` is used to display an informational message without stopping the spinner.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["519", {"page_content": "\"checksum\": \"d93ad7e714ce5446916bb1d63cbb6031\"\n    }\n  ],\n  \"folders\": [\n    {\n      \"folderName\": \"commands\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\",\n      \"files\": [],\n      \"folders\": [\n        {\n          \"folderName\": \"estimate\",\n          \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n          \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n          \"files\": [\n            {\n              \"fileName\": \"index.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["520", {"page_content": "\"summary\": \"The `estimate` function in this code is responsible for providing an estimated cost of processing a given repository using the Autodoc project. It takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function starts by constructing the path to the JSON output directory, which will be used to store the intermediate results of the processing. It then updates the spinner text to indicate that the cost estimation is in progress.\\n\\nNext, the `processRepository` function is called with the provided configuration options and a `true` flag to indicate that this is a dry run. This means that the repository will not actually be processed, but the function will return the details of what would happen if it were processed. This is used to calculate the estimated cost of processing the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["521", {"page_content": "would happen if it were processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce the dry run is complete, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is then calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in a red color. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["522", {"page_content": "'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["523", {"page_content": "\"questions\": \"1. **What is the purpose of the `estimate` function?**\\n\\n   The `estimate` function is used to perform a dry run of the `processRepository` command to get an estimated price for indexing the given repository. It then prints the model details and the total estimated cost.\\n\\n2. **What are the parameters passed to the `processRepository` function?**\\n\\n   The `processRepository` function is called with an object containing the following properties: `name`, `repositoryUrl`, `root`, `output`, `llms`, `ignore`, `filePrompt`, `folderPrompt`, `chatPrompt`, `contentType`, `targetAudience`, and `linkHosted`. Additionally, a second argument `true` is passed to indicate that it's a dry run.\\n\\n3. **How is the total estimated cost calculated and displayed?**\\n\\n   The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes an array of values from the `runDetails` object. The cost is then displayed using `console.log` with", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["524", {"page_content": "array of values from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for formatting, showing the cost with two decimal places and a note that the actual cost may vary.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["525", {"page_content": "\"checksum\": \"2b0b3903432ae423bbc597d04b052ecb\"\n            }\n          ],\n          \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["526", {"page_content": "\"summary\": \"The `estimate` function in `index.ts` is a crucial part of the Autodoc project, as it provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input, containing various configuration options such as repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function begins by constructing the path to the JSON output directory, which stores intermediate results of the processing. It then updates the spinner text to indicate that cost estimation is in progress. The `processRepository` function is called with the provided configuration options and a `true` flag, signifying a dry run. This dry run returns the details of what would happen if the repository were processed, which is used to calculate the estimated cost.\\n\\nUpon completion of the dry run, the spinner is updated to show success, and the results are printed using the `printModelDetails`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["527", {"page_content": "the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in red. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["528", {"page_content": "true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["529", {"page_content": "\"questions\": \"\",\n          \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n        },\n        {\n          \"folderName\": \"index\",\n          \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n          \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n          \"files\": [\n            {\n              \"fileName\": \"convertJsonToMarkdown.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["530", {"page_content": "\"summary\": \"The `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\\n\\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation generation process.\\n\\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.\\n\\nNext, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if so,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["531", {"page_content": "and converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\\n\\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\\n\\nExample usage:\\n\\n```javascript\\nconvertJsonToMarkdown({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will convert all JSON files in the `./input` directory into Markdown files", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["532", {"page_content": "will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["533", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.\\n\\n2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["534", {"page_content": "code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["535", {"page_content": "\"checksum\": \"79c860becf47b9882441682f0213d534\"\n            },\n            {\n              \"fileName\": \"createVectorStore.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["536", {"page_content": "\"summary\": \"The code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\\n\\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.\\n\\nThe `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["537", {"page_content": "object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.\\n\\nThe `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["538", {"page_content": "path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output: './data/vector_store',\\n};\\n\\ncreateVectorStore(config).then(() => {\\n  console.log('Vector store created successfully');\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["539", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processFile` function and what does it return?\\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\\n\\n2. **Question:** How does the `processDirectory` function work and what does it return?\\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.\\n\\n3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["540", {"page_content": "how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["541", {"page_content": "\"checksum\": \"a3409c4340753a867c72eebef7626fb9\"\n            },\n            {\n              \"fileName\": \"index.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\index.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["542", {"page_content": "\"summary\": \"The code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\\n\\nThe `index` function performs three main tasks:\\n\\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Processing repository...');\\n   await processRepository({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["543", {"page_content": "```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Creating markdown files...');\\n   await convertJsonToMarkdown({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Create vector files...');\\n   await createVectorStore({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\nThroughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["544", {"page_content": "the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\\n\\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["545", {"page_content": "\"questions\": \"1. **What does the `index` function do in this code?**\\n\\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\\n\\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**\\n\\n   The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\\n\\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\\n\\n   These prompts are likely used to interact with the user during the processing of the repository.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["546", {"page_content": "These prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["547", {"page_content": "\"checksum\": \"4060b1affae5a6c385cda308b3cd1750\"\n            },\n            {\n              \"fileName\": \"processRepository.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["548", {"page_content": "\"summary\": \"The `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.\\n\\nThe function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The results", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["549", {"page_content": "input length, and calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\\n\\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.\\n\\nThe main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\\n\\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["550", {"page_content": "while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or folder.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["551", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.\\n\\n2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and need", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["552", {"page_content": "for the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.\\n\\n3. **Question:** How does the `reindexCheck` function work and when is it used?\\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["553", {"page_content": "\"checksum\": \"5b3ae9ffad1d4b4a22c6f7fd66bbde6f\"\n            },\n            {\n              \"fileName\": \"prompts.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["554", {"page_content": "\"summary\": \"This code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\\n\\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\\n```\\n\\n2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code file.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["555", {"page_content": "This function generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\\n```\\n\\n3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["556", {"page_content": "function returns a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\\n```\\n\\nThese functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["557", {"page_content": "\"questions\": \"1. **What is the purpose of the `createCodeFileSummary` function?**\\n\\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\\n\\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\\n\\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\\n\\n3. **What is the role of the `folderSummaryPrompt` function?**\\n\\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["558", {"page_content": "\"checksum\": \"e44b82bf4912be69149685a997b6bde3\"\n            }\n          ],\n          \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["559", {"page_content": "\"summary\": \"The code in this folder is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It consists of several functions and utilities that work together to automate the documentation generation process.\\n\\nThe main function, `index`, takes an `AutodocRepoConfig` object as input, which contains various configuration options for processing the repository. It performs three main tasks:\\n\\n1. **Process the repository**: It calls the `processRepository` function to traverse the repository, generate summaries and questions for code files and folders using the LLMS (Language Learning Management System), and create JSON files with the results. These JSON files are stored in the `output/docs/json/` directory.\\n\\n2. **Create Markdown files**: It uses the `convertJsonToMarkdown` function to convert the generated JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["560", {"page_content": "JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n3. **Create vector files**: It calls the `createVectorStore` function to create vector files from the generated Markdown files. These vector files are stored in the `output/docs/data/` directory.\\n\\nThroughout the execution of these tasks, the code provides visual feedback on the progress of the tasks using `updateSpinnerText` and `spinnerSuccess` functions.\\n\\nHere's an example of how this code might be used:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will process the repository located at `./input`, generate documentation in JSON, Markdown, and vector formats, and save the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["561", {"page_content": "vector formats, and save the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains utility functions that generate prompts for documentation experts. These functions create markdown formatted strings with specific instructions for the documentation expert, ensuring consistent formatting and instructions across different parts of the project.\\n\\nIn summary, the code in this folder automates the process of generating documentation for a given repository based on the provided configuration options. The generated documentation can be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["562", {"page_content": "\"questions\": \"\",\n          \"checksum\": \"376f96417f8cbea6a5ab2463268fe4af\"\n        },\n        {\n          \"folderName\": \"init\",\n          \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n          \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n          \"files\": [\n            {\n              \"fileName\": \"index.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\init\\\\index.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\init\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["563", {"page_content": "\"summary\": \"This code is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["564", {"page_content": "the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["565", {"page_content": "configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["566", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc project. It takes an optional `config` parameter of type `AutodocRepoConfig` and returns a new configuration object with default values for various properties.\\n\\n2. **How does the `init` function work and when is it called?**\\n\\n   The `init` function is an asynchronous function that initializes the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It takes an optional `config` parameter of type `AutodocRepoConfig` and prompts the user for input to set the configuration values. It is called when the user wants to set up the Autodoc configuration for their project.\\n\\n3. **What is the purpose of the `inquirer.prompt` calls in the `init` function?**\\n\\n   The `inquirer.prompt` calls are used to interactively prompt the user for input to set the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["567", {"page_content": "The `inquirer.prompt` calls are used to interactively prompt the user for input to set the configuration values for the Autodoc project. The user is asked for the repository name, repository URL, and the LLMs they have access to. The input is then used to create a new configuration object and write it to the `autodoc.config.json` file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["568", {"page_content": "\"checksum\": \"b93831ff1f4023ab61c3bea963a8a112\"\n            }\n          ],\n          \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["569", {"page_content": "\"summary\": \"The `index.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init` folder is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["570", {"page_content": "want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["571", {"page_content": "values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\nThis code is essential for setting up the Autodoc project, as it creates the necessary configuration file and gathers user input to customize the project. It works in conjunction with other parts of the project, such as the CLI and the documentation generation process, which rely on the configuration file to function correctly.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["572", {"page_content": "\"questions\": \"\",\n          \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n        },\n        {\n          \"folderName\": \"query\",\n          \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n          \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n          \"files\": [\n            {\n              \"fileName\": \"createChatChain.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["573", {"page_content": "\"summary\": \"This code defines a function `makeChain` that creates a chatbot for answering questions about a software project called `projectName`. The chatbot is trained on the content of the project, which is located at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters:\\n\\n- `projectName`: The name of the software project.\\n- `repositoryUrl`: The URL of the project's repository.\\n- `contentType`: The type of content the chatbot is trained on.\\n- `chatPrompt`: Additional instructions for answering questions about the content type.\\n- `targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["574", {"page_content": "`targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for efficient nearest neighbor search.\\n- `llms`: An array of LLMModels, which are language models used for generating answers.\\n- `onTokenStream`: An optional callback function that is called when a new token is generated by the language model.\\n\\nThe `makeChain` function first creates a question generator using the `LLMChain` class. This generator is responsible for rephrasing follow-up questions to be standalone questions. It uses the `CONDENSE_PROMPT` template, which is defined at the beginning of the code.\\n\\nNext, the function creates a `QA_PROMPT` template using the `makeQAPrompt` function. This template is used to generate answers to the questions in a conversational manner, with hyperlinks back to GitHub and code examples where appropriate.\\n\\nFinally, the function creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["575", {"page_content": "creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project. The chatbot uses the `vectorstore` for efficient nearest neighbor search and the `llms` language models for generating answers. If the `onTokenStream` callback is provided, it will be called when a new token is generated by the language model.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["576", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `makeChain` function and what are its input parameters?\\n\\n   **Answer:** The `makeChain` function is used to create a `ChatVectorDBQAChain` instance, which is responsible for generating questions and answers based on the given input parameters. The input parameters include `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and an optional `onTokenStream` function.\\n\\n2. **Question:** What are the roles of `CONDENSE_PROMPT` and `QA_PROMPT` in this code?\\n\\n   **Answer:** `CONDENSE_PROMPT` is a template for generating standalone questions from a given chat history and follow-up question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to GitHub, based on the provided context and question. Both templates are used in the `LLMChain` and `loadQAChain` instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["577", {"page_content": "instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and when is it used?\\n\\n   **Answer:** The `onTokenStream` function is an optional callback that can be provided to the `makeChain` function. It is used to handle the streaming of tokens generated by the OpenAIChat instance. If provided, it will be called with each new token generated during the chat process.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["578", {"page_content": "\"checksum\": \"6869048a06de62499933b14c37cddc1d\"\n            },\n            {\n              \"fileName\": \"index.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\index.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["579", {"page_content": "\"summary\": \"This code defines a chatbot interface for the Autodoc project, which allows users to ask questions related to a specific codebase and receive answers in a conversational manner. The chatbot uses a combination of the `inquirer` library for user input, `marked` and `marked-terminal` for rendering Markdown output, and the `langchain` library for handling natural language processing tasks.\\n\\nThe `query` function is the main entry point for the chatbot. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store using the `HNSWLib` and `OpenAIEmbeddings` classes, and creates a chat chain using the `makeChain` function.\\n\\nThe chatbot interface is displayed using the `displayWelcomeMessage` function, which prints a welcome message to the console. The `getQuestion` function is used to prompt the user for a question", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["580", {"page_content": "message to the console. The `getQuestion` function is used to prompt the user for a question using the `inquirer` library. The chatbot then enters a loop, where it processes the user's question, generates a response using the chat chain, and displays the response as Markdown in the terminal.\\n\\nIf an error occurs during the processing of a question, the chatbot will display an error message and continue to prompt the user for a new question. The loop continues until the user types 'exit', at which point the chatbot terminates.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["581", {"page_content": "userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example would initialize the chatbot with the specified repository and user configurations, and start the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["582", {"page_content": "\"questions\": \"1. **What is the purpose of the `query` function in this code?**\\n\\n   The `query` function is responsible for handling user interactions with the chatbot. It takes in an AutodocRepoConfig object and an AutodocUserConfig object, sets up the necessary data structures, and then enters a loop where it prompts the user for questions, processes them, and displays the results.\\n\\n2. **How does the code handle rendering Markdown text in the terminal?**\\n\\n   The code uses the `marked` library along with a custom `TerminalRenderer` to render Markdown text in the terminal. The `marked` library is configured with the custom renderer using `marked.setOptions({ renderer: new TerminalRenderer() });`.\\n\\n3. **What is the purpose of the `chatHistory` variable and how is it used?**\\n\\n   The `chatHistory` variable is an array that stores the history of questions and answers in the chat session. It is used to keep track of the conversation between the user and the chatbot.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["583", {"page_content": "in the chat session. It is used to keep track of the conversation between the user and the chatbot. When a new question is asked, the chat history is passed to the `chain.call()` function, and the new question and its corresponding answer are added to the `chatHistory` array.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["584", {"page_content": "\"checksum\": \"19807a33957666422f31136970c37245\"\n            }\n          ],\n          \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["585", {"page_content": "\"summary\": \"The `query` folder in the Autodoc project contains code for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot is trained on the content of the project and provides answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate.\\n\\nThe main entry point for the chatbot is the `query` function in `index.ts`. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store and creates a chat chain using the `makeChain` function from `createChatChain.ts`.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["586", {"page_content": "'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example initializes the chatbot with the specified repository and user configurations and starts the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\\n\\nThe `createChatChain.ts` file defines the `makeChain` function, which creates a chatbot for answering questions about a software project. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["587", {"page_content": "takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and `onTokenStream`. It first creates a question generator using the `LLMChain` class, then creates a `QA_PROMPT` template using the `makeQAPrompt` function, and finally creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project.\\n\\nIn summary, the code in the `query` folder is responsible for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot uses a combination of natural language processing techniques and efficient nearest neighbor search to generate accurate and relevant answers for the user.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["588", {"page_content": "\"questions\": \"\",\n          \"checksum\": \"9e0d0f111bf588e2df66862dce9db288\"\n        },\n        {\n          \"folderName\": \"user\",\n          \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n          \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n          \"files\": [\n            {\n              \"fileName\": \"index.ts\",\n              \"filePath\": \"src\\\\cli\\\\commands\\\\user\\\\index.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\user\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["589", {"page_content": "\"summary\": \"This code is responsible for managing the user configuration for the Autodoc project. It provides a way to create, update, and save the user configuration file, which stores information about the user's access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function is used to create a default configuration object with the provided `config` parameter or with GPT-3 as the default LLM. This function is used to generate a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["590", {"page_content": "exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["591", {"page_content": "user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["592", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc user. It takes an optional `config` parameter and returns an object with a `llms` property, which is an array of LLM models.\\n\\n2. **How does the `user` function handle existing user configuration files?**\\n\\n   The `user` function checks if a user configuration file already exists using `fsSync.existsSync`. If it does, the user is prompted with a confirmation message to overwrite the existing configuration. If the user chooses not to overwrite, the process exits with a status code of 0.\\n\\n3. **What are the available choices for LLM models in the `user` function?**\\n\\n   The available choices for LLM models are GPT-3.5 Turbo, GPT-3.5 Turbo and GPT-4 8K (Early Access), and GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["593", {"page_content": "8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected value is stored in the `llms` property of the new configuration object.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["594", {"page_content": "\"checksum\": \"76bc1e6d5d61e24907832c4cac443225\"\n            }\n          ],\n          \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["595", {"page_content": "\"summary\": \"The `index.ts` file in the `user` folder is responsible for managing the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with either the provided `config` parameter or GPT-3 as the default LLM. This function is useful for generating a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["596", {"page_content": "process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nThis code is essential for the Autodoc project as it allows users to manage their access to different LLMs and store their preferences in a configuration file. This configuration file can", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["597", {"page_content": "to different LLMs and store their preferences in a configuration file. This configuration file can then be used by other parts of the project to determine which LLMs the user has access to and tailor the querying process accordingly.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the `index.ts` file in the `user` folder is a crucial part of the Autodoc project, allowing users to manage their LLM access and preferences. This configuration is then used by other parts of the project to provide a tailored experience based on the user's access to different LLMs.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["598", {"page_content": "\"questions\": \"\",\n          \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n        }\n      ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["599", {"page_content": "\"summary\": \"The code in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands` folder is responsible for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project. The folder contains several subfolders, each with a specific purpose.\\n\\n### estimate\\n\\nThe `estimate` function provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input and performs a dry run of the repository processing to calculate the estimated cost. Example usage:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["600", {"page_content": "filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\n### index\\n\\nThe code in this folder processes a given repository and generates documentation in JSON, Markdown, and vector formats. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository, creating Markdown files, and creating vector files. Example usage:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\n### init\\n\\nThe `init` function initializes the configuration of the Autodoc project. It prompts the user to input necessary information to set up the project and creates the `autodoc.config.json` file in the project root. Example", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["601", {"page_content": "to set up the project and creates the `autodoc.config.json` file in the project root. Example usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\n### query\\n\\nThe `query` folder contains code for creating a chatbot that can answer questions about a specific software project. The main entry point is the `query` function, which takes an `AutodocRepoConfig` object and an `AutodocUserConfig` object as input. Example usage:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["602", {"page_content": "'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\n### user\\n\\nThe `user` folder manages the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs). Example usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the code in this folder is essential for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["603", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"d11f941351fb51140313ada9b52bbf1a\"\n    },\n    {\n      \"folderName\": \"utils\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils\",\n      \"files\": [\n        {\n          \"fileName\": \"APIRateLimit.ts\",\n          \"filePath\": \"src\\\\cli\\\\utils\\\\APIRateLimit.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\APIRateLimit.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["604", {"page_content": "\"summary\": \"The `APIRateLimit` class in this code snippet is designed to manage and limit the number of concurrent API calls made by the application. This is useful in situations where the API being called has a rate limit or when the application needs to prevent overwhelming the server with too many requests at once.\\n\\nThe class constructor takes an optional parameter `maxConcurrentCalls`, which defaults to 50, to set the maximum number of concurrent API calls allowed. It maintains a queue of API calls and keeps track of the number of calls in progress.\\n\\nThe main method of this class is `callApi<T>(apiFunction: () => Promise<T>): Promise<T>`. It takes a function `apiFunction` that returns a promise and wraps it in a new promise. The purpose of this wrapping is to control the execution of the API calls and ensure that they do not exceed the specified rate limit.\\n\\nWhen `callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["605", {"page_content": "`callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is triggered if there are available slots for concurrent calls. The `dequeueAndExecute` method checks if there are any API calls in the queue and if the number of in-progress calls is below the maximum limit. If both conditions are met, it dequeues the next API call and executes it.\\n\\nThe `executeCall` function inside `callApi` is responsible for actually calling the API function, resolving or rejecting the promise based on the result, and updating the number of in-progress calls. Once an API call is completed, the `dequeueAndExecute` method is called again to process any remaining calls in the queue.\\n\\nHere's an example of how this class can be used in the larger project:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\n\\nasync function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["606", {"page_content": "function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls to the `fetch` function, ensuring that no more than 10 calls are made at once.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["607", {"page_content": "\"questions\": \"1. **What is the purpose of the `APIRateLimit` class?**\\n\\n   The `APIRateLimit` class is designed to manage and limit the number of concurrent API calls to a specified maximum, preventing the application from overwhelming the API with too many requests at once.\\n\\n2. **How does the `callApi` method work and what is its return type?**\\n\\n   The `callApi` method takes an `apiFunction` as an argument, which is a function that returns a Promise. It adds the API call to a queue and executes it when there are available slots for concurrent calls. The method returns a Promise of type `T`, where `T` is the expected return type of the `apiFunction`.\\n\\n3. **How can the maximum number of concurrent calls be configured?**\\n\\n   The maximum number of concurrent calls can be configured by passing a value to the `maxConcurrentCalls` parameter in the constructor of the `APIRateLimit` class. If no value is provided, the default value is set to 50.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["608", {"page_content": "\"checksum\": \"8862552c9cfd8b6db454d45e565081ef\"\n        },\n        {\n          \"fileName\": \"FileUtil.ts\",\n          \"filePath\": \"src\\\\cli\\\\utils\\\\FileUtil.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\FileUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["609", {"page_content": "\"summary\": \"This code provides utility functions for handling file and folder paths in the autodoc project. The main purpose of these functions is to generate file names and GitHub URLs for documentation files.\\n\\n1. `getFileName(input, delimiter, extension)`: This function takes an input string, an optional delimiter (default is '.'), and an optional extension (default is '.md'). It returns a new string with the given extension. If the delimiter is found in the input string, the function removes the part of the string after the last occurrence of the delimiter and appends the extension. If the delimiter is not found, the function simply appends the extension to the input string. This function can be used to generate file names for documentation files with the desired extension.\\n\\n   Example usage:\\n\\n   ```\\n   getFileName('example.txt'); // returns 'example.md'\\n   getFileName('example', '_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["610", {"page_content": "'_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot, inputRoot, filePath, linkHosted)`: This function generates a GitHub URL for a file. It takes the GitHub repository root URL, the input root folder path, the file path, and a boolean flag indicating whether the URL should be for the hosted version of the file or the source code. It returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true);\\n   // returns 'https://github.com/user/repo/example.md'\\n   ```\\n\\n3. `githubFolderUrl(githubRoot, inputRoot, folderPath, linkHosted)`: This function is similar to `githubFileUrl`, but it generates a GitHub URL for a folder instead of a file. It takes the same arguments as `githubFileUrl` and returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["611", {"page_content": "githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns 'https://github.com/user/repo/folder'\\n   ```\\n\\nThese utility functions can be used throughout the autodoc project to generate file names and GitHub URLs for documentation files and folders, ensuring consistent naming and URL generation across the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["612", {"page_content": "\"questions\": \"1. **What is the purpose of the `getFileName` function?**\\n\\n   The `getFileName` function takes an input string, an optional delimiter, and an optional extension, and returns a new string with the given extension. If the delimiter is not found in the input string, the extension is simply appended to the input string. If the delimiter is found, the input string is sliced up to the last delimiter index and the extension is appended.\\n\\n2. **What are the differences between the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   Both functions take the same parameters: `githubRoot`, `inputRoot`, a path (either `filePath` or `folderPath`), and a `linkHosted` boolean. The main difference is in the returned URL: `githubFileUrl` returns a URL pointing to a file in the GitHub repository, while `githubFolderUrl` returns a URL pointing to a folder in the GitHub repository. The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["613", {"page_content": "The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for folders.\\n\\n3. **What is the purpose of the `linkHosted` parameter in the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   The `linkHosted` parameter is a boolean that determines whether the returned URL should point to the hosted version of the file or folder on GitHub Pages (if `true`) or to the file or folder within the GitHub repository itself (if `false`). Depending on the value of `linkHosted`, the functions will return different URL structures.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["614", {"page_content": "\"checksum\": \"d1f26fc674b4a9b4a2053642771871c8\"\n        },\n        {\n          \"fileName\": \"LLMUtil.ts\",\n          \"filePath\": \"src\\\\cli\\\\utils\\\\LLMUtil.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\LLMUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["615", {"page_content": "\"summary\": \"This code defines and manages different language models (LLMs) and their associated costs for a project that utilizes OpenAI's GPT models. It imports the `OpenAIChat` class from the `langchain/llms` module and the `LLMModelDetails` and `LLMModels` types from the `../../types.js` file.\\n\\nThe `models` object contains three LLMs: GPT3, GPT4, and GPT432k. Each model has its own properties, such as `name`, `inputCostPer1KTokens`, `outputCostPer1KTokens`, `maxLength`, and an instance of the `OpenAIChat` class with the respective model name and API key. Additionally, each model has counters for input tokens, output tokens, succeeded, failed, and total files processed.\\n\\nThe `printModelDetails` function takes an array of `LLMModelDetails` and prints a summary table to the console. It calculates the total cost for each model based on the input and output tokens and their respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["616", {"page_content": "respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens, and cost across all models.\\n\\nThe `totalIndexCostEstimate` function calculates the total cost of indexing all models in the input array. It uses the same cost calculation as in `printModelDetails` but returns the total cost as a number.\\n\\nThese functions can be used in the larger project to manage and analyze the usage and costs of different LLMs. For example, the `printModelDetails` function can be called to display a summary of the models' usage and costs:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nprintModelDetails(Object.values(models));\\n```\\n\\nAnd the `totalIndexCostEstimate` function can be used to estimate the total cost of indexing all models:\\n\\n```javascript\\nimport { models, totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["617", {"page_content": "{ models, totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["618", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `models` object and how are the different GPT models being used?\\n   **Answer:** The `models` object is a record that maps different GPT models (GPT3, GPT4, and GPT432k) to their respective details, such as cost per tokens, maximum length, and an instance of `OpenAIChat` with the corresponding model configuration.\\n\\n2. **Question:** How does the `printModelDetails` function work and what information does it display?\\n   **Answer:** The `printModelDetails` function takes an array of `LLMModelDetails` as input, processes the information for each model, and then prints a summary table to the console. The table includes the model name, file count, succeeded and failed counts, total tokens, and cost.\\n\\n3. **Question:** What is the purpose of the `totalIndexCostEstimate` function and how is it calculating the total cost?\\n   **Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["619", {"page_content": "**Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the given models by iterating through the input `models` array and summing up the costs based on the input and output tokens and their respective costs per 1K tokens.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["620", {"page_content": "\"checksum\": \"f4464cf197f4af827ac0eac950d568fc\"\n        },\n        {\n          \"fileName\": \"traverseFileSystem.ts\",\n          \"filePath\": \"src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["621", {"page_content": "\"summary\": \"The `traverseFileSystem` function in this code is an asynchronous function that recursively traverses a given file system, processing files and folders based on the provided parameters. It is designed to be used in the larger project for generating documentation or performing other tasks that require processing files and folders in a directory structure.\\n\\nThe function takes an object of type `TraverseFileSystemParams` as its input, which contains various properties to control the traversal and processing behavior. These properties include:\\n\\n- `inputPath`: The root path to start the traversal from.\\n- `projectName`: The name of the project being processed.\\n- `processFile`: An optional callback function to process a file.\\n- `processFolder`: An optional callback function to process a folder.\\n- `ignore`: An array of patterns to ignore during traversal.\\n- `filePrompt`, `folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["622", {"page_content": "`folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`, `linkHosted`: Additional metadata for processing.\\n\\nThe function first checks if the provided `inputPath` exists using `fs.access`. If the path does not exist, it logs an error message and returns. It then defines a helper function `shouldIgnore` that checks if a given file or folder should be ignored based on the `ignore` patterns.\\n\\nThe main logic of the function is implemented in the `dfs` (depth-first search) function, which is called recursively to traverse the file system. It reads the contents of the current directory using `fs.readdir`, filters out ignored items, and processes the remaining items.\\n\\nFor each item, if it is a directory, the `dfs` function is called recursively, and the `processFolder` callback is invoked if provided. If it is a file and its content is text (checked using `isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["623", {"page_content": "`isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using `Promise.all` to process items concurrently, improving performance. If an error occurs during traversal, it is logged and rethrown.\\n\\nHere's an example of how this function might be used in the larger project:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => {\\n    // Process file logic here\\n  },\\n  processFolder: (params) => {\\n    // Process folder logic here\\n  },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["624", {"page_content": "\"questions\": \"1. **What is the purpose of the `traverseFileSystem` function?**\\n\\n   The `traverseFileSystem` function is an asynchronous function that traverses a given file system, processes folders and files based on the provided parameters, and ignores files and folders based on the given ignore patterns.\\n\\n2. **How does the `shouldIgnore` function work?**\\n\\n   The `shouldIgnore` function takes a file name as input and returns a boolean value indicating whether the file should be ignored or not. It checks if the file name matches any of the ignore patterns provided in the `ignore` parameter using the `minimatch` library.\\n\\n3. **What is the role of the `dfs` function inside `traverseFileSystem`?**\\n\\n   The `dfs` function is an asynchronous function that performs a depth-first search on the file system starting from the given `currentPath`. It processes folders and files based on the provided parameters and recursively calls itself for each subdirectory found.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["625", {"page_content": "\"checksum\": \"b9e957c10ee6c009864c90aa2fa93763\"\n        },\n        {\n          \"fileName\": \"WaitUtil.ts\",\n          \"filePath\": \"src\\\\cli\\\\utils\\\\WaitUtil.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\WaitUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["626", {"page_content": "\"summary\": \"The code in this file provides two utility functions, `wait` and `forTrue`, which are designed to help manage asynchronous operations in the larger project. Both functions return a `Promise`, making them suitable for use with `async/await` syntax.\\n\\n### wait\\n\\nThe `wait` function takes two arguments: `timeoutMs`, a number representing the desired waiting time in milliseconds, and an optional `value` that defaults to `null`. It returns a `Promise` that resolves with the provided `value` after the specified `timeoutMs` has elapsed. This function can be used to introduce a delay in the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\ndelayedEcho(); // Output: Start -> (1 second delay) -> End\\n```\\n\\n### forTrue\\n\\nThe `forTrue` function takes a single argument, `fn`, which is a function that returns a boolean value. It returns", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["627", {"page_content": "takes a single argument, `fn`, which is a function that returns a boolean value. It returns a `Promise` that resolves with `true` when the provided function `fn` returns `true`. The function `fn` is checked every 50 milliseconds, up to a maximum of 200 times (i.e., 10 seconds). If `fn` does not return `true` within this time, the `Promise` is rejected.\\n\\nThis function can be used to wait for a specific condition to be met before continuing the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nlet condition = false;\\n\\nsetTimeout(() => {\\n  condition = true;\\n}, 3000);\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n\\nwaitForCondition(); // Output: Waiting for condition... -> (3 second delay) -> Condition met!\\n```\\n\\nIn summary, this file provides two utility functions that help manage asynchronous operations by introducing delays and waiting for specific", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["628", {"page_content": "functions that help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used in the larger project to control the flow of asynchronous code execution.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["629", {"page_content": "\"questions\": \"1. **What is the purpose of the `wait` function?**\\n\\n   The `wait` function is an asynchronous utility function that resolves a promise after a specified timeout in milliseconds, optionally returning a value when the promise is resolved.\\n\\n2. **How does the `forTrue` function work?**\\n\\n   The `forTrue` function takes a function `fn` as an argument, which should return a boolean value. It checks the result of `fn` every 50 milliseconds and resolves the promise when `fn` returns `true`. If `fn` does not return `true` after 200 attempts, the promise is rejected.\\n\\n3. **What is the use case for the `forTrue` function?**\\n\\n   The `forTrue` function can be used to wait for a certain condition to be met before proceeding with the execution of the code. This can be useful in situations where you need to wait for an asynchronous operation to complete or a specific state to be reached before continuing.\",\n          \"checksum\": \"bf4acebb6c2736274af75a8c8441c9d2\"", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["630", {"page_content": "\"checksum\": \"bf4acebb6c2736274af75a8c8441c9d2\"\n        }\n      ],\n      \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["631", {"page_content": "\"summary\": \"The `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils` folder contains utility functions and classes that assist in managing API rate limits, handling file and folder paths, managing language models, traversing file systems, and controlling asynchronous operations. These utilities can be used throughout the autodoc project to ensure consistent behavior and improve code organization.\\n\\n`APIRateLimit.ts` provides the `APIRateLimit` class, which manages and limits the number of concurrent API calls made by the application. This is useful when working with rate-limited APIs or preventing server overload. Example usage:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\nasync function fetchSomeData(id) {\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\n`FileUtil.ts` offers utility functions for generating file names and GitHub URLs for documentation files.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["632", {"page_content": "offers utility functions for generating file names and GitHub URLs for documentation files. These functions ensure consistent naming and URL generation across the project. Example usage:\\n\\n```javascript\\ngetFileName('example.txt'); // returns 'example.md'\\ngithubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true); // returns 'https://github.com/user/repo/example.md'\\n```\\n\\n`LLMUtil.ts` defines and manages different language models (LLMs) and their associated costs for a project utilizing OpenAI's GPT models. Functions like `printModelDetails` and `totalIndexCostEstimate` can be used to manage and analyze the usage and costs of different LLMs. Example usage:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\nprintModelDetails(Object.values(models));\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\\n\\n`traverseFileSystem.ts` contains the `traverseFileSystem`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["633", {"page_content": "cost: ${totalCost}`);\\n```\\n\\n`traverseFileSystem.ts` contains the `traverseFileSystem` function, which recursively traverses a given file system, processing files and folders based on provided parameters. This is useful for generating documentation or performing tasks that require processing files and folders in a directory structure. Example usage:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => { /* Process file logic */ },\\n  processFolder: (params) => { /* Process folder logic */ },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\\n\\n`WaitUtil.ts` provides two utility functions, `wait` and `forTrue`, which help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used to control the flow of asynchronous code execution. Example usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["634", {"page_content": "function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n```\\n\\nIn summary, the utilities in this folder enhance the autodoc project by providing consistent behavior, improving code organization, and managing various aspects of the project, such as API rate limits, file and folder paths, language models, file system traversal, and asynchronous operations.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["635", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"a4b7088863601cd326edbec7726eefe7\"\n    }\n  ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["636", {"page_content": "\"summary\": \"The code in the `spinner.ts` file, located in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli` folder, is responsible for managing a spinner, a visual element that indicates a background process is running. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\\n\\nThe module exports several functions to interact with the spinner:\\n\\n1. `updateSpinnerText(message: string)`: Updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\\n\\n   Example usage:\\n   ```javascript\\n   updateSpinnerText('Loading data...');\\n   ```\\n\\n2. `stopSpinner()`: Stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   stopSpinner();\\n   ```\\n\\n3. `spinnerError(message?: string)`: Stops the spinner and marks it as failed with an optional error message. It only takes effect if", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["637", {"page_content": "Stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerError('Failed to load data');\\n   ```\\n\\n4. `spinnerSuccess(message?: string)`: Stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerSuccess('Data loaded successfully');\\n   ```\\n\\n5. `spinnerInfo(message: string)`: Displays an informational message without affecting the spinner's state.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerInfo('Connecting to server...');\\n   ```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["638", {"page_content": "By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["639", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"e9d728bc3244f1081af08994f5fb1cd0\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/summary.json"}, "type": "Document"}], ["640", {"page_content": "{\n  \"fileName\": \"traverseFileSystem.ts\",\n  \"filePath\": \"src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/traverseFileSystem.json"}, "type": "Document"}], ["641", {"page_content": "\"summary\": \"The `traverseFileSystem` function in this code is an asynchronous function that recursively traverses a given file system, processing files and folders based on the provided parameters. It is designed to be used in the larger project for generating documentation or performing other tasks that require processing files and folders in a directory structure.\\n\\nThe function takes an object of type `TraverseFileSystemParams` as its input, which contains various properties to control the traversal and processing behavior. These properties include:\\n\\n- `inputPath`: The root path to start the traversal from.\\n- `projectName`: The name of the project being processed.\\n- `processFile`: An optional callback function to process a file.\\n- `processFolder`: An optional callback function to process a folder.\\n- `ignore`: An array of patterns to ignore during traversal.\\n- `filePrompt`, `folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/traverseFileSystem.json"}, "type": "Document"}], ["642", {"page_content": "`folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`, `linkHosted`: Additional metadata for processing.\\n\\nThe function first checks if the provided `inputPath` exists using `fs.access`. If the path does not exist, it logs an error message and returns. It then defines a helper function `shouldIgnore` that checks if a given file or folder should be ignored based on the `ignore` patterns.\\n\\nThe main logic of the function is implemented in the `dfs` (depth-first search) function, which is called recursively to traverse the file system. It reads the contents of the current directory using `fs.readdir`, filters out ignored items, and processes the remaining items.\\n\\nFor each item, if it is a directory, the `dfs` function is called recursively, and the `processFolder` callback is invoked if provided. If it is a file and its content is text (checked using `isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/traverseFileSystem.json"}, "type": "Document"}], ["643", {"page_content": "`isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using `Promise.all` to process items concurrently, improving performance. If an error occurs during traversal, it is logged and rethrown.\\n\\nHere's an example of how this function might be used in the larger project:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => {\\n    // Process file logic here\\n  },\\n  processFolder: (params) => {\\n    // Process folder logic here\\n  },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/traverseFileSystem.json"}, "type": "Document"}], ["644", {"page_content": "\"questions\": \"1. **What is the purpose of the `traverseFileSystem` function?**\\n\\n   The `traverseFileSystem` function is an asynchronous function that traverses a given file system, processes folders and files based on the provided parameters, and ignores files and folders based on the given ignore patterns.\\n\\n2. **How does the `shouldIgnore` function work?**\\n\\n   The `shouldIgnore` function takes a file name as input and returns a boolean value indicating whether the file should be ignored or not. It checks if the file name matches any of the ignore patterns provided in the `ignore` parameter using the `minimatch` library.\\n\\n3. **What is the role of the `dfs` function inside `traverseFileSystem`?**\\n\\n   The `dfs` function is an asynchronous function that performs a depth-first search on the file system starting from the given `currentPath`. It processes folders and files based on the provided parameters and recursively calls itself for each subdirectory found.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/traverseFileSystem.json"}, "type": "Document"}], ["645", {"page_content": "\"checksum\": \"b9e957c10ee6c009864c90aa2fa93763\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/traverseFileSystem.json"}, "type": "Document"}], ["646", {"page_content": "{\n  \"fileName\": \"APIRateLimit.ts\",\n  \"filePath\": \"src\\\\cli\\\\utils\\\\APIRateLimit.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\APIRateLimit.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/APIRateLimit.json"}, "type": "Document"}], ["647", {"page_content": "\"summary\": \"The `APIRateLimit` class in this code snippet is designed to manage and limit the number of concurrent API calls made by the application. This is useful in situations where the API being called has a rate limit or when the application needs to prevent overwhelming the server with too many requests at once.\\n\\nThe class constructor takes an optional parameter `maxConcurrentCalls`, which defaults to 50, to set the maximum number of concurrent API calls allowed. It maintains a queue of API calls and keeps track of the number of calls in progress.\\n\\nThe main method of this class is `callApi<T>(apiFunction: () => Promise<T>): Promise<T>`. It takes a function `apiFunction` that returns a promise and wraps it in a new promise. The purpose of this wrapping is to control the execution of the API calls and ensure that they do not exceed the specified rate limit.\\n\\nWhen `callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/APIRateLimit.json"}, "type": "Document"}], ["648", {"page_content": "is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is triggered if there are available slots for concurrent calls. The `dequeueAndExecute` method checks if there are any API calls in the queue and if the number of in-progress calls is below the maximum limit. If both conditions are met, it dequeues the next API call and executes it.\\n\\nThe `executeCall` function inside `callApi` is responsible for actually calling the API function, resolving or rejecting the promise based on the result, and updating the number of in-progress calls. Once an API call is completed, the `dequeueAndExecute` method is called again to process any remaining calls in the queue.\\n\\nHere's an example of how this class can be used in the larger project:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\n\\nasync function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/APIRateLimit.json"}, "type": "Document"}], ["649", {"page_content": "function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls to the `fetch` function, ensuring that no more than 10 calls are made at once.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/APIRateLimit.json"}, "type": "Document"}], ["650", {"page_content": "\"questions\": \"1. **What is the purpose of the `APIRateLimit` class?**\\n\\n   The `APIRateLimit` class is designed to manage and limit the number of concurrent API calls to a specified maximum, preventing the application from overwhelming the API with too many requests at once.\\n\\n2. **How does the `callApi` method work and what is its return type?**\\n\\n   The `callApi` method takes an `apiFunction` as an argument, which is a function that returns a Promise. It adds the API call to a queue and executes it when there are available slots for concurrent calls. The method returns a Promise of type `T`, where `T` is the expected return type of the `apiFunction`.\\n\\n3. **How can the maximum number of concurrent calls be configured?**\\n\\n   The maximum number of concurrent calls can be configured by passing a value to the `maxConcurrentCalls` parameter in the constructor of the `APIRateLimit` class. If no value is provided, the default value is set to 50.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/APIRateLimit.json"}, "type": "Document"}], ["651", {"page_content": "\"checksum\": \"8862552c9cfd8b6db454d45e565081ef\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/APIRateLimit.json"}, "type": "Document"}], ["652", {"page_content": "{\n  \"fileName\": \"LLMUtil.ts\",\n  \"filePath\": \"src\\\\cli\\\\utils\\\\LLMUtil.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\LLMUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/LLMUtil.json"}, "type": "Document"}], ["653", {"page_content": "\"summary\": \"This code defines and manages different language models (LLMs) and their associated costs for a project that utilizes OpenAI's GPT models. It imports the `OpenAIChat` class from the `langchain/llms` module and the `LLMModelDetails` and `LLMModels` types from the `../../types.js` file.\\n\\nThe `models` object contains three LLMs: GPT3, GPT4, and GPT432k. Each model has its own properties, such as `name`, `inputCostPer1KTokens`, `outputCostPer1KTokens`, `maxLength`, and an instance of the `OpenAIChat` class with the respective model name and API key. Additionally, each model has counters for input tokens, output tokens, succeeded, failed, and total files processed.\\n\\nThe `printModelDetails` function takes an array of `LLMModelDetails` and prints a summary table to the console. It calculates the total cost for each model based on the input and output tokens and their respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens, and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/LLMUtil.json"}, "type": "Document"}], ["654", {"page_content": "costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens, and cost across all models.\\n\\nThe `totalIndexCostEstimate` function calculates the total cost of indexing all models in the input array. It uses the same cost calculation as in `printModelDetails` but returns the total cost as a number.\\n\\nThese functions can be used in the larger project to manage and analyze the usage and costs of different LLMs. For example, the `printModelDetails` function can be called to display a summary of the models' usage and costs:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nprintModelDetails(Object.values(models));\\n```\\n\\nAnd the `totalIndexCostEstimate` function can be used to estimate the total cost of indexing all models:\\n\\n```javascript\\nimport { models, totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/LLMUtil.json"}, "type": "Document"}], ["655", {"page_content": "totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/LLMUtil.json"}, "type": "Document"}], ["656", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `models` object and how are the different GPT models being used?\\n   **Answer:** The `models` object is a record that maps different GPT models (GPT3, GPT4, and GPT432k) to their respective details, such as cost per tokens, maximum length, and an instance of `OpenAIChat` with the corresponding model configuration.\\n\\n2. **Question:** How does the `printModelDetails` function work and what information does it display?\\n   **Answer:** The `printModelDetails` function takes an array of `LLMModelDetails` as input, processes the information for each model, and then prints a summary table to the console. The table includes the model name, file count, succeeded and failed counts, total tokens, and cost.\\n\\n3. **Question:** What is the purpose of the `totalIndexCostEstimate` function and how is it calculating the total cost?\\n   **Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the given models", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/LLMUtil.json"}, "type": "Document"}], ["657", {"page_content": "The `totalIndexCostEstimate` function calculates the total cost of processing the given models by iterating through the input `models` array and summing up the costs based on the input and output tokens and their respective costs per 1K tokens.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/LLMUtil.json"}, "type": "Document"}], ["658", {"page_content": "\"checksum\": \"f4464cf197f4af827ac0eac950d568fc\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/LLMUtil.json"}, "type": "Document"}], ["659", {"page_content": "{\n  \"fileName\": \"FileUtil.ts\",\n  \"filePath\": \"src\\\\cli\\\\utils\\\\FileUtil.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\FileUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/FileUtil.json"}, "type": "Document"}], ["660", {"page_content": "\"summary\": \"This code provides utility functions for handling file and folder paths in the autodoc project. The main purpose of these functions is to generate file names and GitHub URLs for documentation files.\\n\\n1. `getFileName(input, delimiter, extension)`: This function takes an input string, an optional delimiter (default is '.'), and an optional extension (default is '.md'). It returns a new string with the given extension. If the delimiter is found in the input string, the function removes the part of the string after the last occurrence of the delimiter and appends the extension. If the delimiter is not found, the function simply appends the extension to the input string. This function can be used to generate file names for documentation files with the desired extension.\\n\\n   Example usage:\\n\\n   ```\\n   getFileName('example.txt'); // returns 'example.md'\\n   getFileName('example', '_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot, inputRoot,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/FileUtil.json"}, "type": "Document"}], ["661", {"page_content": "'_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot, inputRoot, filePath, linkHosted)`: This function generates a GitHub URL for a file. It takes the GitHub repository root URL, the input root folder path, the file path, and a boolean flag indicating whether the URL should be for the hosted version of the file or the source code. It returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true);\\n   // returns 'https://github.com/user/repo/example.md'\\n   ```\\n\\n3. `githubFolderUrl(githubRoot, inputRoot, folderPath, linkHosted)`: This function is similar to `githubFileUrl`, but it generates a GitHub URL for a folder instead of a file. It takes the same arguments as `githubFileUrl` and returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/FileUtil.json"}, "type": "Document"}], ["662", {"page_content": "githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns 'https://github.com/user/repo/folder'\\n   ```\\n\\nThese utility functions can be used throughout the autodoc project to generate file names and GitHub URLs for documentation files and folders, ensuring consistent naming and URL generation across the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/FileUtil.json"}, "type": "Document"}], ["663", {"page_content": "\"questions\": \"1. **What is the purpose of the `getFileName` function?**\\n\\n   The `getFileName` function takes an input string, an optional delimiter, and an optional extension, and returns a new string with the given extension. If the delimiter is not found in the input string, the extension is simply appended to the input string. If the delimiter is found, the input string is sliced up to the last delimiter index and the extension is appended.\\n\\n2. **What are the differences between the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   Both functions take the same parameters: `githubRoot`, `inputRoot`, a path (either `filePath` or `folderPath`), and a `linkHosted` boolean. The main difference is in the returned URL: `githubFileUrl` returns a URL pointing to a file in the GitHub repository, while `githubFolderUrl` returns a URL pointing to a folder in the GitHub repository. The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/FileUtil.json"}, "type": "Document"}], ["664", {"page_content": "The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for folders.\\n\\n3. **What is the purpose of the `linkHosted` parameter in the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   The `linkHosted` parameter is a boolean that determines whether the returned URL should point to the hosted version of the file or folder on GitHub Pages (if `true`) or to the file or folder within the GitHub repository itself (if `false`). Depending on the value of `linkHosted`, the functions will return different URL structures.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/FileUtil.json"}, "type": "Document"}], ["665", {"page_content": "\"checksum\": \"d1f26fc674b4a9b4a2053642771871c8\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/FileUtil.json"}, "type": "Document"}], ["666", {"page_content": "{\n  \"folderName\": \"utils\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils\",\n  \"files\": [\n    {\n      \"fileName\": \"APIRateLimit.ts\",\n      \"filePath\": \"src\\\\cli\\\\utils\\\\APIRateLimit.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\APIRateLimit.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["667", {"page_content": "\"summary\": \"The `APIRateLimit` class in this code snippet is designed to manage and limit the number of concurrent API calls made by the application. This is useful in situations where the API being called has a rate limit or when the application needs to prevent overwhelming the server with too many requests at once.\\n\\nThe class constructor takes an optional parameter `maxConcurrentCalls`, which defaults to 50, to set the maximum number of concurrent API calls allowed. It maintains a queue of API calls and keeps track of the number of calls in progress.\\n\\nThe main method of this class is `callApi<T>(apiFunction: () => Promise<T>): Promise<T>`. It takes a function `apiFunction` that returns a promise and wraps it in a new promise. The purpose of this wrapping is to control the execution of the API calls and ensure that they do not exceed the specified rate limit.\\n\\nWhen `callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["668", {"page_content": "is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is triggered if there are available slots for concurrent calls. The `dequeueAndExecute` method checks if there are any API calls in the queue and if the number of in-progress calls is below the maximum limit. If both conditions are met, it dequeues the next API call and executes it.\\n\\nThe `executeCall` function inside `callApi` is responsible for actually calling the API function, resolving or rejecting the promise based on the result, and updating the number of in-progress calls. Once an API call is completed, the `dequeueAndExecute` method is called again to process any remaining calls in the queue.\\n\\nHere's an example of how this class can be used in the larger project:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\n\\nasync function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["669", {"page_content": "function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls to the `fetch` function, ensuring that no more than 10 calls are made at once.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["670", {"page_content": "\"questions\": \"1. **What is the purpose of the `APIRateLimit` class?**\\n\\n   The `APIRateLimit` class is designed to manage and limit the number of concurrent API calls to a specified maximum, preventing the application from overwhelming the API with too many requests at once.\\n\\n2. **How does the `callApi` method work and what is its return type?**\\n\\n   The `callApi` method takes an `apiFunction` as an argument, which is a function that returns a Promise. It adds the API call to a queue and executes it when there are available slots for concurrent calls. The method returns a Promise of type `T`, where `T` is the expected return type of the `apiFunction`.\\n\\n3. **How can the maximum number of concurrent calls be configured?**\\n\\n   The maximum number of concurrent calls can be configured by passing a value to the `maxConcurrentCalls` parameter in the constructor of the `APIRateLimit` class. If no value is provided, the default value is set to 50.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["671", {"page_content": "\"checksum\": \"8862552c9cfd8b6db454d45e565081ef\"\n    },\n    {\n      \"fileName\": \"FileUtil.ts\",\n      \"filePath\": \"src\\\\cli\\\\utils\\\\FileUtil.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\FileUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["672", {"page_content": "\"summary\": \"This code provides utility functions for handling file and folder paths in the autodoc project. The main purpose of these functions is to generate file names and GitHub URLs for documentation files.\\n\\n1. `getFileName(input, delimiter, extension)`: This function takes an input string, an optional delimiter (default is '.'), and an optional extension (default is '.md'). It returns a new string with the given extension. If the delimiter is found in the input string, the function removes the part of the string after the last occurrence of the delimiter and appends the extension. If the delimiter is not found, the function simply appends the extension to the input string. This function can be used to generate file names for documentation files with the desired extension.\\n\\n   Example usage:\\n\\n   ```\\n   getFileName('example.txt'); // returns 'example.md'\\n   getFileName('example', '_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["673", {"page_content": "'_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot, inputRoot, filePath, linkHosted)`: This function generates a GitHub URL for a file. It takes the GitHub repository root URL, the input root folder path, the file path, and a boolean flag indicating whether the URL should be for the hosted version of the file or the source code. It returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true);\\n   // returns 'https://github.com/user/repo/example.md'\\n   ```\\n\\n3. `githubFolderUrl(githubRoot, inputRoot, folderPath, linkHosted)`: This function is similar to `githubFileUrl`, but it generates a GitHub URL for a folder instead of a file. It takes the same arguments as `githubFileUrl` and returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["674", {"page_content": "githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns 'https://github.com/user/repo/folder'\\n   ```\\n\\nThese utility functions can be used throughout the autodoc project to generate file names and GitHub URLs for documentation files and folders, ensuring consistent naming and URL generation across the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["675", {"page_content": "\"questions\": \"1. **What is the purpose of the `getFileName` function?**\\n\\n   The `getFileName` function takes an input string, an optional delimiter, and an optional extension, and returns a new string with the given extension. If the delimiter is not found in the input string, the extension is simply appended to the input string. If the delimiter is found, the input string is sliced up to the last delimiter index and the extension is appended.\\n\\n2. **What are the differences between the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   Both functions take the same parameters: `githubRoot`, `inputRoot`, a path (either `filePath` or `folderPath`), and a `linkHosted` boolean. The main difference is in the returned URL: `githubFileUrl` returns a URL pointing to a file in the GitHub repository, while `githubFolderUrl` returns a URL pointing to a folder in the GitHub repository. The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["676", {"page_content": "The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for folders.\\n\\n3. **What is the purpose of the `linkHosted` parameter in the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   The `linkHosted` parameter is a boolean that determines whether the returned URL should point to the hosted version of the file or folder on GitHub Pages (if `true`) or to the file or folder within the GitHub repository itself (if `false`). Depending on the value of `linkHosted`, the functions will return different URL structures.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["677", {"page_content": "\"checksum\": \"d1f26fc674b4a9b4a2053642771871c8\"\n    },\n    {\n      \"fileName\": \"LLMUtil.ts\",\n      \"filePath\": \"src\\\\cli\\\\utils\\\\LLMUtil.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\LLMUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["678", {"page_content": "\"summary\": \"This code defines and manages different language models (LLMs) and their associated costs for a project that utilizes OpenAI's GPT models. It imports the `OpenAIChat` class from the `langchain/llms` module and the `LLMModelDetails` and `LLMModels` types from the `../../types.js` file.\\n\\nThe `models` object contains three LLMs: GPT3, GPT4, and GPT432k. Each model has its own properties, such as `name`, `inputCostPer1KTokens`, `outputCostPer1KTokens`, `maxLength`, and an instance of the `OpenAIChat` class with the respective model name and API key. Additionally, each model has counters for input tokens, output tokens, succeeded, failed, and total files processed.\\n\\nThe `printModelDetails` function takes an array of `LLMModelDetails` and prints a summary table to the console. It calculates the total cost for each model based on the input and output tokens and their respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["679", {"page_content": "costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens, and cost across all models.\\n\\nThe `totalIndexCostEstimate` function calculates the total cost of indexing all models in the input array. It uses the same cost calculation as in `printModelDetails` but returns the total cost as a number.\\n\\nThese functions can be used in the larger project to manage and analyze the usage and costs of different LLMs. For example, the `printModelDetails` function can be called to display a summary of the models' usage and costs:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nprintModelDetails(Object.values(models));\\n```\\n\\nAnd the `totalIndexCostEstimate` function can be used to estimate the total cost of indexing all models:\\n\\n```javascript\\nimport { models, totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["680", {"page_content": "totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["681", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `models` object and how are the different GPT models being used?\\n   **Answer:** The `models` object is a record that maps different GPT models (GPT3, GPT4, and GPT432k) to their respective details, such as cost per tokens, maximum length, and an instance of `OpenAIChat` with the corresponding model configuration.\\n\\n2. **Question:** How does the `printModelDetails` function work and what information does it display?\\n   **Answer:** The `printModelDetails` function takes an array of `LLMModelDetails` as input, processes the information for each model, and then prints a summary table to the console. The table includes the model name, file count, succeeded and failed counts, total tokens, and cost.\\n\\n3. **Question:** What is the purpose of the `totalIndexCostEstimate` function and how is it calculating the total cost?\\n   **Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the given", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["682", {"page_content": "**Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the given models by iterating through the input `models` array and summing up the costs based on the input and output tokens and their respective costs per 1K tokens.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["683", {"page_content": "\"checksum\": \"f4464cf197f4af827ac0eac950d568fc\"\n    },\n    {\n      \"fileName\": \"traverseFileSystem.ts\",\n      \"filePath\": \"src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["684", {"page_content": "\"summary\": \"The `traverseFileSystem` function in this code is an asynchronous function that recursively traverses a given file system, processing files and folders based on the provided parameters. It is designed to be used in the larger project for generating documentation or performing other tasks that require processing files and folders in a directory structure.\\n\\nThe function takes an object of type `TraverseFileSystemParams` as its input, which contains various properties to control the traversal and processing behavior. These properties include:\\n\\n- `inputPath`: The root path to start the traversal from.\\n- `projectName`: The name of the project being processed.\\n- `processFile`: An optional callback function to process a file.\\n- `processFolder`: An optional callback function to process a folder.\\n- `ignore`: An array of patterns to ignore during traversal.\\n- `filePrompt`, `folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["685", {"page_content": "`folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`, `linkHosted`: Additional metadata for processing.\\n\\nThe function first checks if the provided `inputPath` exists using `fs.access`. If the path does not exist, it logs an error message and returns. It then defines a helper function `shouldIgnore` that checks if a given file or folder should be ignored based on the `ignore` patterns.\\n\\nThe main logic of the function is implemented in the `dfs` (depth-first search) function, which is called recursively to traverse the file system. It reads the contents of the current directory using `fs.readdir`, filters out ignored items, and processes the remaining items.\\n\\nFor each item, if it is a directory, the `dfs` function is called recursively, and the `processFolder` callback is invoked if provided. If it is a file and its content is text (checked using `isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["686", {"page_content": "`isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using `Promise.all` to process items concurrently, improving performance. If an error occurs during traversal, it is logged and rethrown.\\n\\nHere's an example of how this function might be used in the larger project:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => {\\n    // Process file logic here\\n  },\\n  processFolder: (params) => {\\n    // Process folder logic here\\n  },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["687", {"page_content": "\"questions\": \"1. **What is the purpose of the `traverseFileSystem` function?**\\n\\n   The `traverseFileSystem` function is an asynchronous function that traverses a given file system, processes folders and files based on the provided parameters, and ignores files and folders based on the given ignore patterns.\\n\\n2. **How does the `shouldIgnore` function work?**\\n\\n   The `shouldIgnore` function takes a file name as input and returns a boolean value indicating whether the file should be ignored or not. It checks if the file name matches any of the ignore patterns provided in the `ignore` parameter using the `minimatch` library.\\n\\n3. **What is the role of the `dfs` function inside `traverseFileSystem`?**\\n\\n   The `dfs` function is an asynchronous function that performs a depth-first search on the file system starting from the given `currentPath`. It processes folders and files based on the provided parameters and recursively calls itself for each subdirectory found.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["688", {"page_content": "\"checksum\": \"b9e957c10ee6c009864c90aa2fa93763\"\n    },\n    {\n      \"fileName\": \"WaitUtil.ts\",\n      \"filePath\": \"src\\\\cli\\\\utils\\\\WaitUtil.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\WaitUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["689", {"page_content": "\"summary\": \"The code in this file provides two utility functions, `wait` and `forTrue`, which are designed to help manage asynchronous operations in the larger project. Both functions return a `Promise`, making them suitable for use with `async/await` syntax.\\n\\n### wait\\n\\nThe `wait` function takes two arguments: `timeoutMs`, a number representing the desired waiting time in milliseconds, and an optional `value` that defaults to `null`. It returns a `Promise` that resolves with the provided `value` after the specified `timeoutMs` has elapsed. This function can be used to introduce a delay in the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\ndelayedEcho(); // Output: Start -> (1 second delay) -> End\\n```\\n\\n### forTrue\\n\\nThe `forTrue` function takes a single argument, `fn`, which is a function that returns a boolean value. It returns a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["690", {"page_content": "takes a single argument, `fn`, which is a function that returns a boolean value. It returns a `Promise` that resolves with `true` when the provided function `fn` returns `true`. The function `fn` is checked every 50 milliseconds, up to a maximum of 200 times (i.e., 10 seconds). If `fn` does not return `true` within this time, the `Promise` is rejected.\\n\\nThis function can be used to wait for a specific condition to be met before continuing the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nlet condition = false;\\n\\nsetTimeout(() => {\\n  condition = true;\\n}, 3000);\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n\\nwaitForCondition(); // Output: Waiting for condition... -> (3 second delay) -> Condition met!\\n```\\n\\nIn summary, this file provides two utility functions that help manage asynchronous operations by introducing delays and waiting for specific", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["691", {"page_content": "functions that help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used in the larger project to control the flow of asynchronous code execution.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["692", {"page_content": "\"questions\": \"1. **What is the purpose of the `wait` function?**\\n\\n   The `wait` function is an asynchronous utility function that resolves a promise after a specified timeout in milliseconds, optionally returning a value when the promise is resolved.\\n\\n2. **How does the `forTrue` function work?**\\n\\n   The `forTrue` function takes a function `fn` as an argument, which should return a boolean value. It checks the result of `fn` every 50 milliseconds and resolves the promise when `fn` returns `true`. If `fn` does not return `true` after 200 attempts, the promise is rejected.\\n\\n3. **What is the use case for the `forTrue` function?**\\n\\n   The `forTrue` function can be used to wait for a certain condition to be met before proceeding with the execution of the code. This can be useful in situations where you need to wait for an asynchronous operation to complete or a specific state to be reached before continuing.\",\n      \"checksum\": \"bf4acebb6c2736274af75a8c8441c9d2\"\n    }\n  ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["693", {"page_content": "\"checksum\": \"bf4acebb6c2736274af75a8c8441c9d2\"\n    }\n  ],\n  \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["694", {"page_content": "\"summary\": \"The `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils` folder contains utility functions and classes that assist in managing API rate limits, handling file and folder paths, managing language models, traversing file systems, and controlling asynchronous operations. These utilities can be used throughout the autodoc project to ensure consistent behavior and improve code organization.\\n\\n`APIRateLimit.ts` provides the `APIRateLimit` class, which manages and limits the number of concurrent API calls made by the application. This is useful when working with rate-limited APIs or preventing server overload. Example usage:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\nasync function fetchSomeData(id) {\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\n`FileUtil.ts` offers utility functions for generating file names and GitHub URLs for documentation files. These", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["695", {"page_content": "offers utility functions for generating file names and GitHub URLs for documentation files. These functions ensure consistent naming and URL generation across the project. Example usage:\\n\\n```javascript\\ngetFileName('example.txt'); // returns 'example.md'\\ngithubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true); // returns 'https://github.com/user/repo/example.md'\\n```\\n\\n`LLMUtil.ts` defines and manages different language models (LLMs) and their associated costs for a project utilizing OpenAI's GPT models. Functions like `printModelDetails` and `totalIndexCostEstimate` can be used to manage and analyze the usage and costs of different LLMs. Example usage:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\nprintModelDetails(Object.values(models));\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\\n\\n`traverseFileSystem.ts` contains the `traverseFileSystem`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["696", {"page_content": "cost: ${totalCost}`);\\n```\\n\\n`traverseFileSystem.ts` contains the `traverseFileSystem` function, which recursively traverses a given file system, processing files and folders based on provided parameters. This is useful for generating documentation or performing tasks that require processing files and folders in a directory structure. Example usage:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => { /* Process file logic */ },\\n  processFolder: (params) => { /* Process folder logic */ },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\\n\\n`WaitUtil.ts` provides two utility functions, `wait` and `forTrue`, which help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used to control the flow of asynchronous code execution. Example usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["697", {"page_content": "function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n```\\n\\nIn summary, the utilities in this folder enhance the autodoc project by providing consistent behavior, improving code organization, and managing various aspects of the project, such as API rate limits, file and folder paths, language models, file system traversal, and asynchronous operations.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["698", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"a4b7088863601cd326edbec7726eefe7\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/summary.json"}, "type": "Document"}], ["699", {"page_content": "{\n  \"fileName\": \"WaitUtil.ts\",\n  \"filePath\": \"src\\\\cli\\\\utils\\\\WaitUtil.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\WaitUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/WaitUtil.json"}, "type": "Document"}], ["700", {"page_content": "\"summary\": \"The code in this file provides two utility functions, `wait` and `forTrue`, which are designed to help manage asynchronous operations in the larger project. Both functions return a `Promise`, making them suitable for use with `async/await` syntax.\\n\\n### wait\\n\\nThe `wait` function takes two arguments: `timeoutMs`, a number representing the desired waiting time in milliseconds, and an optional `value` that defaults to `null`. It returns a `Promise` that resolves with the provided `value` after the specified `timeoutMs` has elapsed. This function can be used to introduce a delay in the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\ndelayedEcho(); // Output: Start -> (1 second delay) -> End\\n```\\n\\n### forTrue\\n\\nThe `forTrue` function takes a single argument, `fn`, which is a function that returns a boolean value. It returns a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/WaitUtil.json"}, "type": "Document"}], ["701", {"page_content": "takes a single argument, `fn`, which is a function that returns a boolean value. It returns a `Promise` that resolves with `true` when the provided function `fn` returns `true`. The function `fn` is checked every 50 milliseconds, up to a maximum of 200 times (i.e., 10 seconds). If `fn` does not return `true` within this time, the `Promise` is rejected.\\n\\nThis function can be used to wait for a specific condition to be met before continuing the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nlet condition = false;\\n\\nsetTimeout(() => {\\n  condition = true;\\n}, 3000);\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n\\nwaitForCondition(); // Output: Waiting for condition... -> (3 second delay) -> Condition met!\\n```\\n\\nIn summary, this file provides two utility functions that help manage asynchronous operations by introducing delays and waiting for specific", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/WaitUtil.json"}, "type": "Document"}], ["702", {"page_content": "functions that help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used in the larger project to control the flow of asynchronous code execution.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/WaitUtil.json"}, "type": "Document"}], ["703", {"page_content": "\"questions\": \"1. **What is the purpose of the `wait` function?**\\n\\n   The `wait` function is an asynchronous utility function that resolves a promise after a specified timeout in milliseconds, optionally returning a value when the promise is resolved.\\n\\n2. **How does the `forTrue` function work?**\\n\\n   The `forTrue` function takes a function `fn` as an argument, which should return a boolean value. It checks the result of `fn` every 50 milliseconds and resolves the promise when `fn` returns `true`. If `fn` does not return `true` after 200 attempts, the promise is rejected.\\n\\n3. **What is the use case for the `forTrue` function?**\\n\\n   The `forTrue` function can be used to wait for a certain condition to be met before proceeding with the execution of the code. This can be useful in situations where you need to wait for an asynchronous operation to complete or a specific state to be reached before continuing.\",\n  \"checksum\": \"bf4acebb6c2736274af75a8c8441c9d2\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/utils/WaitUtil.json"}, "type": "Document"}], ["704", {"page_content": "{\n  \"fileName\": \"index.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\init\\\\index.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\init\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/index.json"}, "type": "Document"}], ["705", {"page_content": "\"summary\": \"This code is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/index.json"}, "type": "Document"}], ["706", {"page_content": "process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/index.json"}, "type": "Document"}], ["707", {"page_content": "configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/index.json"}, "type": "Document"}], ["708", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc project. It takes an optional `config` parameter of type `AutodocRepoConfig` and returns a new configuration object with default values for various properties.\\n\\n2. **How does the `init` function work and when is it called?**\\n\\n   The `init` function is an asynchronous function that initializes the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It takes an optional `config` parameter of type `AutodocRepoConfig` and prompts the user for input to set the configuration values. It is called when the user wants to set up the Autodoc configuration for their project.\\n\\n3. **What is the purpose of the `inquirer.prompt` calls in the `init` function?**\\n\\n   The `inquirer.prompt` calls are used to interactively prompt the user for input to set the configuration", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/index.json"}, "type": "Document"}], ["709", {"page_content": "calls are used to interactively prompt the user for input to set the configuration values for the Autodoc project. The user is asked for the repository name, repository URL, and the LLMs they have access to. The input is then used to create a new configuration object and write it to the `autodoc.config.json` file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/index.json"}, "type": "Document"}], ["710", {"page_content": "\"checksum\": \"b93831ff1f4023ab61c3bea963a8a112\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/index.json"}, "type": "Document"}], ["711", {"page_content": "{\n  \"folderName\": \"init\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n  \"files\": [\n    {\n      \"fileName\": \"index.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\init\\\\index.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\init\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["712", {"page_content": "\"summary\": \"This code is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["713", {"page_content": "the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["714", {"page_content": "configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["715", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc project. It takes an optional `config` parameter of type `AutodocRepoConfig` and returns a new configuration object with default values for various properties.\\n\\n2. **How does the `init` function work and when is it called?**\\n\\n   The `init` function is an asynchronous function that initializes the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It takes an optional `config` parameter of type `AutodocRepoConfig` and prompts the user for input to set the configuration values. It is called when the user wants to set up the Autodoc configuration for their project.\\n\\n3. **What is the purpose of the `inquirer.prompt` calls in the `init` function?**\\n\\n   The `inquirer.prompt` calls are used to interactively prompt the user for input to set the configuration", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["716", {"page_content": "calls are used to interactively prompt the user for input to set the configuration values for the Autodoc project. The user is asked for the repository name, repository URL, and the LLMs they have access to. The input is then used to create a new configuration object and write it to the `autodoc.config.json` file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["717", {"page_content": "\"checksum\": \"b93831ff1f4023ab61c3bea963a8a112\"\n    }\n  ],\n  \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["718", {"page_content": "\"summary\": \"The `index.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init` folder is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["719", {"page_content": "the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["720", {"page_content": "init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\nThis code is essential for setting up the Autodoc project, as it creates the necessary configuration file and gathers user input to customize the project. It works in conjunction with other parts of the project, such as the CLI and the documentation generation process, which rely on the configuration file to function correctly.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["721", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/init/summary.json"}, "type": "Document"}], ["722", {"page_content": "{\n  \"fileName\": \"createChatChain.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/createChatChain.json"}, "type": "Document"}], ["723", {"page_content": "\"summary\": \"This code defines a function `makeChain` that creates a chatbot for answering questions about a software project called `projectName`. The chatbot is trained on the content of the project, which is located at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters:\\n\\n- `projectName`: The name of the software project.\\n- `repositoryUrl`: The URL of the project's repository.\\n- `contentType`: The type of content the chatbot is trained on.\\n- `chatPrompt`: Additional instructions for answering questions about the content type.\\n- `targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/createChatChain.json"}, "type": "Document"}], ["724", {"page_content": "The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for efficient nearest neighbor search.\\n- `llms`: An array of LLMModels, which are language models used for generating answers.\\n- `onTokenStream`: An optional callback function that is called when a new token is generated by the language model.\\n\\nThe `makeChain` function first creates a question generator using the `LLMChain` class. This generator is responsible for rephrasing follow-up questions to be standalone questions. It uses the `CONDENSE_PROMPT` template, which is defined at the beginning of the code.\\n\\nNext, the function creates a `QA_PROMPT` template using the `makeQAPrompt` function. This template is used to generate answers to the questions in a conversational manner, with hyperlinks back to GitHub and code examples where appropriate.\\n\\nFinally, the function creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/createChatChain.json"}, "type": "Document"}], ["725", {"page_content": "a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project. The chatbot uses the `vectorstore` for efficient nearest neighbor search and the `llms` language models for generating answers. If the `onTokenStream` callback is provided, it will be called when a new token is generated by the language model.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/createChatChain.json"}, "type": "Document"}], ["726", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `makeChain` function and what are its input parameters?\\n\\n   **Answer:** The `makeChain` function is used to create a `ChatVectorDBQAChain` instance, which is responsible for generating questions and answers based on the given input parameters. The input parameters include `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and an optional `onTokenStream` function.\\n\\n2. **Question:** What are the roles of `CONDENSE_PROMPT` and `QA_PROMPT` in this code?\\n\\n   **Answer:** `CONDENSE_PROMPT` is a template for generating standalone questions from a given chat history and follow-up question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to GitHub, based on the provided context and question. Both templates are used in the `LLMChain` and `loadQAChain` instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and when is", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/createChatChain.json"}, "type": "Document"}], ["727", {"page_content": "instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and when is it used?\\n\\n   **Answer:** The `onTokenStream` function is an optional callback that can be provided to the `makeChain` function. It is used to handle the streaming of tokens generated by the OpenAIChat instance. If provided, it will be called with each new token generated during the chat process.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/createChatChain.json"}, "type": "Document"}], ["728", {"page_content": "\"checksum\": \"6869048a06de62499933b14c37cddc1d\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/createChatChain.json"}, "type": "Document"}], ["729", {"page_content": "{\n  \"fileName\": \"index.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\index.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/index.json"}, "type": "Document"}], ["730", {"page_content": "\"summary\": \"This code defines a chatbot interface for the Autodoc project, which allows users to ask questions related to a specific codebase and receive answers in a conversational manner. The chatbot uses a combination of the `inquirer` library for user input, `marked` and `marked-terminal` for rendering Markdown output, and the `langchain` library for handling natural language processing tasks.\\n\\nThe `query` function is the main entry point for the chatbot. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store using the `HNSWLib` and `OpenAIEmbeddings` classes, and creates a chat chain using the `makeChain` function.\\n\\nThe chatbot interface is displayed using the `displayWelcomeMessage` function, which prints a welcome message to the console. The `getQuestion` function is used to prompt the user for a question using the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/index.json"}, "type": "Document"}], ["731", {"page_content": "to the console. The `getQuestion` function is used to prompt the user for a question using the `inquirer` library. The chatbot then enters a loop, where it processes the user's question, generates a response using the chat chain, and displays the response as Markdown in the terminal.\\n\\nIf an error occurs during the processing of a question, the chatbot will display an error message and continue to prompt the user for a new question. The loop continues until the user types 'exit', at which point the chatbot terminates.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example would", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/index.json"}, "type": "Document"}], ["732", {"page_content": "= {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example would initialize the chatbot with the specified repository and user configurations, and start the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/index.json"}, "type": "Document"}], ["733", {"page_content": "\"questions\": \"1. **What is the purpose of the `query` function in this code?**\\n\\n   The `query` function is responsible for handling user interactions with the chatbot. It takes in an AutodocRepoConfig object and an AutodocUserConfig object, sets up the necessary data structures, and then enters a loop where it prompts the user for questions, processes them, and displays the results.\\n\\n2. **How does the code handle rendering Markdown text in the terminal?**\\n\\n   The code uses the `marked` library along with a custom `TerminalRenderer` to render Markdown text in the terminal. The `marked` library is configured with the custom renderer using `marked.setOptions({ renderer: new TerminalRenderer() });`.\\n\\n3. **What is the purpose of the `chatHistory` variable and how is it used?**\\n\\n   The `chatHistory` variable is an array that stores the history of questions and answers in the chat session. It is used to keep track of the conversation between the user and the chatbot. When a new", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/index.json"}, "type": "Document"}], ["734", {"page_content": "session. It is used to keep track of the conversation between the user and the chatbot. When a new question is asked, the chat history is passed to the `chain.call()` function, and the new question and its corresponding answer are added to the `chatHistory` array.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/index.json"}, "type": "Document"}], ["735", {"page_content": "\"checksum\": \"19807a33957666422f31136970c37245\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/index.json"}, "type": "Document"}], ["736", {"page_content": "{\n  \"folderName\": \"query\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n  \"files\": [\n    {\n      \"fileName\": \"createChatChain.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["737", {"page_content": "\"summary\": \"This code defines a function `makeChain` that creates a chatbot for answering questions about a software project called `projectName`. The chatbot is trained on the content of the project, which is located at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters:\\n\\n- `projectName`: The name of the software project.\\n- `repositoryUrl`: The URL of the project's repository.\\n- `contentType`: The type of content the chatbot is trained on.\\n- `chatPrompt`: Additional instructions for answering questions about the content type.\\n- `targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["738", {"page_content": "The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for efficient nearest neighbor search.\\n- `llms`: An array of LLMModels, which are language models used for generating answers.\\n- `onTokenStream`: An optional callback function that is called when a new token is generated by the language model.\\n\\nThe `makeChain` function first creates a question generator using the `LLMChain` class. This generator is responsible for rephrasing follow-up questions to be standalone questions. It uses the `CONDENSE_PROMPT` template, which is defined at the beginning of the code.\\n\\nNext, the function creates a `QA_PROMPT` template using the `makeQAPrompt` function. This template is used to generate answers to the questions in a conversational manner, with hyperlinks back to GitHub and code examples where appropriate.\\n\\nFinally, the function creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["739", {"page_content": "a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project. The chatbot uses the `vectorstore` for efficient nearest neighbor search and the `llms` language models for generating answers. If the `onTokenStream` callback is provided, it will be called when a new token is generated by the language model.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["740", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `makeChain` function and what are its input parameters?\\n\\n   **Answer:** The `makeChain` function is used to create a `ChatVectorDBQAChain` instance, which is responsible for generating questions and answers based on the given input parameters. The input parameters include `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and an optional `onTokenStream` function.\\n\\n2. **Question:** What are the roles of `CONDENSE_PROMPT` and `QA_PROMPT` in this code?\\n\\n   **Answer:** `CONDENSE_PROMPT` is a template for generating standalone questions from a given chat history and follow-up question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to GitHub, based on the provided context and question. Both templates are used in the `LLMChain` and `loadQAChain` instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["741", {"page_content": "instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and when is it used?\\n\\n   **Answer:** The `onTokenStream` function is an optional callback that can be provided to the `makeChain` function. It is used to handle the streaming of tokens generated by the OpenAIChat instance. If provided, it will be called with each new token generated during the chat process.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["742", {"page_content": "\"checksum\": \"6869048a06de62499933b14c37cddc1d\"\n    },\n    {\n      \"fileName\": \"index.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\index.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["743", {"page_content": "\"summary\": \"This code defines a chatbot interface for the Autodoc project, which allows users to ask questions related to a specific codebase and receive answers in a conversational manner. The chatbot uses a combination of the `inquirer` library for user input, `marked` and `marked-terminal` for rendering Markdown output, and the `langchain` library for handling natural language processing tasks.\\n\\nThe `query` function is the main entry point for the chatbot. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store using the `HNSWLib` and `OpenAIEmbeddings` classes, and creates a chat chain using the `makeChain` function.\\n\\nThe chatbot interface is displayed using the `displayWelcomeMessage` function, which prints a welcome message to the console. The `getQuestion` function is used to prompt the user for a question using", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["744", {"page_content": "message to the console. The `getQuestion` function is used to prompt the user for a question using the `inquirer` library. The chatbot then enters a loop, where it processes the user's question, generates a response using the chat chain, and displays the response as Markdown in the terminal.\\n\\nIf an error occurs during the processing of a question, the chatbot will display an error message and continue to prompt the user for a new question. The loop continues until the user types 'exit', at which point the chatbot terminates.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["745", {"page_content": "userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example would initialize the chatbot with the specified repository and user configurations, and start the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["746", {"page_content": "\"questions\": \"1. **What is the purpose of the `query` function in this code?**\\n\\n   The `query` function is responsible for handling user interactions with the chatbot. It takes in an AutodocRepoConfig object and an AutodocUserConfig object, sets up the necessary data structures, and then enters a loop where it prompts the user for questions, processes them, and displays the results.\\n\\n2. **How does the code handle rendering Markdown text in the terminal?**\\n\\n   The code uses the `marked` library along with a custom `TerminalRenderer` to render Markdown text in the terminal. The `marked` library is configured with the custom renderer using `marked.setOptions({ renderer: new TerminalRenderer() });`.\\n\\n3. **What is the purpose of the `chatHistory` variable and how is it used?**\\n\\n   The `chatHistory` variable is an array that stores the history of questions and answers in the chat session. It is used to keep track of the conversation between the user and the chatbot. When a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["747", {"page_content": "chat session. It is used to keep track of the conversation between the user and the chatbot. When a new question is asked, the chat history is passed to the `chain.call()` function, and the new question and its corresponding answer are added to the `chatHistory` array.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["748", {"page_content": "\"checksum\": \"19807a33957666422f31136970c37245\"\n    }\n  ],\n  \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["749", {"page_content": "\"summary\": \"The `query` folder in the Autodoc project contains code for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot is trained on the content of the project and provides answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate.\\n\\nThe main entry point for the chatbot is the `query` function in `index.ts`. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store and creates a chat chain using the `makeChain` function from `createChatChain.ts`.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["750", {"page_content": "repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example initializes the chatbot with the specified repository and user configurations and starts the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\\n\\nThe `createChatChain.ts` file defines the `makeChain` function, which creates a chatbot for answering questions about a software project. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["751", {"page_content": "takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and `onTokenStream`. It first creates a question generator using the `LLMChain` class, then creates a `QA_PROMPT` template using the `makeQAPrompt` function, and finally creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project.\\n\\nIn summary, the code in the `query` folder is responsible for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot uses a combination of natural language processing techniques and efficient nearest neighbor search to generate accurate and relevant answers for the user.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["752", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"9e0d0f111bf588e2df66862dce9db288\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/query/summary.json"}, "type": "Document"}], ["753", {"page_content": "{\n  \"fileName\": \"createVectorStore.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/createVectorStore.json"}, "type": "Document"}], ["754", {"page_content": "\"summary\": \"The code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\\n\\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.\\n\\nThe `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/createVectorStore.json"}, "type": "Document"}], ["755", {"page_content": "an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.\\n\\nThe `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/createVectorStore.json"}, "type": "Document"}], ["756", {"page_content": "path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output: './data/vector_store',\\n};\\n\\ncreateVectorStore(config).then(() => {\\n  console.log('Vector store created successfully');\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/createVectorStore.json"}, "type": "Document"}], ["757", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processFile` function and what does it return?\\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\\n\\n2. **Question:** How does the `processDirectory` function work and what does it return?\\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.\\n\\n3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/createVectorStore.json"}, "type": "Document"}], ["758", {"page_content": "it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/createVectorStore.json"}, "type": "Document"}], ["759", {"page_content": "\"checksum\": \"a3409c4340753a867c72eebef7626fb9\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/createVectorStore.json"}, "type": "Document"}], ["760", {"page_content": "{\n  \"fileName\": \"convertJsonToMarkdown.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/convertJsonToMarkdown.json"}, "type": "Document"}], ["761", {"page_content": "\"summary\": \"The `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\\n\\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation generation process.\\n\\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.\\n\\nNext, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if so, it", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/convertJsonToMarkdown.json"}, "type": "Document"}], ["762", {"page_content": "converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\\n\\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\\n\\nExample usage:\\n\\n```javascript\\nconvertJsonToMarkdown({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will convert all JSON files in the `./input` directory into Markdown files and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/convertJsonToMarkdown.json"}, "type": "Document"}], ["763", {"page_content": "will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/convertJsonToMarkdown.json"}, "type": "Document"}], ["764", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.\\n\\n2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created, and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/convertJsonToMarkdown.json"}, "type": "Document"}], ["765", {"page_content": "in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/convertJsonToMarkdown.json"}, "type": "Document"}], ["766", {"page_content": "\"checksum\": \"79c860becf47b9882441682f0213d534\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/convertJsonToMarkdown.json"}, "type": "Document"}], ["767", {"page_content": "{\n  \"fileName\": \"index.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\index.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/index.json"}, "type": "Document"}], ["768", {"page_content": "\"summary\": \"The code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\\n\\nThe `index` function performs three main tasks:\\n\\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Processing repository...');\\n   await processRepository({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/index.json"}, "type": "Document"}], ["769", {"page_content": "**Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Creating markdown files...');\\n   await convertJsonToMarkdown({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Create vector files...');\\n   await createVectorStore({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\nThroughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/index.json"}, "type": "Document"}], ["770", {"page_content": "the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\\n\\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/index.json"}, "type": "Document"}], ["771", {"page_content": "\"questions\": \"1. **What does the `index` function do in this code?**\\n\\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\\n\\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**\\n\\n   The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\\n\\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\\n\\n   These prompts are likely used to interact with the user during the processing of the repository. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/index.json"}, "type": "Document"}], ["772", {"page_content": "prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/index.json"}, "type": "Document"}], ["773", {"page_content": "\"checksum\": \"4060b1affae5a6c385cda308b3cd1750\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/index.json"}, "type": "Document"}], ["774", {"page_content": "{\n  \"folderName\": \"index\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n  \"files\": [\n    {\n      \"fileName\": \"convertJsonToMarkdown.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["775", {"page_content": "\"summary\": \"The `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\\n\\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation generation process.\\n\\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.\\n\\nNext, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if so, it", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["776", {"page_content": "converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\\n\\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\\n\\nExample usage:\\n\\n```javascript\\nconvertJsonToMarkdown({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will convert all JSON files in the `./input` directory into Markdown files and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["777", {"page_content": "will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["778", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.\\n\\n2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["779", {"page_content": "file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["780", {"page_content": "\"checksum\": \"79c860becf47b9882441682f0213d534\"\n    },\n    {\n      \"fileName\": \"createVectorStore.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["781", {"page_content": "\"summary\": \"The code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\\n\\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.\\n\\nThe `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["782", {"page_content": "an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.\\n\\nThe `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["783", {"page_content": "path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output: './data/vector_store',\\n};\\n\\ncreateVectorStore(config).then(() => {\\n  console.log('Vector store created successfully');\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["784", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processFile` function and what does it return?\\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\\n\\n2. **Question:** How does the `processDirectory` function work and what does it return?\\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.\\n\\n3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["785", {"page_content": "it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["786", {"page_content": "\"checksum\": \"a3409c4340753a867c72eebef7626fb9\"\n    },\n    {\n      \"fileName\": \"index.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\index.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["787", {"page_content": "\"summary\": \"The code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\\n\\nThe `index` function performs three main tasks:\\n\\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Processing repository...');\\n   await processRepository({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["788", {"page_content": "**Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Creating markdown files...');\\n   await convertJsonToMarkdown({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Create vector files...');\\n   await createVectorStore({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\nThroughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["789", {"page_content": "the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\\n\\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["790", {"page_content": "\"questions\": \"1. **What does the `index` function do in this code?**\\n\\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\\n\\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**\\n\\n   The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\\n\\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\\n\\n   These prompts are likely used to interact with the user during the processing of the repository. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["791", {"page_content": "prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["792", {"page_content": "\"checksum\": \"4060b1affae5a6c385cda308b3cd1750\"\n    },\n    {\n      \"fileName\": \"processRepository.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["793", {"page_content": "\"summary\": \"The `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.\\n\\nThe function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The results are then", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["794", {"page_content": "and calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\\n\\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.\\n\\nThe main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\\n\\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["795", {"page_content": "function checks if reindexing is needed by comparing the new and old checksums of a file or folder.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["796", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.\\n\\n2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and need to be", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["797", {"page_content": "the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.\\n\\n3. **Question:** How does the `reindexCheck` function work and when is it used?\\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["798", {"page_content": "\"checksum\": \"5b3ae9ffad1d4b4a22c6f7fd66bbde6f\"\n    },\n    {\n      \"fileName\": \"prompts.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["799", {"page_content": "\"summary\": \"This code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\\n\\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\\n```\\n\\n2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code file. It", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["800", {"page_content": "This function generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\\n```\\n\\n3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["801", {"page_content": "function returns a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\\n```\\n\\nThese functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["802", {"page_content": "\"questions\": \"1. **What is the purpose of the `createCodeFileSummary` function?**\\n\\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\\n\\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\\n\\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\\n\\n3. **What is the role of the `folderSummaryPrompt` function?**\\n\\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.\",\n      \"checksum\": \"e44b82bf4912be69149685a997b6bde3\"\n    }\n  ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["803", {"page_content": "\"checksum\": \"e44b82bf4912be69149685a997b6bde3\"\n    }\n  ],\n  \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["804", {"page_content": "\"summary\": \"The code in this folder is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It consists of several functions and utilities that work together to automate the documentation generation process.\\n\\nThe main function, `index`, takes an `AutodocRepoConfig` object as input, which contains various configuration options for processing the repository. It performs three main tasks:\\n\\n1. **Process the repository**: It calls the `processRepository` function to traverse the repository, generate summaries and questions for code files and folders using the LLMS (Language Learning Management System), and create JSON files with the results. These JSON files are stored in the `output/docs/json/` directory.\\n\\n2. **Create Markdown files**: It uses the `convertJsonToMarkdown` function to convert the generated JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n3.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["805", {"page_content": "Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n3. **Create vector files**: It calls the `createVectorStore` function to create vector files from the generated Markdown files. These vector files are stored in the `output/docs/data/` directory.\\n\\nThroughout the execution of these tasks, the code provides visual feedback on the progress of the tasks using `updateSpinnerText` and `spinnerSuccess` functions.\\n\\nHere's an example of how this code might be used:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will process the repository located at `./input`, generate documentation in JSON, Markdown, and vector formats, and save the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains utility functions that", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["806", {"page_content": "the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains utility functions that generate prompts for documentation experts. These functions create markdown formatted strings with specific instructions for the documentation expert, ensuring consistent formatting and instructions across different parts of the project.\\n\\nIn summary, the code in this folder automates the process of generating documentation for a given repository based on the provided configuration options. The generated documentation can be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["807", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"376f96417f8cbea6a5ab2463268fe4af\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/summary.json"}, "type": "Document"}], ["808", {"page_content": "{\n  \"fileName\": \"processRepository.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/processRepository.json"}, "type": "Document"}], ["809", {"page_content": "\"summary\": \"The `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.\\n\\nThe function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The results are then saved", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/processRepository.json"}, "type": "Document"}], ["810", {"page_content": "calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\\n\\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.\\n\\nThe main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\\n\\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/processRepository.json"}, "type": "Document"}], ["811", {"page_content": "function checks if reindexing is needed by comparing the new and old checksums of a file or folder.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/processRepository.json"}, "type": "Document"}], ["812", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.\\n\\n2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and need to be", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/processRepository.json"}, "type": "Document"}], ["813", {"page_content": "the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.\\n\\n3. **Question:** How does the `reindexCheck` function work and when is it used?\\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/processRepository.json"}, "type": "Document"}], ["814", {"page_content": "\"checksum\": \"5b3ae9ffad1d4b4a22c6f7fd66bbde6f\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/processRepository.json"}, "type": "Document"}], ["815", {"page_content": "{\n  \"fileName\": \"prompts.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/prompts.json"}, "type": "Document"}], ["816", {"page_content": "\"summary\": \"This code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\\n\\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\\n```\\n\\n2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code file. It takes", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/prompts.json"}, "type": "Document"}], ["817", {"page_content": "generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\\n```\\n\\n3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their summaries and a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/prompts.json"}, "type": "Document"}], ["818", {"page_content": "a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\\n```\\n\\nThese functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/prompts.json"}, "type": "Document"}], ["819", {"page_content": "\"questions\": \"1. **What is the purpose of the `createCodeFileSummary` function?**\\n\\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\\n\\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\\n\\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\\n\\n3. **What is the role of the `folderSummaryPrompt` function?**\\n\\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.\",\n  \"checksum\": \"e44b82bf4912be69149685a997b6bde3\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/index/prompts.json"}, "type": "Document"}], ["820", {"page_content": "{\n  \"folderName\": \"commands\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\",\n  \"files\": [],\n  \"folders\": [\n    {\n      \"folderName\": \"estimate\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n      \"files\": [\n        {\n          \"fileName\": \"index.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["821", {"page_content": "\"summary\": \"The `estimate` function in this code is responsible for providing an estimated cost of processing a given repository using the Autodoc project. It takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function starts by constructing the path to the JSON output directory, which will be used to store the intermediate results of the processing. It then updates the spinner text to indicate that the cost estimation is in progress.\\n\\nNext, the `processRepository` function is called with the provided configuration options and a `true` flag to indicate that this is a dry run. This means that the repository will not actually be processed, but the function will return the details of what would happen if it were processed. This is used to calculate the estimated cost of processing the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["822", {"page_content": "would happen if it were processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce the dry run is complete, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is then calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in a red color. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["823", {"page_content": "'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["824", {"page_content": "\"questions\": \"1. **What is the purpose of the `estimate` function?**\\n\\n   The `estimate` function is used to perform a dry run of the `processRepository` command to get an estimated price for indexing the given repository. It then prints the model details and the total estimated cost.\\n\\n2. **What are the parameters passed to the `processRepository` function?**\\n\\n   The `processRepository` function is called with an object containing the following properties: `name`, `repositoryUrl`, `root`, `output`, `llms`, `ignore`, `filePrompt`, `folderPrompt`, `chatPrompt`, `contentType`, `targetAudience`, and `linkHosted`. Additionally, a second argument `true` is passed to indicate that it's a dry run.\\n\\n3. **How is the total estimated cost calculated and displayed?**\\n\\n   The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes an array of values from the `runDetails` object. The cost is then displayed using `console.log` with", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["825", {"page_content": "array of values from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for formatting, showing the cost with two decimal places and a note that the actual cost may vary.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["826", {"page_content": "\"checksum\": \"2b0b3903432ae423bbc597d04b052ecb\"\n        }\n      ],\n      \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["827", {"page_content": "\"summary\": \"The `estimate` function in `index.ts` is a crucial part of the Autodoc project, as it provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input, containing various configuration options such as repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function begins by constructing the path to the JSON output directory, which stores intermediate results of the processing. It then updates the spinner text to indicate that cost estimation is in progress. The `processRepository` function is called with the provided configuration options and a `true` flag, signifying a dry run. This dry run returns the details of what would happen if the repository were processed, which is used to calculate the estimated cost.\\n\\nUpon completion of the dry run, the spinner is updated to show success, and the results are printed using the `printModelDetails` function.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["828", {"page_content": "is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in red. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["829", {"page_content": "true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["830", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n    },\n    {\n      \"folderName\": \"index\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n      \"files\": [\n        {\n          \"fileName\": \"convertJsonToMarkdown.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["831", {"page_content": "\"summary\": \"The `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\\n\\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation generation process.\\n\\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.\\n\\nNext, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if so, it", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["832", {"page_content": "converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\\n\\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\\n\\nExample usage:\\n\\n```javascript\\nconvertJsonToMarkdown({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will convert all JSON files in the `./input` directory into Markdown files and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["833", {"page_content": "will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["834", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.\\n\\n2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["835", {"page_content": "code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["836", {"page_content": "\"checksum\": \"79c860becf47b9882441682f0213d534\"\n        },\n        {\n          \"fileName\": \"createVectorStore.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["837", {"page_content": "\"summary\": \"The code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\\n\\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.\\n\\nThe `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["838", {"page_content": "returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.\\n\\nThe `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["839", {"page_content": "path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output: './data/vector_store',\\n};\\n\\ncreateVectorStore(config).then(() => {\\n  console.log('Vector store created successfully');\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["840", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processFile` function and what does it return?\\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\\n\\n2. **Question:** How does the `processDirectory` function work and what does it return?\\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.\\n\\n3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["841", {"page_content": "how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["842", {"page_content": "\"checksum\": \"a3409c4340753a867c72eebef7626fb9\"\n        },\n        {\n          \"fileName\": \"index.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\index.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["843", {"page_content": "\"summary\": \"The code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\\n\\nThe `index` function performs three main tasks:\\n\\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Processing repository...');\\n   await processRepository({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["844", {"page_content": "```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Creating markdown files...');\\n   await convertJsonToMarkdown({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Create vector files...');\\n   await createVectorStore({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\nThroughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["845", {"page_content": "the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\\n\\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["846", {"page_content": "\"questions\": \"1. **What does the `index` function do in this code?**\\n\\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\\n\\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**\\n\\n   The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\\n\\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\\n\\n   These prompts are likely used to interact with the user during the processing of the repository. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["847", {"page_content": "prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["848", {"page_content": "\"checksum\": \"4060b1affae5a6c385cda308b3cd1750\"\n        },\n        {\n          \"fileName\": \"processRepository.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["849", {"page_content": "\"summary\": \"The `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.\\n\\nThe function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The results are", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["850", {"page_content": "length, and calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\\n\\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.\\n\\nThe main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\\n\\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["851", {"page_content": "`reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or folder.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["852", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.\\n\\n2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and need to be", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["853", {"page_content": "the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.\\n\\n3. **Question:** How does the `reindexCheck` function work and when is it used?\\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["854", {"page_content": "\"checksum\": \"5b3ae9ffad1d4b4a22c6f7fd66bbde6f\"\n        },\n        {\n          \"fileName\": \"prompts.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["855", {"page_content": "\"summary\": \"This code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\\n\\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\\n```\\n\\n2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code file. It", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["856", {"page_content": "This function generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\\n```\\n\\n3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["857", {"page_content": "function returns a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\\n```\\n\\nThese functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["858", {"page_content": "\"questions\": \"1. **What is the purpose of the `createCodeFileSummary` function?**\\n\\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\\n\\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\\n\\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\\n\\n3. **What is the role of the `folderSummaryPrompt` function?**\\n\\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.\",\n          \"checksum\": \"e44b82bf4912be69149685a997b6bde3\"", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["859", {"page_content": "\"checksum\": \"e44b82bf4912be69149685a997b6bde3\"\n        }\n      ],\n      \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["860", {"page_content": "\"summary\": \"The code in this folder is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It consists of several functions and utilities that work together to automate the documentation generation process.\\n\\nThe main function, `index`, takes an `AutodocRepoConfig` object as input, which contains various configuration options for processing the repository. It performs three main tasks:\\n\\n1. **Process the repository**: It calls the `processRepository` function to traverse the repository, generate summaries and questions for code files and folders using the LLMS (Language Learning Management System), and create JSON files with the results. These JSON files are stored in the `output/docs/json/` directory.\\n\\n2. **Create Markdown files**: It uses the `convertJsonToMarkdown` function to convert the generated JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n3.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["861", {"page_content": "Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n3. **Create vector files**: It calls the `createVectorStore` function to create vector files from the generated Markdown files. These vector files are stored in the `output/docs/data/` directory.\\n\\nThroughout the execution of these tasks, the code provides visual feedback on the progress of the tasks using `updateSpinnerText` and `spinnerSuccess` functions.\\n\\nHere's an example of how this code might be used:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will process the repository located at `./input`, generate documentation in JSON, Markdown, and vector formats, and save the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains utility functions that", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["862", {"page_content": "the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains utility functions that generate prompts for documentation experts. These functions create markdown formatted strings with specific instructions for the documentation expert, ensuring consistent formatting and instructions across different parts of the project.\\n\\nIn summary, the code in this folder automates the process of generating documentation for a given repository based on the provided configuration options. The generated documentation can be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["863", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"376f96417f8cbea6a5ab2463268fe4af\"\n    },\n    {\n      \"folderName\": \"init\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n      \"files\": [\n        {\n          \"fileName\": \"index.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\init\\\\index.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\init\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["864", {"page_content": "\"summary\": \"This code is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["865", {"page_content": "the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["866", {"page_content": "configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["867", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc project. It takes an optional `config` parameter of type `AutodocRepoConfig` and returns a new configuration object with default values for various properties.\\n\\n2. **How does the `init` function work and when is it called?**\\n\\n   The `init` function is an asynchronous function that initializes the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It takes an optional `config` parameter of type `AutodocRepoConfig` and prompts the user for input to set the configuration values. It is called when the user wants to set up the Autodoc configuration for their project.\\n\\n3. **What is the purpose of the `inquirer.prompt` calls in the `init` function?**\\n\\n   The `inquirer.prompt` calls are used to interactively prompt the user for input to set the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["868", {"page_content": "The `inquirer.prompt` calls are used to interactively prompt the user for input to set the configuration values for the Autodoc project. The user is asked for the repository name, repository URL, and the LLMs they have access to. The input is then used to create a new configuration object and write it to the `autodoc.config.json` file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["869", {"page_content": "\"checksum\": \"b93831ff1f4023ab61c3bea963a8a112\"\n        }\n      ],\n      \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["870", {"page_content": "\"summary\": \"The `index.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init` folder is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["871", {"page_content": "want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["872", {"page_content": "values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\nThis code is essential for setting up the Autodoc project, as it creates the necessary configuration file and gathers user input to customize the project. It works in conjunction with other parts of the project, such as the CLI and the documentation generation process, which rely on the configuration file to function correctly.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["873", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n    },\n    {\n      \"folderName\": \"query\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n      \"files\": [\n        {\n          \"fileName\": \"createChatChain.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["874", {"page_content": "\"summary\": \"This code defines a function `makeChain` that creates a chatbot for answering questions about a software project called `projectName`. The chatbot is trained on the content of the project, which is located at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters:\\n\\n- `projectName`: The name of the software project.\\n- `repositoryUrl`: The URL of the project's repository.\\n- `contentType`: The type of content the chatbot is trained on.\\n- `chatPrompt`: Additional instructions for answering questions about the content type.\\n- `targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["875", {"page_content": "The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for efficient nearest neighbor search.\\n- `llms`: An array of LLMModels, which are language models used for generating answers.\\n- `onTokenStream`: An optional callback function that is called when a new token is generated by the language model.\\n\\nThe `makeChain` function first creates a question generator using the `LLMChain` class. This generator is responsible for rephrasing follow-up questions to be standalone questions. It uses the `CONDENSE_PROMPT` template, which is defined at the beginning of the code.\\n\\nNext, the function creates a `QA_PROMPT` template using the `makeQAPrompt` function. This template is used to generate answers to the questions in a conversational manner, with hyperlinks back to GitHub and code examples where appropriate.\\n\\nFinally, the function creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["876", {"page_content": "a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project. The chatbot uses the `vectorstore` for efficient nearest neighbor search and the `llms` language models for generating answers. If the `onTokenStream` callback is provided, it will be called when a new token is generated by the language model.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["877", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `makeChain` function and what are its input parameters?\\n\\n   **Answer:** The `makeChain` function is used to create a `ChatVectorDBQAChain` instance, which is responsible for generating questions and answers based on the given input parameters. The input parameters include `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and an optional `onTokenStream` function.\\n\\n2. **Question:** What are the roles of `CONDENSE_PROMPT` and `QA_PROMPT` in this code?\\n\\n   **Answer:** `CONDENSE_PROMPT` is a template for generating standalone questions from a given chat history and follow-up question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to GitHub, based on the provided context and question. Both templates are used in the `LLMChain` and `loadQAChain` instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["878", {"page_content": "instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and when is it used?\\n\\n   **Answer:** The `onTokenStream` function is an optional callback that can be provided to the `makeChain` function. It is used to handle the streaming of tokens generated by the OpenAIChat instance. If provided, it will be called with each new token generated during the chat process.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["879", {"page_content": "\"checksum\": \"6869048a06de62499933b14c37cddc1d\"\n        },\n        {\n          \"fileName\": \"index.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\index.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["880", {"page_content": "\"summary\": \"This code defines a chatbot interface for the Autodoc project, which allows users to ask questions related to a specific codebase and receive answers in a conversational manner. The chatbot uses a combination of the `inquirer` library for user input, `marked` and `marked-terminal` for rendering Markdown output, and the `langchain` library for handling natural language processing tasks.\\n\\nThe `query` function is the main entry point for the chatbot. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store using the `HNSWLib` and `OpenAIEmbeddings` classes, and creates a chat chain using the `makeChain` function.\\n\\nThe chatbot interface is displayed using the `displayWelcomeMessage` function, which prints a welcome message to the console. The `getQuestion` function is used to prompt the user for a question", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["881", {"page_content": "message to the console. The `getQuestion` function is used to prompt the user for a question using the `inquirer` library. The chatbot then enters a loop, where it processes the user's question, generates a response using the chat chain, and displays the response as Markdown in the terminal.\\n\\nIf an error occurs during the processing of a question, the chatbot will display an error message and continue to prompt the user for a new question. The loop continues until the user types 'exit', at which point the chatbot terminates.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["882", {"page_content": "userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example would initialize the chatbot with the specified repository and user configurations, and start the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["883", {"page_content": "\"questions\": \"1. **What is the purpose of the `query` function in this code?**\\n\\n   The `query` function is responsible for handling user interactions with the chatbot. It takes in an AutodocRepoConfig object and an AutodocUserConfig object, sets up the necessary data structures, and then enters a loop where it prompts the user for questions, processes them, and displays the results.\\n\\n2. **How does the code handle rendering Markdown text in the terminal?**\\n\\n   The code uses the `marked` library along with a custom `TerminalRenderer` to render Markdown text in the terminal. The `marked` library is configured with the custom renderer using `marked.setOptions({ renderer: new TerminalRenderer() });`.\\n\\n3. **What is the purpose of the `chatHistory` variable and how is it used?**\\n\\n   The `chatHistory` variable is an array that stores the history of questions and answers in the chat session. It is used to keep track of the conversation between the user and the chatbot. When", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["884", {"page_content": "chat session. It is used to keep track of the conversation between the user and the chatbot. When a new question is asked, the chat history is passed to the `chain.call()` function, and the new question and its corresponding answer are added to the `chatHistory` array.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["885", {"page_content": "\"checksum\": \"19807a33957666422f31136970c37245\"\n        }\n      ],\n      \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["886", {"page_content": "\"summary\": \"The `query` folder in the Autodoc project contains code for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot is trained on the content of the project and provides answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate.\\n\\nThe main entry point for the chatbot is the `query` function in `index.ts`. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store and creates a chat chain using the `makeChain` function from `createChatChain.ts`.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["887", {"page_content": "repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example initializes the chatbot with the specified repository and user configurations and starts the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\\n\\nThe `createChatChain.ts` file defines the `makeChain` function, which creates a chatbot for answering questions about a software project. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["888", {"page_content": "takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and `onTokenStream`. It first creates a question generator using the `LLMChain` class, then creates a `QA_PROMPT` template using the `makeQAPrompt` function, and finally creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project.\\n\\nIn summary, the code in the `query` folder is responsible for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot uses a combination of natural language processing techniques and efficient nearest neighbor search to generate accurate and relevant answers for the user.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["889", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"9e0d0f111bf588e2df66862dce9db288\"\n    },\n    {\n      \"folderName\": \"user\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n      \"files\": [\n        {\n          \"fileName\": \"index.ts\",\n          \"filePath\": \"src\\\\cli\\\\commands\\\\user\\\\index.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\user\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["890", {"page_content": "\"summary\": \"This code is responsible for managing the user configuration for the Autodoc project. It provides a way to create, update, and save the user configuration file, which stores information about the user's access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function is used to create a default configuration object with the provided `config` parameter or with GPT-3 as the default LLM. This function is used to generate a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["891", {"page_content": "the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["892", {"page_content": "with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["893", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc user. It takes an optional `config` parameter and returns an object with a `llms` property, which is an array of LLM models.\\n\\n2. **How does the `user` function handle existing user configuration files?**\\n\\n   The `user` function checks if a user configuration file already exists using `fsSync.existsSync`. If it does, the user is prompted with a confirmation message to overwrite the existing configuration. If the user chooses not to overwrite, the process exits with a status code of 0.\\n\\n3. **What are the available choices for LLM models in the `user` function?**\\n\\n   The available choices for LLM models are GPT-3.5 Turbo, GPT-3.5 Turbo and GPT-4 8K (Early Access), and GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["894", {"page_content": "8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected value is stored in the `llms` property of the new configuration object.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["895", {"page_content": "\"checksum\": \"76bc1e6d5d61e24907832c4cac443225\"\n        }\n      ],\n      \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["896", {"page_content": "\"summary\": \"The `index.ts` file in the `user` folder is responsible for managing the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with either the provided `config` parameter or GPT-3 as the default LLM. This function is useful for generating a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["897", {"page_content": "process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nThis code is essential for the Autodoc project as it allows users to manage their access to different LLMs and store their preferences in a configuration file. This configuration file can", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["898", {"page_content": "to different LLMs and store their preferences in a configuration file. This configuration file can then be used by other parts of the project to determine which LLMs the user has access to and tailor the querying process accordingly.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the `index.ts` file in the `user` folder is a crucial part of the Autodoc project, allowing users to manage their LLM access and preferences. This configuration is then used by other parts of the project to provide a tailored experience based on the user's access to different LLMs.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["899", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n    }\n  ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["900", {"page_content": "\"summary\": \"The code in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands` folder is responsible for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project. The folder contains several subfolders, each with a specific purpose.\\n\\n### estimate\\n\\nThe `estimate` function provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input and performs a dry run of the repository processing to calculate the estimated cost. Example usage:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["901", {"page_content": "filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\n### index\\n\\nThe code in this folder processes a given repository and generates documentation in JSON, Markdown, and vector formats. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository, creating Markdown files, and creating vector files. Example usage:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\n### init\\n\\nThe `init` function initializes the configuration of the Autodoc project. It prompts the user to input necessary information to set up the project and creates the `autodoc.config.json` file in the project root. Example", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["902", {"page_content": "to set up the project and creates the `autodoc.config.json` file in the project root. Example usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\n### query\\n\\nThe `query` folder contains code for creating a chatbot that can answer questions about a specific software project. The main entry point is the `query` function, which takes an `AutodocRepoConfig` object and an `AutodocUserConfig` object as input. Example usage:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["903", {"page_content": "'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\n### user\\n\\nThe `user` folder manages the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs). Example usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the code in this folder is essential for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["904", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"d11f941351fb51140313ada9b52bbf1a\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/summary.json"}, "type": "Document"}], ["905", {"page_content": "{\n  \"fileName\": \"index.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\user\\\\index.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\user\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/index.json"}, "type": "Document"}], ["906", {"page_content": "\"summary\": \"This code is responsible for managing the user configuration for the Autodoc project. It provides a way to create, update, and save the user configuration file, which stores information about the user's access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function is used to create a default configuration object with the provided `config` parameter or with GPT-3 as the default LLM. This function is used to generate a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/index.json"}, "type": "Document"}], ["907", {"page_content": "configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/index.json"}, "type": "Document"}], ["908", {"page_content": "with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/index.json"}, "type": "Document"}], ["909", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc user. It takes an optional `config` parameter and returns an object with a `llms` property, which is an array of LLM models.\\n\\n2. **How does the `user` function handle existing user configuration files?**\\n\\n   The `user` function checks if a user configuration file already exists using `fsSync.existsSync`. If it does, the user is prompted with a confirmation message to overwrite the existing configuration. If the user chooses not to overwrite, the process exits with a status code of 0.\\n\\n3. **What are the available choices for LLM models in the `user` function?**\\n\\n   The available choices for LLM models are GPT-3.5 Turbo, GPT-3.5 Turbo and GPT-4 8K (Early Access), and GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/index.json"}, "type": "Document"}], ["910", {"page_content": "Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected value is stored in the `llms` property of the new configuration object.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/index.json"}, "type": "Document"}], ["911", {"page_content": "\"checksum\": \"76bc1e6d5d61e24907832c4cac443225\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/index.json"}, "type": "Document"}], ["912", {"page_content": "{\n  \"folderName\": \"user\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n  \"files\": [\n    {\n      \"fileName\": \"index.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\user\\\\index.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\user\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["913", {"page_content": "\"summary\": \"This code is responsible for managing the user configuration for the Autodoc project. It provides a way to create, update, and save the user configuration file, which stores information about the user's access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function is used to create a default configuration object with the provided `config` parameter or with GPT-3 as the default LLM. This function is used to generate a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["914", {"page_content": "user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["915", {"page_content": "with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["916", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc user. It takes an optional `config` parameter and returns an object with a `llms` property, which is an array of LLM models.\\n\\n2. **How does the `user` function handle existing user configuration files?**\\n\\n   The `user` function checks if a user configuration file already exists using `fsSync.existsSync`. If it does, the user is prompted with a confirmation message to overwrite the existing configuration. If the user chooses not to overwrite, the process exits with a status code of 0.\\n\\n3. **What are the available choices for LLM models in the `user` function?**\\n\\n   The available choices for LLM models are GPT-3.5 Turbo, GPT-3.5 Turbo and GPT-4 8K (Early Access), and GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["917", {"page_content": "8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected value is stored in the `llms` property of the new configuration object.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["918", {"page_content": "\"checksum\": \"76bc1e6d5d61e24907832c4cac443225\"\n    }\n  ],\n  \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["919", {"page_content": "\"summary\": \"The `index.ts` file in the `user` folder is responsible for managing the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with either the provided `config` parameter or GPT-3 as the default LLM. This function is useful for generating a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["920", {"page_content": "exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nThis code is essential for the Autodoc project as it allows users to manage their access to different LLMs and store their preferences in a configuration file. This configuration file can then be", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["921", {"page_content": "LLMs and store their preferences in a configuration file. This configuration file can then be used by other parts of the project to determine which LLMs the user has access to and tailor the querying process accordingly.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the `index.ts` file in the `user` folder is a crucial part of the Autodoc project, allowing users to manage their LLM access and preferences. This configuration is then used by other parts of the project to provide a tailored experience based on the user's access to different LLMs.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["922", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/user/summary.json"}, "type": "Document"}], ["923", {"page_content": "{\n  \"fileName\": \"index.ts\",\n  \"filePath\": \"src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/index.json"}, "type": "Document"}], ["924", {"page_content": "\"summary\": \"The `estimate` function in this code is responsible for providing an estimated cost of processing a given repository using the Autodoc project. It takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function starts by constructing the path to the JSON output directory, which will be used to store the intermediate results of the processing. It then updates the spinner text to indicate that the cost estimation is in progress.\\n\\nNext, the `processRepository` function is called with the provided configuration options and a `true` flag to indicate that this is a dry run. This means that the repository will not actually be processed, but the function will return the details of what would happen if it were processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/index.json"}, "type": "Document"}], ["925", {"page_content": "processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce the dry run is complete, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is then calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in a red color. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git',", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/index.json"}, "type": "Document"}], ["926", {"page_content": "root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/index.json"}, "type": "Document"}], ["927", {"page_content": "\"questions\": \"1. **What is the purpose of the `estimate` function?**\\n\\n   The `estimate` function is used to perform a dry run of the `processRepository` command to get an estimated price for indexing the given repository. It then prints the model details and the total estimated cost.\\n\\n2. **What are the parameters passed to the `processRepository` function?**\\n\\n   The `processRepository` function is called with an object containing the following properties: `name`, `repositoryUrl`, `root`, `output`, `llms`, `ignore`, `filePrompt`, `folderPrompt`, `chatPrompt`, `contentType`, `targetAudience`, and `linkHosted`. Additionally, a second argument `true` is passed to indicate that it's a dry run.\\n\\n3. **How is the total estimated cost calculated and displayed?**\\n\\n   The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes an array of values from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/index.json"}, "type": "Document"}], ["928", {"page_content": "the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for formatting, showing the cost with two decimal places and a note that the actual cost may vary.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/index.json"}, "type": "Document"}], ["929", {"page_content": "\"checksum\": \"2b0b3903432ae423bbc597d04b052ecb\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/index.json"}, "type": "Document"}], ["930", {"page_content": "{\n  \"folderName\": \"estimate\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n  \"files\": [\n    {\n      \"fileName\": \"index.ts\",\n      \"filePath\": \"src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["931", {"page_content": "\"summary\": \"The `estimate` function in this code is responsible for providing an estimated cost of processing a given repository using the Autodoc project. It takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function starts by constructing the path to the JSON output directory, which will be used to store the intermediate results of the processing. It then updates the spinner text to indicate that the cost estimation is in progress.\\n\\nNext, the `processRepository` function is called with the provided configuration options and a `true` flag to indicate that this is a dry run. This means that the repository will not actually be processed, but the function will return the details of what would happen if it were processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["932", {"page_content": "were processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce the dry run is complete, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is then calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in a red color. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git',", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["933", {"page_content": "root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["934", {"page_content": "\"questions\": \"1. **What is the purpose of the `estimate` function?**\\n\\n   The `estimate` function is used to perform a dry run of the `processRepository` command to get an estimated price for indexing the given repository. It then prints the model details and the total estimated cost.\\n\\n2. **What are the parameters passed to the `processRepository` function?**\\n\\n   The `processRepository` function is called with an object containing the following properties: `name`, `repositoryUrl`, `root`, `output`, `llms`, `ignore`, `filePrompt`, `folderPrompt`, `chatPrompt`, `contentType`, `targetAudience`, and `linkHosted`. Additionally, a second argument `true` is passed to indicate that it's a dry run.\\n\\n3. **How is the total estimated cost calculated and displayed?**\\n\\n   The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes an array of values from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["935", {"page_content": "from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for formatting, showing the cost with two decimal places and a note that the actual cost may vary.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["936", {"page_content": "\"checksum\": \"2b0b3903432ae423bbc597d04b052ecb\"\n    }\n  ],\n  \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["937", {"page_content": "\"summary\": \"The `estimate` function in `index.ts` is a crucial part of the Autodoc project, as it provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input, containing various configuration options such as repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function begins by constructing the path to the JSON output directory, which stores intermediate results of the processing. It then updates the spinner text to indicate that cost estimation is in progress. The `processRepository` function is called with the provided configuration options and a `true` flag, signifying a dry run. This dry run returns the details of what would happen if the repository were processed, which is used to calculate the estimated cost.\\n\\nUpon completion of the dry run, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["938", {"page_content": "is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in red. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["939", {"page_content": "true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["940", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/cli/commands/estimate/summary.json"}, "type": "Document"}], ["941", {"page_content": "{\n  \"fileName\": \"index.ts\",\n  \"filePath\": \"src\\\\index.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/index.json"}, "type": "Document"}], ["942", {"page_content": "\"summary\": \"This code is the main entry point for the Autodoc CLI tool, which provides a set of commands to help developers automatically generate documentation for their codebase. The tool uses the `commander` library to define and handle commands, and `inquirer` for interactive prompts.\\n\\nThe available commands are:\\n\\n1. `init`: Initializes the repository by creating an `autodoc.config.json` file in the current directory. If the file already exists, it uses the existing configuration.\\n   ```bash\\n   autodoc init\\n   ```\\n\\n2. `estimate`: Estimates the cost of running the `index` command on the repository. It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc estimate\\n   ```\\n\\n3. `index`: Traverses the codebase, writes documentation using LLM, and creates a locally stored index. Before starting the indexing process, it prompts the user for confirmation. It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc index\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/index.json"}, "type": "Document"}], ["943", {"page_content": "It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc index\\n   ```\\n\\n4. `user`: Sets the Autodoc user configuration. If a user configuration file exists, it uses the existing configuration.\\n   ```bash\\n   autodoc user\\n   ```\\n\\n5. `q`: Queries an Autodoc index. It requires both the `autodoc.config.json` and user configuration files to be present.\\n   ```bash\\n   autodoc q\\n   ```\\n\\nThe code also listens for unhandled promise rejections and handles them gracefully by showing an error spinner, stopping the spinner, and exiting with an error code.\\n\\nIn the larger project, this CLI tool serves as the primary interface for users to interact with Autodoc, allowing them to easily generate and manage documentation for their codebase.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/index.json"}, "type": "Document"}], ["944", {"page_content": "\"questions\": \"1. **What is the purpose of the Autodoc CLI Tool?**\\n\\n   The Autodoc CLI Tool is designed to help developers automatically generate documentation for their codebase by traversing the code, writing docs via LLM, and creating a locally stored index.\\n\\n2. **How does the `estimate` command work and what does it return?**\\n\\n   The `estimate` command reads the `autodoc.config.json` file and estimates the cost of running the `index` command on the repository. It provides an estimation of the resources required to generate the documentation.\\n\\n3. **What is the role of the `user` command and how does it interact with the user configuration file?**\\n\\n   The `user` command is responsible for setting the Autodoc user configuration. It reads the user configuration file (if it exists) and allows the user to update or create a new configuration. This configuration is then used in other commands, such as the `query` command, to interact with the Autodoc index.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/index.json"}, "type": "Document"}], ["945", {"page_content": "\"checksum\": \"7bc160e4c4ef027d4968e3650a305a7d\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/index.json"}, "type": "Document"}], ["946", {"page_content": "{\n  \"folderName\": \"langchain\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\langchain\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\langchain\",\n  \"files\": [\n    {\n      \"fileName\": \"hnswlib.ts\",\n      \"filePath\": \"src\\\\langchain\\\\hnswlib.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\langchain\\\\hnswlib.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["947", {"page_content": "\"summary\": \"The `HNSWLib` class in this code is a specialized vector store that uses the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. It is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. The main purpose of this class is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\\n\\nThe constructor of the `HNSWLib` class takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is used to convert documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.\\n\\nThe `addDocuments` method takes an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["948", {"page_content": "converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\\n\\nThe `save` and `load` methods allow for persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\\n\\nHere's an example of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["949", {"page_content": "Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nIn the larger project, the `HNSWLib` class can be used to efficiently store and search for documents based on their content similarity, which can be useful for tasks such as document clustering, recommendation systems, or information retrieval.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["950", {"page_content": "\"questions\": \"1. **Question**: What is the purpose of the `HNSWLib` class and how does it relate to the `SaveableVectorStore` class?\\n   **Answer**: The `HNSWLib` class is an implementation of a vector store using the Hierarchical Navigable Small World (HNSW) algorithm from the `hnswlib-node` library. It extends the `SaveableVectorStore` class, which provides a base class for vector stores that can be saved and loaded from disk.\\n\\n2. **Question**: How does the `addDocuments` method work and what is its purpose?\\n   **Answer**: The `addDocuments` method takes an array of `Document` objects, extracts their `pageContent`, and embeds them using the provided `Embeddings` instance. It then adds the resulting vectors and documents to the HNSW index and the `InMemoryDocstore`, respectively.\\n\\n3. **Question**: How does the `similaritySearchVectorWithScore` method work and what does it return?\\n   **Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a number", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["951", {"page_content": "**Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a number `k` as input, and searches for the `k` most similar vectors in the HNSW index. It returns an array of tuples, where each tuple contains a `Document` object and its corresponding similarity score to the query vector.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["952", {"page_content": "\"checksum\": \"4725f6bfddda88355b55a980a1eae582\"\n    }\n  ],\n  \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["953", {"page_content": "\"summary\": \"The `hnswlib.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\langchain` folder contains the `HNSWLib` class, which is a specialized vector store utilizing the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. This class is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. Its primary purpose is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\\n\\nThe `HNSWLib` class constructor takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is responsible for converting documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.\\n\\nThe `addDocuments` method accepts an array of `Document` objects, converts them into embeddings using the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["954", {"page_content": "method accepts an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\\n\\nThe `save` and `load` methods enable persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\\n\\nIn the larger project, the `HNSWLib` class can be employed to efficiently store and search for documents based on their content similarity, which can be beneficial for tasks such as document clustering, recommendation systems, or information retrieval.\\n\\nHere's an example of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ...", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["955", {"page_content": "of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nThis code snippet demonstrates how to create an `HNSWLib` instance, add documents to the index, and perform a similarity search. The results can then be used for various purposes, such as finding related documents or generating recommendations based on content similarity.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["956", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"ccbe47bddb9d048f35d29fb2d8c04d7f\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/summary.json"}, "type": "Document"}], ["957", {"page_content": "{\n  \"fileName\": \"hnswlib.ts\",\n  \"filePath\": \"src\\\\langchain\\\\hnswlib.ts\",\n  \"url\": \"https://github.com/context-labs/autodoc/src\\\\langchain\\\\hnswlib.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/hnswlib.json"}, "type": "Document"}], ["958", {"page_content": "\"summary\": \"The `HNSWLib` class in this code is a specialized vector store that uses the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. It is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. The main purpose of this class is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\\n\\nThe constructor of the `HNSWLib` class takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is used to convert documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.\\n\\nThe `addDocuments` method takes an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/hnswlib.json"}, "type": "Document"}], ["959", {"page_content": "converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\\n\\nThe `save` and `load` methods allow for persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\\n\\nHere's an example of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/hnswlib.json"}, "type": "Document"}], ["960", {"page_content": "Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nIn the larger project, the `HNSWLib` class can be used to efficiently store and search for documents based on their content similarity, which can be useful for tasks such as document clustering, recommendation systems, or information retrieval.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/hnswlib.json"}, "type": "Document"}], ["961", {"page_content": "\"questions\": \"1. **Question**: What is the purpose of the `HNSWLib` class and how does it relate to the `SaveableVectorStore` class?\\n   **Answer**: The `HNSWLib` class is an implementation of a vector store using the Hierarchical Navigable Small World (HNSW) algorithm from the `hnswlib-node` library. It extends the `SaveableVectorStore` class, which provides a base class for vector stores that can be saved and loaded from disk.\\n\\n2. **Question**: How does the `addDocuments` method work and what is its purpose?\\n   **Answer**: The `addDocuments` method takes an array of `Document` objects, extracts their `pageContent`, and embeds them using the provided `Embeddings` instance. It then adds the resulting vectors and documents to the HNSW index and the `InMemoryDocstore`, respectively.\\n\\n3. **Question**: How does the `similaritySearchVectorWithScore` method work and what does it return?\\n   **Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a number `k`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/hnswlib.json"}, "type": "Document"}], ["962", {"page_content": "**Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a number `k` as input, and searches for the `k` most similar vectors in the HNSW index. It returns an array of tuples, where each tuple contains a `Document` object and its corresponding similarity score to the query vector.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/hnswlib.json"}, "type": "Document"}], ["963", {"page_content": "\"checksum\": \"4725f6bfddda88355b55a980a1eae582\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/langchain/hnswlib.json"}, "type": "Document"}], ["964", {"page_content": "{\n  \"folderName\": \"src\",\n  \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\",\n  \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\",\n  \"files\": [\n    {\n      \"fileName\": \"const.ts\",\n      \"filePath\": \"src\\\\const.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\const.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["965", {"page_content": "\"summary\": \"The code in this file is responsible for managing the user configuration file for the autodoc project. It imports two Node.js built-in modules, `path` and `os`, which are used to handle file paths and operating system-related utility functions, respectively.\\n\\nThe `userConfigFileName` constant is defined as `'autodoc.user.json'`, which represents the name of the user configuration file. This file is expected to store user-specific settings for the autodoc project in JSON format.\\n\\nThe `userConfigFilePath` constant is created using the `path.resolve()` function, which combines the provided arguments into an absolute file path. The `os.homedir()` function is used to get the current user's home directory, and `./.config/autodoc/` is appended to it as the folder where the user configuration file should be stored. Finally, the `userConfigFileName` constant is appended to the path, resulting in the complete file path for the user configuration file.\\n\\nBy exporting both", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["966", {"page_content": "the path, resulting in the complete file path for the user configuration file.\\n\\nBy exporting both `userConfigFileName` and `userConfigFilePath`, other parts of the autodoc project can easily access and use these constants to read or write user-specific settings. For example, when the autodoc application starts, it can read the user configuration file from the specified path, and apply the settings accordingly.\\n\\nHere's a code example of how these constants might be used in another part of the autodoc project:\\n\\n```javascript\\nimport { userConfigFilePath } from './path/to/this/file';\\n\\n// Read user configuration from the file\\nconst userConfig = JSON.parse(fs.readFileSync(userConfigFilePath, 'utf-8'));\\n\\n// Apply user settings\\napplyUserSettings(userConfig);\\n```\\n\\nIn summary, this code is responsible for defining the name and file path of the user configuration file for the autodoc project, allowing other parts of the project to easily access and manage user-specific", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["967", {"page_content": "the autodoc project, allowing other parts of the project to easily access and manage user-specific settings.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["968", {"page_content": "\"questions\": \"1. **What is the purpose of the `userConfigFileName` and `userConfigFilePath` constants?**\\n\\n   The `userConfigFileName` constant defines the name of the user configuration file for the autodoc project, while the `userConfigFilePath` constant defines the absolute path to this file, which is located in the user's home directory under the `.config/autodoc/` folder.\\n\\n2. **Why are the `node:path` and `node:os` modules being imported?**\\n\\n   The `node:path` module is imported to provide utilities for working with file and directory paths, such as resolving the absolute path to the user configuration file. The `node:os` module is imported to provide operating system-related utility methods, such as getting the user's home directory.\\n\\n3. **Is this code compatible with different operating systems?**\\n\\n   Yes, this code is compatible with different operating systems. The `os.homedir()` method returns the home directory of the current user, which is platform-specific,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["969", {"page_content": "`os.homedir()` method returns the home directory of the current user, which is platform-specific, and the `path.resolve()` method takes care of handling the correct path separators for the current operating system.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["970", {"page_content": "\"checksum\": \"ce40980fffc58e17b13690b9e37a6015\"\n    },\n    {\n      \"fileName\": \"index.ts\",\n      \"filePath\": \"src\\\\index.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["971", {"page_content": "\"summary\": \"This code is the main entry point for the Autodoc CLI tool, which provides a set of commands to help developers automatically generate documentation for their codebase. The tool uses the `commander` library to define and handle commands, and `inquirer` for interactive prompts.\\n\\nThe available commands are:\\n\\n1. `init`: Initializes the repository by creating an `autodoc.config.json` file in the current directory. If the file already exists, it uses the existing configuration.\\n   ```bash\\n   autodoc init\\n   ```\\n\\n2. `estimate`: Estimates the cost of running the `index` command on the repository. It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc estimate\\n   ```\\n\\n3. `index`: Traverses the codebase, writes documentation using LLM, and creates a locally stored index. Before starting the indexing process, it prompts the user for confirmation. It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc index\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["972", {"page_content": "It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc index\\n   ```\\n\\n4. `user`: Sets the Autodoc user configuration. If a user configuration file exists, it uses the existing configuration.\\n   ```bash\\n   autodoc user\\n   ```\\n\\n5. `q`: Queries an Autodoc index. It requires both the `autodoc.config.json` and user configuration files to be present.\\n   ```bash\\n   autodoc q\\n   ```\\n\\nThe code also listens for unhandled promise rejections and handles them gracefully by showing an error spinner, stopping the spinner, and exiting with an error code.\\n\\nIn the larger project, this CLI tool serves as the primary interface for users to interact with Autodoc, allowing them to easily generate and manage documentation for their codebase.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["973", {"page_content": "\"questions\": \"1. **What is the purpose of the Autodoc CLI Tool?**\\n\\n   The Autodoc CLI Tool is designed to help developers automatically generate documentation for their codebase by traversing the code, writing docs via LLM, and creating a locally stored index.\\n\\n2. **How does the `estimate` command work and what does it return?**\\n\\n   The `estimate` command reads the `autodoc.config.json` file and estimates the cost of running the `index` command on the repository. It provides an estimation of the resources required to generate the documentation.\\n\\n3. **What is the role of the `user` command and how does it interact with the user configuration file?**\\n\\n   The `user` command is responsible for setting the Autodoc user configuration. It reads the user configuration file (if it exists) and allows the user to update or create a new configuration. This configuration is then used in other commands, such as the `query` command, to interact with the Autodoc index.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["974", {"page_content": "\"checksum\": \"7bc160e4c4ef027d4968e3650a305a7d\"\n    },\n    {\n      \"fileName\": \"types.ts\",\n      \"filePath\": \"src\\\\types.ts\",\n      \"url\": \"https://github.com/context-labs/autodoc/src\\\\types.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["975", {"page_content": "\"summary\": \"This code defines the types and interfaces for the `autodoc` project, which aims to automatically generate documentation for a given code repository. The project uses OpenAI's language models (LLMs) to process and generate summaries, questions, and other relevant information for files and folders in the repository.\\n\\nThe `AutodocUserConfig` and `AutodocRepoConfig` types define the configuration options for the user and repository, respectively. These include settings such as the LLM models to use, repository URL, output directory, and content type.\\n\\n`FileSummary` and `FolderSummary` types represent the generated summaries for files and folders, including their paths, URLs, and checksums. The `ProcessFileParams` and `ProcessFolderParams` types define the parameters required for processing files and folders, such as the file or folder name, path, and content type.\\n\\n`ProcessFile` and `ProcessFolder` are function types that take the respective parameters and return", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["976", {"page_content": "and `ProcessFolder` are function types that take the respective parameters and return a promise. These functions are responsible for processing the files and folders, generating summaries, and updating the documentation.\\n\\n`TraverseFileSystemParams` type defines the parameters for traversing the file system, including the input path, project name, and optional `processFile` and `processFolder` functions. It also includes settings for ignoring certain files or folders and content type preferences.\\n\\nThe `LLMModels` enum lists the available language models, such as GPT-3.5 Turbo, GPT-4, and GPT-4 32k. The `LLMModelDetails` type provides information about each model, including the cost per 1K tokens, maximum length, and success/failure statistics.\\n\\nIn the larger project, these types and interfaces would be used to configure and run the `autodoc` tool, allowing users to automatically generate documentation for their code repositories using OpenAI's language models. For example, a user", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["977", {"page_content": "documentation for their code repositories using OpenAI's language models. For example, a user could provide an `AutodocRepoConfig` object to configure the tool, and then use the `TraverseFileSystem` function to process the repository and generate the documentation.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["978", {"page_content": "\"questions\": \"1. **What is the purpose of the `AutodocUserConfig` and `AutodocRepoConfig` types?**\\n\\n   The `AutodocUserConfig` type is used to define the user configuration for the autodoc project, which includes an array of LLMModels. The `AutodocRepoConfig` type is used to define the repository configuration for the autodoc project, which includes various properties such as name, repository URL, root, output, LLMModels, and more.\\n\\n2. **What are the different LLMModels available in the `LLMModels` enum?**\\n\\n   The `LLMModels` enum lists the available language models for the autodoc project. Currently, there are three models: GPT3 (gpt-3.5-turbo), GPT4 (gpt-4), and GPT432k (gpt-4-32k).\\n\\n3. **What is the purpose of the `ProcessFile` and `ProcessFolder` types?**\\n\\n   The `ProcessFile` type is a function type that takes a `ProcessFileParams` object as input and returns a Promise. It is used to process a single file in the autodoc project. The `ProcessFolder` type is a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["979", {"page_content": "Promise. It is used to process a single file in the autodoc project. The `ProcessFolder` type is a function type that takes a `ProcessFolderParams` object as input and returns a Promise. It is used to process a folder in the autodoc project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["980", {"page_content": "\"checksum\": \"796822d4da09cce719cb86b540d2fb66\"\n    }\n  ],\n  \"folders\": [\n    {\n      \"folderName\": \"cli\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\",\n      \"files\": [\n        {\n          \"fileName\": \"spinner.ts\",\n          \"filePath\": \"src\\\\cli\\\\spinner.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\spinner.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["981", {"page_content": "\"summary\": \"This code is responsible for managing a spinner, which is a visual element that indicates a process is running in the background. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\\n\\nThe code starts by importing the `ora` library and creating a singleton spinner instance with the 'dots' style. This ensures that there will only be one spinner active at any given time.\\n\\nThere are several functions exported by this module to interact with the spinner:\\n\\n1. `updateSpinnerText(message: string)`: This function updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\\n\\n   Example usage:\\n   ```javascript\\n   updateSpinnerText('Loading data...');\\n   ```\\n\\n2. `stopSpinner()`: This function stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["982", {"page_content": "This function stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   stopSpinner();\\n   ```\\n\\n3. `spinnerError(message?: string)`: This function stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerError('Failed to load data');\\n   ```\\n\\n4. `spinnerSuccess(message?: string)`: This function stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerSuccess('Data loaded successfully');\\n   ```\\n\\n5. `spinnerInfo(message: string)`: This function displays an informational message without affecting the spinner's state.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerInfo('Connecting to server...');\\n   ```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["983", {"page_content": "```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["984", {"page_content": "\"questions\": \"1. **What is the purpose of the `ora` package in this code?**\\n\\n   The `ora` package is used to create a spinner in the command line interface, providing a visual indication of a running process. In this code, it is used to create a singleton spinner with the 'dots' style.\\n\\n2. **How does the `updateSpinnerText` function work?**\\n\\n   The `updateSpinnerText` function takes a message as an input and updates the spinner's text with the given message. If the spinner is already spinning, it updates the text directly; otherwise, it starts the spinner with the new message.\\n\\n3. **What are the differences between `spinnerError`, `spinnerSuccess`, and `spinnerInfo` functions?**\\n\\n   These functions are used to update the spinner's state and message based on the outcome of a process. `spinnerError` is called when there is an error, and it stops the spinner with a failure message. `spinnerSuccess` is called when the process is successful, and it stops the spinner", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["985", {"page_content": "message. `spinnerSuccess` is called when the process is successful, and it stops the spinner with a success message. `spinnerInfo` is used to display an informational message without stopping the spinner.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["986", {"page_content": "\"checksum\": \"d93ad7e714ce5446916bb1d63cbb6031\"\n        }\n      ],\n      \"folders\": [\n        {\n          \"folderName\": \"commands\",\n          \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\",\n          \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\",\n          \"files\": [],\n          \"folders\": [\n            {\n              \"folderName\": \"estimate\",\n              \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n              \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate\",\n              \"files\": [\n                {\n                  \"fileName\": \"index.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\estimate\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["987", {"page_content": "\"summary\": \"The `estimate` function in this code is responsible for providing an estimated cost of processing a given repository using the Autodoc project. It takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function starts by constructing the path to the JSON output directory, which will be used to store the intermediate results of the processing. It then updates the spinner text to indicate that the cost estimation is in progress.\\n\\nNext, the `processRepository` function is called with the provided configuration options and a `true` flag to indicate that this is a dry run. This means that the repository will not actually be processed, but the function will return the details of what would happen if it were processed. This is used to calculate the estimated cost of processing the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["988", {"page_content": "would happen if it were processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce the dry run is complete, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is then calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in a red color. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["989", {"page_content": "'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["990", {"page_content": "\"questions\": \"1. **What is the purpose of the `estimate` function?**\\n\\n   The `estimate` function is used to perform a dry run of the `processRepository` command to get an estimated price for indexing the given repository. It then prints the model details and the total estimated cost.\\n\\n2. **What are the parameters passed to the `processRepository` function?**\\n\\n   The `processRepository` function is called with an object containing the following properties: `name`, `repositoryUrl`, `root`, `output`, `llms`, `ignore`, `filePrompt`, `folderPrompt`, `chatPrompt`, `contentType`, `targetAudience`, and `linkHosted`. Additionally, a second argument `true` is passed to indicate that it's a dry run.\\n\\n3. **How is the total estimated cost calculated and displayed?**\\n\\n   The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes an array of values from the `runDetails` object. The cost is then displayed using `console.log` with", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["991", {"page_content": "array of values from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for formatting, showing the cost with two decimal places and a note that the actual cost may vary.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["992", {"page_content": "\"checksum\": \"2b0b3903432ae423bbc597d04b052ecb\"\n                }\n              ],\n              \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["993", {"page_content": "\"summary\": \"The `estimate` function in `index.ts` is a crucial part of the Autodoc project, as it provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input, containing various configuration options such as repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function begins by constructing the path to the JSON output directory, which stores intermediate results of the processing. It then updates the spinner text to indicate that cost estimation is in progress. The `processRepository` function is called with the provided configuration options and a `true` flag, signifying a dry run. This dry run returns the details of what would happen if the repository were processed, which is used to calculate the estimated cost.\\n\\nUpon completion of the dry run, the spinner is updated to show success, and the results are printed using the `printModelDetails`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["994", {"page_content": "the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in red. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["995", {"page_content": "true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["996", {"page_content": "\"questions\": \"\",\n              \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n            },\n            {\n              \"folderName\": \"index\",\n              \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n              \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index\",\n              \"files\": [\n                {\n                  \"fileName\": \"convertJsonToMarkdown.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["997", {"page_content": "\"summary\": \"The `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\\n\\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation generation process.\\n\\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.\\n\\nNext, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["998", {"page_content": "it, and converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\\n\\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\\n\\nExample usage:\\n\\n```javascript\\nconvertJsonToMarkdown({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will convert all JSON files in the `./input` directory into Markdown", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["999", {"page_content": "will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1000", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.\\n\\n2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1001", {"page_content": "for each code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1002", {"page_content": "\"checksum\": \"79c860becf47b9882441682f0213d534\"\n                },\n                {\n                  \"fileName\": \"createVectorStore.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1003", {"page_content": "\"summary\": \"The code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\\n\\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.\\n\\nThe `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1004", {"page_content": "object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.\\n\\nThe `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1005", {"page_content": "path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output: './data/vector_store',\\n};\\n\\ncreateVectorStore(config).then(() => {\\n  console.log('Vector store created successfully');\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1006", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processFile` function and what does it return?\\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\\n\\n2. **Question:** How does the `processDirectory` function work and what does it return?\\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.\\n\\n3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1007", {"page_content": "and how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1008", {"page_content": "\"checksum\": \"a3409c4340753a867c72eebef7626fb9\"\n                },\n                {\n                  \"fileName\": \"index.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\index.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1009", {"page_content": "\"summary\": \"The code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\\n\\nThe `index` function performs three main tasks:\\n\\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Processing repository...');\\n   await processRepository({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1010", {"page_content": "```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Creating markdown files...');\\n   await convertJsonToMarkdown({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Create vector files...');\\n   await createVectorStore({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\nThroughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1011", {"page_content": "the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\\n\\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1012", {"page_content": "\"questions\": \"1. **What does the `index` function do in this code?**\\n\\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\\n\\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**\\n\\n   The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\\n\\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\\n\\n   These prompts are likely used to interact with the user during the processing of the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1013", {"page_content": "code?**\\n\\n   These prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1014", {"page_content": "\"checksum\": \"4060b1affae5a6c385cda308b3cd1750\"\n                },\n                {\n                  \"fileName\": \"processRepository.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\processRepository.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1015", {"page_content": "\"summary\": \"The `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.\\n\\nThe function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1016", {"page_content": "on the input length, and calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\\n\\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.\\n\\nThe main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\\n\\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1017", {"page_content": "while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or folder.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1018", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.\\n\\n2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1019", {"page_content": "for the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.\\n\\n3. **Question:** How does the `reindexCheck` function work and when is it used?\\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1020", {"page_content": "\"checksum\": \"5b3ae9ffad1d4b4a22c6f7fd66bbde6f\"\n                },\n                {\n                  \"fileName\": \"prompts.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\prompts.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1021", {"page_content": "\"summary\": \"This code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\\n\\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\\n```\\n\\n2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1022", {"page_content": "This function generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\\n```\\n\\n3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1023", {"page_content": "function returns a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\\n```\\n\\nThese functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1024", {"page_content": "\"questions\": \"1. **What is the purpose of the `createCodeFileSummary` function?**\\n\\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\\n\\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\\n\\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\\n\\n3. **What is the role of the `folderSummaryPrompt` function?**\\n\\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1025", {"page_content": "\"checksum\": \"e44b82bf4912be69149685a997b6bde3\"\n                }\n              ],\n              \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1026", {"page_content": "\"summary\": \"The code in this folder is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It consists of several functions and utilities that work together to automate the documentation generation process.\\n\\nThe main function, `index`, takes an `AutodocRepoConfig` object as input, which contains various configuration options for processing the repository. It performs three main tasks:\\n\\n1. **Process the repository**: It calls the `processRepository` function to traverse the repository, generate summaries and questions for code files and folders using the LLMS (Language Learning Management System), and create JSON files with the results. These JSON files are stored in the `output/docs/json/` directory.\\n\\n2. **Create Markdown files**: It uses the `convertJsonToMarkdown` function to convert the generated JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1027", {"page_content": "JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n3. **Create vector files**: It calls the `createVectorStore` function to create vector files from the generated Markdown files. These vector files are stored in the `output/docs/data/` directory.\\n\\nThroughout the execution of these tasks, the code provides visual feedback on the progress of the tasks using `updateSpinnerText` and `spinnerSuccess` functions.\\n\\nHere's an example of how this code might be used:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will process the repository located at `./input`, generate documentation in JSON, Markdown, and vector formats, and save the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1028", {"page_content": "vector formats, and save the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains utility functions that generate prompts for documentation experts. These functions create markdown formatted strings with specific instructions for the documentation expert, ensuring consistent formatting and instructions across different parts of the project.\\n\\nIn summary, the code in this folder automates the process of generating documentation for a given repository based on the provided configuration options. The generated documentation can be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1029", {"page_content": "\"questions\": \"\",\n              \"checksum\": \"376f96417f8cbea6a5ab2463268fe4af\"\n            },\n            {\n              \"folderName\": \"init\",\n              \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n              \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init\",\n              \"files\": [\n                {\n                  \"fileName\": \"index.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\init\\\\index.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\init\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1030", {"page_content": "\"summary\": \"This code is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1031", {"page_content": "overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl:", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1032", {"page_content": "configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1033", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc project. It takes an optional `config` parameter of type `AutodocRepoConfig` and returns a new configuration object with default values for various properties.\\n\\n2. **How does the `init` function work and when is it called?**\\n\\n   The `init` function is an asynchronous function that initializes the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It takes an optional `config` parameter of type `AutodocRepoConfig` and prompts the user for input to set the configuration values. It is called when the user wants to set up the Autodoc configuration for their project.\\n\\n3. **What is the purpose of the `inquirer.prompt` calls in the `init` function?**\\n\\n   The `inquirer.prompt` calls are used to interactively prompt the user for input to set the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1034", {"page_content": "The `inquirer.prompt` calls are used to interactively prompt the user for input to set the configuration values for the Autodoc project. The user is asked for the repository name, repository URL, and the LLMs they have access to. The input is then used to create a new configuration object and write it to the `autodoc.config.json` file.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1035", {"page_content": "\"checksum\": \"b93831ff1f4023ab61c3bea963a8a112\"\n                }\n              ],\n              \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1036", {"page_content": "\"summary\": \"The `index.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init` folder is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1037", {"page_content": "want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1038", {"page_content": "values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\nThis code is essential for setting up the Autodoc project, as it creates the necessary configuration file and gathers user input to customize the project. It works in conjunction with other parts of the project, such as the CLI and the documentation generation process, which rely on the configuration file to function correctly.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1039", {"page_content": "\"questions\": \"\",\n              \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n            },\n            {\n              \"folderName\": \"query\",\n              \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n              \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query\",\n              \"files\": [\n                {\n                  \"fileName\": \"createChatChain.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1040", {"page_content": "\"summary\": \"This code defines a function `makeChain` that creates a chatbot for answering questions about a software project called `projectName`. The chatbot is trained on the content of the project, which is located at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters:\\n\\n- `projectName`: The name of the software project.\\n- `repositoryUrl`: The URL of the project's repository.\\n- `contentType`: The type of content the chatbot is trained on.\\n- `chatPrompt`: Additional instructions for answering questions about the content type.\\n- `targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1041", {"page_content": "`targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for efficient nearest neighbor search.\\n- `llms`: An array of LLMModels, which are language models used for generating answers.\\n- `onTokenStream`: An optional callback function that is called when a new token is generated by the language model.\\n\\nThe `makeChain` function first creates a question generator using the `LLMChain` class. This generator is responsible for rephrasing follow-up questions to be standalone questions. It uses the `CONDENSE_PROMPT` template, which is defined at the beginning of the code.\\n\\nNext, the function creates a `QA_PROMPT` template using the `makeQAPrompt` function. This template is used to generate answers to the questions in a conversational manner, with hyperlinks back to GitHub and code examples where appropriate.\\n\\nFinally, the function creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1042", {"page_content": "creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project. The chatbot uses the `vectorstore` for efficient nearest neighbor search and the `llms` language models for generating answers. If the `onTokenStream` callback is provided, it will be called when a new token is generated by the language model.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1043", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `makeChain` function and what are its input parameters?\\n\\n   **Answer:** The `makeChain` function is used to create a `ChatVectorDBQAChain` instance, which is responsible for generating questions and answers based on the given input parameters. The input parameters include `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and an optional `onTokenStream` function.\\n\\n2. **Question:** What are the roles of `CONDENSE_PROMPT` and `QA_PROMPT` in this code?\\n\\n   **Answer:** `CONDENSE_PROMPT` is a template for generating standalone questions from a given chat history and follow-up question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to GitHub, based on the provided context and question. Both templates are used in the `LLMChain` and `loadQAChain` instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1044", {"page_content": "`loadQAChain` instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and when is it used?\\n\\n   **Answer:** The `onTokenStream` function is an optional callback that can be provided to the `makeChain` function. It is used to handle the streaming of tokens generated by the OpenAIChat instance. If provided, it will be called with each new token generated during the chat process.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1045", {"page_content": "\"checksum\": \"6869048a06de62499933b14c37cddc1d\"\n                },\n                {\n                  \"fileName\": \"index.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\query\\\\index.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1046", {"page_content": "\"summary\": \"This code defines a chatbot interface for the Autodoc project, which allows users to ask questions related to a specific codebase and receive answers in a conversational manner. The chatbot uses a combination of the `inquirer` library for user input, `marked` and `marked-terminal` for rendering Markdown output, and the `langchain` library for handling natural language processing tasks.\\n\\nThe `query` function is the main entry point for the chatbot. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store using the `HNSWLib` and `OpenAIEmbeddings` classes, and creates a chat chain using the `makeChain` function.\\n\\nThe chatbot interface is displayed using the `displayWelcomeMessage` function, which prints a welcome message to the console. The `getQuestion` function is used to prompt the user for a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1047", {"page_content": "a welcome message to the console. The `getQuestion` function is used to prompt the user for a question using the `inquirer` library. The chatbot then enters a loop, where it processes the user's question, generates a response using the chat chain, and displays the response as Markdown in the terminal.\\n\\nIf an error occurs during the processing of a question, the chatbot will display an error message and continue to prompt the user for a new question. The loop continues until the user types 'exit', at which point the chatbot terminates.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1048", {"page_content": "'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example would initialize the chatbot with the specified repository and user configurations, and start the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1049", {"page_content": "\"questions\": \"1. **What is the purpose of the `query` function in this code?**\\n\\n   The `query` function is responsible for handling user interactions with the chatbot. It takes in an AutodocRepoConfig object and an AutodocUserConfig object, sets up the necessary data structures, and then enters a loop where it prompts the user for questions, processes them, and displays the results.\\n\\n2. **How does the code handle rendering Markdown text in the terminal?**\\n\\n   The code uses the `marked` library along with a custom `TerminalRenderer` to render Markdown text in the terminal. The `marked` library is configured with the custom renderer using `marked.setOptions({ renderer: new TerminalRenderer() });`.\\n\\n3. **What is the purpose of the `chatHistory` variable and how is it used?**\\n\\n   The `chatHistory` variable is an array that stores the history of questions and answers in the chat session. It is used to keep track of the conversation between the user and the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1050", {"page_content": "answers in the chat session. It is used to keep track of the conversation between the user and the chatbot. When a new question is asked, the chat history is passed to the `chain.call()` function, and the new question and its corresponding answer are added to the `chatHistory` array.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1051", {"page_content": "\"checksum\": \"19807a33957666422f31136970c37245\"\n                }\n              ],\n              \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1052", {"page_content": "\"summary\": \"The `query` folder in the Autodoc project contains code for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot is trained on the content of the project and provides answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate.\\n\\nThe main entry point for the chatbot is the `query` function in `index.ts`. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store and creates a chat chain using the `makeChain` function from `createChatChain.ts`.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1053", {"page_content": "'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example initializes the chatbot with the specified repository and user configurations and starts the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\\n\\nThe `createChatChain.ts` file defines the `makeChain` function, which creates a chatbot for answering questions about a software project. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1054", {"page_content": "takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and `onTokenStream`. It first creates a question generator using the `LLMChain` class, then creates a `QA_PROMPT` template using the `makeQAPrompt` function, and finally creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project.\\n\\nIn summary, the code in the `query` folder is responsible for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot uses a combination of natural language processing techniques and efficient nearest neighbor search to generate accurate and relevant answers for the user.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1055", {"page_content": "\"questions\": \"\",\n              \"checksum\": \"9e0d0f111bf588e2df66862dce9db288\"\n            },\n            {\n              \"folderName\": \"user\",\n              \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n              \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user\",\n              \"files\": [\n                {\n                  \"fileName\": \"index.ts\",\n                  \"filePath\": \"src\\\\cli\\\\commands\\\\user\\\\index.ts\",\n                  \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\user\\\\index.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1056", {"page_content": "\"summary\": \"This code is responsible for managing the user configuration for the Autodoc project. It provides a way to create, update, and save the user configuration file, which stores information about the user's access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function is used to create a default configuration object with the provided `config` parameter or with GPT-3 as the default LLM. This function is used to generate a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1057", {"page_content": "exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1058", {"page_content": "user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1059", {"page_content": "\"questions\": \"1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc user. It takes an optional `config` parameter and returns an object with a `llms` property, which is an array of LLM models.\\n\\n2. **How does the `user` function handle existing user configuration files?**\\n\\n   The `user` function checks if a user configuration file already exists using `fsSync.existsSync`. If it does, the user is prompted with a confirmation message to overwrite the existing configuration. If the user chooses not to overwrite, the process exits with a status code of 0.\\n\\n3. **What are the available choices for LLM models in the `user` function?**\\n\\n   The available choices for LLM models are GPT-3.5 Turbo, GPT-3.5 Turbo and GPT-4 8K (Early Access), and GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1060", {"page_content": "8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected value is stored in the `llms` property of the new configuration object.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1061", {"page_content": "\"checksum\": \"76bc1e6d5d61e24907832c4cac443225\"\n                }\n              ],\n              \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1062", {"page_content": "\"summary\": \"The `index.ts` file in the `user` folder is responsible for managing the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with either the provided `config` parameter or GPT-3 as the default LLM. This function is useful for generating a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1063", {"page_content": "process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nThis code is essential for the Autodoc project as it allows users to manage their access to different LLMs and store their preferences in a configuration file. This configuration file can", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1064", {"page_content": "to different LLMs and store their preferences in a configuration file. This configuration file can then be used by other parts of the project to determine which LLMs the user has access to and tailor the querying process accordingly.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the `index.ts` file in the `user` folder is a crucial part of the Autodoc project, allowing users to manage their LLM access and preferences. This configuration is then used by other parts of the project to provide a tailored experience based on the user's access to different LLMs.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1065", {"page_content": "\"questions\": \"\",\n              \"checksum\": \"4b8fd2b2abaec4959873fc3396c414d8\"\n            }\n          ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1066", {"page_content": "\"summary\": \"The code in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands` folder is responsible for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project. The folder contains several subfolders, each with a specific purpose.\\n\\n### estimate\\n\\nThe `estimate` function provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input and performs a dry run of the repository processing to calculate the estimated cost. Example usage:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1067", {"page_content": "filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\n### index\\n\\nThe code in this folder processes a given repository and generates documentation in JSON, Markdown, and vector formats. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository, creating Markdown files, and creating vector files. Example usage:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\n### init\\n\\nThe `init` function initializes the configuration of the Autodoc project. It prompts the user to input necessary information to set up the project and creates the `autodoc.config.json` file in the project root. Example", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1068", {"page_content": "to set up the project and creates the `autodoc.config.json` file in the project root. Example usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\n### query\\n\\nThe `query` folder contains code for creating a chatbot that can answer questions about a specific software project. The main entry point is the `query` function, which takes an `AutodocRepoConfig` object and an `AutodocUserConfig` object as input. Example usage:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1069", {"page_content": "'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\n### user\\n\\nThe `user` folder manages the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs). Example usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the code in this folder is essential for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1070", {"page_content": "\"questions\": \"\",\n          \"checksum\": \"d11f941351fb51140313ada9b52bbf1a\"\n        },\n        {\n          \"folderName\": \"utils\",\n          \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils\",\n          \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils\",\n          \"files\": [\n            {\n              \"fileName\": \"APIRateLimit.ts\",\n              \"filePath\": \"src\\\\cli\\\\utils\\\\APIRateLimit.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\APIRateLimit.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1071", {"page_content": "\"summary\": \"The `APIRateLimit` class in this code snippet is designed to manage and limit the number of concurrent API calls made by the application. This is useful in situations where the API being called has a rate limit or when the application needs to prevent overwhelming the server with too many requests at once.\\n\\nThe class constructor takes an optional parameter `maxConcurrentCalls`, which defaults to 50, to set the maximum number of concurrent API calls allowed. It maintains a queue of API calls and keeps track of the number of calls in progress.\\n\\nThe main method of this class is `callApi<T>(apiFunction: () => Promise<T>): Promise<T>`. It takes a function `apiFunction` that returns a promise and wraps it in a new promise. The purpose of this wrapping is to control the execution of the API calls and ensure that they do not exceed the specified rate limit.\\n\\nWhen `callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1072", {"page_content": "`callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is triggered if there are available slots for concurrent calls. The `dequeueAndExecute` method checks if there are any API calls in the queue and if the number of in-progress calls is below the maximum limit. If both conditions are met, it dequeues the next API call and executes it.\\n\\nThe `executeCall` function inside `callApi` is responsible for actually calling the API function, resolving or rejecting the promise based on the result, and updating the number of in-progress calls. Once an API call is completed, the `dequeueAndExecute` method is called again to process any remaining calls in the queue.\\n\\nHere's an example of how this class can be used in the larger project:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\n\\nasync function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1073", {"page_content": "function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls to the `fetch` function, ensuring that no more than 10 calls are made at once.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1074", {"page_content": "\"questions\": \"1. **What is the purpose of the `APIRateLimit` class?**\\n\\n   The `APIRateLimit` class is designed to manage and limit the number of concurrent API calls to a specified maximum, preventing the application from overwhelming the API with too many requests at once.\\n\\n2. **How does the `callApi` method work and what is its return type?**\\n\\n   The `callApi` method takes an `apiFunction` as an argument, which is a function that returns a Promise. It adds the API call to a queue and executes it when there are available slots for concurrent calls. The method returns a Promise of type `T`, where `T` is the expected return type of the `apiFunction`.\\n\\n3. **How can the maximum number of concurrent calls be configured?**\\n\\n   The maximum number of concurrent calls can be configured by passing a value to the `maxConcurrentCalls` parameter in the constructor of the `APIRateLimit` class. If no value is provided, the default value is set to 50.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1075", {"page_content": "\"checksum\": \"8862552c9cfd8b6db454d45e565081ef\"\n            },\n            {\n              \"fileName\": \"FileUtil.ts\",\n              \"filePath\": \"src\\\\cli\\\\utils\\\\FileUtil.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\FileUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1076", {"page_content": "\"summary\": \"This code provides utility functions for handling file and folder paths in the autodoc project. The main purpose of these functions is to generate file names and GitHub URLs for documentation files.\\n\\n1. `getFileName(input, delimiter, extension)`: This function takes an input string, an optional delimiter (default is '.'), and an optional extension (default is '.md'). It returns a new string with the given extension. If the delimiter is found in the input string, the function removes the part of the string after the last occurrence of the delimiter and appends the extension. If the delimiter is not found, the function simply appends the extension to the input string. This function can be used to generate file names for documentation files with the desired extension.\\n\\n   Example usage:\\n\\n   ```\\n   getFileName('example.txt'); // returns 'example.md'\\n   getFileName('example', '_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1077", {"page_content": "'_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot, inputRoot, filePath, linkHosted)`: This function generates a GitHub URL for a file. It takes the GitHub repository root URL, the input root folder path, the file path, and a boolean flag indicating whether the URL should be for the hosted version of the file or the source code. It returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true);\\n   // returns 'https://github.com/user/repo/example.md'\\n   ```\\n\\n3. `githubFolderUrl(githubRoot, inputRoot, folderPath, linkHosted)`: This function is similar to `githubFileUrl`, but it generates a GitHub URL for a folder instead of a file. It takes the same arguments as `githubFileUrl` and returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1078", {"page_content": "githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns 'https://github.com/user/repo/folder'\\n   ```\\n\\nThese utility functions can be used throughout the autodoc project to generate file names and GitHub URLs for documentation files and folders, ensuring consistent naming and URL generation across the project.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1079", {"page_content": "\"questions\": \"1. **What is the purpose of the `getFileName` function?**\\n\\n   The `getFileName` function takes an input string, an optional delimiter, and an optional extension, and returns a new string with the given extension. If the delimiter is not found in the input string, the extension is simply appended to the input string. If the delimiter is found, the input string is sliced up to the last delimiter index and the extension is appended.\\n\\n2. **What are the differences between the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   Both functions take the same parameters: `githubRoot`, `inputRoot`, a path (either `filePath` or `folderPath`), and a `linkHosted` boolean. The main difference is in the returned URL: `githubFileUrl` returns a URL pointing to a file in the GitHub repository, while `githubFolderUrl` returns a URL pointing to a folder in the GitHub repository. The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1080", {"page_content": "repository. The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for folders.\\n\\n3. **What is the purpose of the `linkHosted` parameter in the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   The `linkHosted` parameter is a boolean that determines whether the returned URL should point to the hosted version of the file or folder on GitHub Pages (if `true`) or to the file or folder within the GitHub repository itself (if `false`). Depending on the value of `linkHosted`, the functions will return different URL structures.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1081", {"page_content": "\"checksum\": \"d1f26fc674b4a9b4a2053642771871c8\"\n            },\n            {\n              \"fileName\": \"LLMUtil.ts\",\n              \"filePath\": \"src\\\\cli\\\\utils\\\\LLMUtil.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\LLMUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1082", {"page_content": "\"summary\": \"This code defines and manages different language models (LLMs) and their associated costs for a project that utilizes OpenAI's GPT models. It imports the `OpenAIChat` class from the `langchain/llms` module and the `LLMModelDetails` and `LLMModels` types from the `../../types.js` file.\\n\\nThe `models` object contains three LLMs: GPT3, GPT4, and GPT432k. Each model has its own properties, such as `name`, `inputCostPer1KTokens`, `outputCostPer1KTokens`, `maxLength`, and an instance of the `OpenAIChat` class with the respective model name and API key. Additionally, each model has counters for input tokens, output tokens, succeeded, failed, and total files processed.\\n\\nThe `printModelDetails` function takes an array of `LLMModelDetails` and prints a summary table to the console. It calculates the total cost for each model based on the input and output tokens and their respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1083", {"page_content": "respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens, and cost across all models.\\n\\nThe `totalIndexCostEstimate` function calculates the total cost of indexing all models in the input array. It uses the same cost calculation as in `printModelDetails` but returns the total cost as a number.\\n\\nThese functions can be used in the larger project to manage and analyze the usage and costs of different LLMs. For example, the `printModelDetails` function can be called to display a summary of the models' usage and costs:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nprintModelDetails(Object.values(models));\\n```\\n\\nAnd the `totalIndexCostEstimate` function can be used to estimate the total cost of indexing all models:\\n\\n```javascript\\nimport { models, totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1084", {"page_content": "{ models, totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1085", {"page_content": "\"questions\": \"1. **Question:** What is the purpose of the `models` object and how are the different GPT models being used?\\n   **Answer:** The `models` object is a record that maps different GPT models (GPT3, GPT4, and GPT432k) to their respective details, such as cost per tokens, maximum length, and an instance of `OpenAIChat` with the corresponding model configuration.\\n\\n2. **Question:** How does the `printModelDetails` function work and what information does it display?\\n   **Answer:** The `printModelDetails` function takes an array of `LLMModelDetails` as input, processes the information for each model, and then prints a summary table to the console. The table includes the model name, file count, succeeded and failed counts, total tokens, and cost.\\n\\n3. **Question:** What is the purpose of the `totalIndexCostEstimate` function and how is it calculating the total cost?\\n   **Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1086", {"page_content": "**Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the given models by iterating through the input `models` array and summing up the costs based on the input and output tokens and their respective costs per 1K tokens.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1087", {"page_content": "\"checksum\": \"f4464cf197f4af827ac0eac950d568fc\"\n            },\n            {\n              \"fileName\": \"traverseFileSystem.ts\",\n              \"filePath\": \"src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\traverseFileSystem.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1088", {"page_content": "\"summary\": \"The `traverseFileSystem` function in this code is an asynchronous function that recursively traverses a given file system, processing files and folders based on the provided parameters. It is designed to be used in the larger project for generating documentation or performing other tasks that require processing files and folders in a directory structure.\\n\\nThe function takes an object of type `TraverseFileSystemParams` as its input, which contains various properties to control the traversal and processing behavior. These properties include:\\n\\n- `inputPath`: The root path to start the traversal from.\\n- `projectName`: The name of the project being processed.\\n- `processFile`: An optional callback function to process a file.\\n- `processFolder`: An optional callback function to process a folder.\\n- `ignore`: An array of patterns to ignore during traversal.\\n- `filePrompt`, `folderPrompt`: Optional prompts for user interaction.\\n- `contentType`,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1089", {"page_content": "`filePrompt`, `folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`, `linkHosted`: Additional metadata for processing.\\n\\nThe function first checks if the provided `inputPath` exists using `fs.access`. If the path does not exist, it logs an error message and returns. It then defines a helper function `shouldIgnore` that checks if a given file or folder should be ignored based on the `ignore` patterns.\\n\\nThe main logic of the function is implemented in the `dfs` (depth-first search) function, which is called recursively to traverse the file system. It reads the contents of the current directory using `fs.readdir`, filters out ignored items, and processes the remaining items.\\n\\nFor each item, if it is a directory, the `dfs` function is called recursively, and the `processFolder` callback is invoked if provided. If it is a file and its content is text (checked using `isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1090", {"page_content": "(checked using `isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using `Promise.all` to process items concurrently, improving performance. If an error occurs during traversal, it is logged and rethrown.\\n\\nHere's an example of how this function might be used in the larger project:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => {\\n    // Process file logic here\\n  },\\n  processFolder: (params) => {\\n    // Process folder logic here\\n  },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1091", {"page_content": "\"questions\": \"1. **What is the purpose of the `traverseFileSystem` function?**\\n\\n   The `traverseFileSystem` function is an asynchronous function that traverses a given file system, processes folders and files based on the provided parameters, and ignores files and folders based on the given ignore patterns.\\n\\n2. **How does the `shouldIgnore` function work?**\\n\\n   The `shouldIgnore` function takes a file name as input and returns a boolean value indicating whether the file should be ignored or not. It checks if the file name matches any of the ignore patterns provided in the `ignore` parameter using the `minimatch` library.\\n\\n3. **What is the role of the `dfs` function inside `traverseFileSystem`?**\\n\\n   The `dfs` function is an asynchronous function that performs a depth-first search on the file system starting from the given `currentPath`. It processes folders and files based on the provided parameters and recursively calls itself for each subdirectory found.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1092", {"page_content": "\"checksum\": \"b9e957c10ee6c009864c90aa2fa93763\"\n            },\n            {\n              \"fileName\": \"WaitUtil.ts\",\n              \"filePath\": \"src\\\\cli\\\\utils\\\\WaitUtil.ts\",\n              \"url\": \"https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\WaitUtil.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1093", {"page_content": "\"summary\": \"The code in this file provides two utility functions, `wait` and `forTrue`, which are designed to help manage asynchronous operations in the larger project. Both functions return a `Promise`, making them suitable for use with `async/await` syntax.\\n\\n### wait\\n\\nThe `wait` function takes two arguments: `timeoutMs`, a number representing the desired waiting time in milliseconds, and an optional `value` that defaults to `null`. It returns a `Promise` that resolves with the provided `value` after the specified `timeoutMs` has elapsed. This function can be used to introduce a delay in the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\ndelayedEcho(); // Output: Start -> (1 second delay) -> End\\n```\\n\\n### forTrue\\n\\nThe `forTrue` function takes a single argument, `fn`, which is a function that returns a boolean value. It", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1094", {"page_content": "function takes a single argument, `fn`, which is a function that returns a boolean value. It returns a `Promise` that resolves with `true` when the provided function `fn` returns `true`. The function `fn` is checked every 50 milliseconds, up to a maximum of 200 times (i.e., 10 seconds). If `fn` does not return `true` within this time, the `Promise` is rejected.\\n\\nThis function can be used to wait for a specific condition to be met before continuing the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nlet condition = false;\\n\\nsetTimeout(() => {\\n  condition = true;\\n}, 3000);\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n\\nwaitForCondition(); // Output: Waiting for condition... -> (3 second delay) -> Condition met!\\n```\\n\\nIn summary, this file provides two utility functions that help manage asynchronous operations by introducing delays and waiting for", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1095", {"page_content": "utility functions that help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used in the larger project to control the flow of asynchronous code execution.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1096", {"page_content": "\"questions\": \"1. **What is the purpose of the `wait` function?**\\n\\n   The `wait` function is an asynchronous utility function that resolves a promise after a specified timeout in milliseconds, optionally returning a value when the promise is resolved.\\n\\n2. **How does the `forTrue` function work?**\\n\\n   The `forTrue` function takes a function `fn` as an argument, which should return a boolean value. It checks the result of `fn` every 50 milliseconds and resolves the promise when `fn` returns `true`. If `fn` does not return `true` after 200 attempts, the promise is rejected.\\n\\n3. **What is the use case for the `forTrue` function?**\\n\\n   The `forTrue` function can be used to wait for a certain condition to be met before proceeding with the execution of the code. This can be useful in situations where you need to wait for an asynchronous operation to complete or a specific state to be reached before continuing.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1097", {"page_content": "\"checksum\": \"bf4acebb6c2736274af75a8c8441c9d2\"\n            }\n          ],\n          \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1098", {"page_content": "\"summary\": \"The `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils` folder contains utility functions and classes that assist in managing API rate limits, handling file and folder paths, managing language models, traversing file systems, and controlling asynchronous operations. These utilities can be used throughout the autodoc project to ensure consistent behavior and improve code organization.\\n\\n`APIRateLimit.ts` provides the `APIRateLimit` class, which manages and limits the number of concurrent API calls made by the application. This is useful when working with rate-limited APIs or preventing server overload. Example usage:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\nasync function fetchSomeData(id) {\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\n`FileUtil.ts` offers utility functions for generating file names and GitHub URLs for documentation files.", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1099", {"page_content": "offers utility functions for generating file names and GitHub URLs for documentation files. These functions ensure consistent naming and URL generation across the project. Example usage:\\n\\n```javascript\\ngetFileName('example.txt'); // returns 'example.md'\\ngithubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true); // returns 'https://github.com/user/repo/example.md'\\n```\\n\\n`LLMUtil.ts` defines and manages different language models (LLMs) and their associated costs for a project utilizing OpenAI's GPT models. Functions like `printModelDetails` and `totalIndexCostEstimate` can be used to manage and analyze the usage and costs of different LLMs. Example usage:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\nprintModelDetails(Object.values(models));\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\\n\\n`traverseFileSystem.ts` contains the `traverseFileSystem`", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1100", {"page_content": "cost: ${totalCost}`);\\n```\\n\\n`traverseFileSystem.ts` contains the `traverseFileSystem` function, which recursively traverses a given file system, processing files and folders based on provided parameters. This is useful for generating documentation or performing tasks that require processing files and folders in a directory structure. Example usage:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => { /* Process file logic */ },\\n  processFolder: (params) => { /* Process folder logic */ },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\\n\\n`WaitUtil.ts` provides two utility functions, `wait` and `forTrue`, which help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used to control the flow of asynchronous code execution. Example usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000,", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1101", {"page_content": "function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n```\\n\\nIn summary, the utilities in this folder enhance the autodoc project by providing consistent behavior, improving code organization, and managing various aspects of the project, such as API rate limits, file and folder paths, language models, file system traversal, and asynchronous operations.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1102", {"page_content": "\"questions\": \"\",\n          \"checksum\": \"a4b7088863601cd326edbec7726eefe7\"\n        }\n      ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1103", {"page_content": "\"summary\": \"The code in the `spinner.ts` file, located in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli` folder, is responsible for managing a spinner, a visual element that indicates a background process is running. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\\n\\nThe module exports several functions to interact with the spinner:\\n\\n1. `updateSpinnerText(message: string)`: Updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\\n\\n   Example usage:\\n   ```javascript\\n   updateSpinnerText('Loading data...');\\n   ```\\n\\n2. `stopSpinner()`: Stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   stopSpinner();\\n   ```\\n\\n3. `spinnerError(message?: string)`: Stops the spinner and marks it as failed with an optional error message. It only takes effect", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1104", {"page_content": "Stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerError('Failed to load data');\\n   ```\\n\\n4. `spinnerSuccess(message?: string)`: Stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerSuccess('Data loaded successfully');\\n   ```\\n\\n5. `spinnerInfo(message: string)`: Displays an informational message without affecting the spinner's state.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerInfo('Connecting to server...');\\n   ```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1105", {"page_content": "By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1106", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"e9d728bc3244f1081af08994f5fb1cd0\"\n    },\n    {\n      \"folderName\": \"langchain\",\n      \"folderPath\": \".autodoc\\\\docs\\\\json\\\\src\\\\langchain\",\n      \"url\": \"https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\langchain\",\n      \"files\": [\n        {\n          \"fileName\": \"hnswlib.ts\",\n          \"filePath\": \"src\\\\langchain\\\\hnswlib.ts\",\n          \"url\": \"https://github.com/context-labs/autodoc/src\\\\langchain\\\\hnswlib.ts\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1107", {"page_content": "\"summary\": \"The `HNSWLib` class in this code is a specialized vector store that uses the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. It is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. The main purpose of this class is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\\n\\nThe constructor of the `HNSWLib` class takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is used to convert documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.\\n\\nThe `addDocuments` method takes an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1108", {"page_content": "converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\\n\\nThe `save` and `load` methods allow for persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\\n\\nHere's an example of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1109", {"page_content": "Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nIn the larger project, the `HNSWLib` class can be used to efficiently store and search for documents based on their content similarity, which can be useful for tasks such as document clustering, recommendation systems, or information retrieval.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1110", {"page_content": "\"questions\": \"1. **Question**: What is the purpose of the `HNSWLib` class and how does it relate to the `SaveableVectorStore` class?\\n   **Answer**: The `HNSWLib` class is an implementation of a vector store using the Hierarchical Navigable Small World (HNSW) algorithm from the `hnswlib-node` library. It extends the `SaveableVectorStore` class, which provides a base class for vector stores that can be saved and loaded from disk.\\n\\n2. **Question**: How does the `addDocuments` method work and what is its purpose?\\n   **Answer**: The `addDocuments` method takes an array of `Document` objects, extracts their `pageContent`, and embeds them using the provided `Embeddings` instance. It then adds the resulting vectors and documents to the HNSW index and the `InMemoryDocstore`, respectively.\\n\\n3. **Question**: How does the `similaritySearchVectorWithScore` method work and what does it return?\\n   **Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1111", {"page_content": "it return?\\n   **Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a number `k` as input, and searches for the `k` most similar vectors in the HNSW index. It returns an array of tuples, where each tuple contains a `Document` object and its corresponding similarity score to the query vector.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1112", {"page_content": "\"checksum\": \"4725f6bfddda88355b55a980a1eae582\"\n        }\n      ],\n      \"folders\": [],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1113", {"page_content": "\"summary\": \"The `hnswlib.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\langchain` folder contains the `HNSWLib` class, which is a specialized vector store utilizing the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. This class is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. Its primary purpose is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\\n\\nThe `HNSWLib` class constructor takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is responsible for converting documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.\\n\\nThe `addDocuments` method accepts an array of `Document` objects, converts them into embeddings using the", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1114", {"page_content": "method accepts an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\\n\\nThe `save` and `load` methods enable persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\\n\\nIn the larger project, the `HNSWLib` class can be employed to efficiently store and search for documents based on their content similarity, which can be beneficial for tasks such as document clustering, recommendation systems, or information retrieval.\\n\\nHere's an example of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ...", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1115", {"page_content": "of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nThis code snippet demonstrates how to create an `HNSWLib` instance, add documents to the index, and perform a similarity search. The results can then be used for various purposes, such as finding related documents or generating recommendations based on content similarity.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1116", {"page_content": "\"questions\": \"\",\n      \"checksum\": \"ccbe47bddb9d048f35d29fb2d8c04d7f\"\n    }\n  ],", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1117", {"page_content": "\"summary\": \"The `.autodoc\\\\docs\\\\json\\\\src` folder contains the core components of the autodoc project, which is designed to automatically generate documentation for a given code repository using OpenAI's language models (LLMs). The folder consists of three main files: `const.ts`, `index.ts`, and `types.ts`, as well as two subfolders: `cli` and `langchain`.\\n\\n`const.ts` defines the name and file path of the user configuration file for the autodoc project. This file stores user-specific settings in JSON format. Other parts of the project can easily access and use these constants to read or write user-specific settings. For example:\\n\\n```javascript\\nimport { userConfigFilePath } from './path/to/this/file';\\n\\n// Read user configuration from the file\\nconst userConfig = JSON.parse(fs.readFileSync(userConfigFilePath, 'utf-8'));\\n\\n// Apply user settings\\napplyUserSettings(userConfig);\\n```\\n\\n`index.ts` serves as the main entry point for the Autodoc CLI tool, providing a set of", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1118", {"page_content": "serves as the main entry point for the Autodoc CLI tool, providing a set of commands for developers to generate and manage documentation for their codebase. The available commands include `init`, `estimate`, `index`, `user`, and `q`. The CLI tool uses the `commander` library for command handling and `inquirer` for interactive prompts.\\n\\n`types.ts` defines the types and interfaces for the autodoc project, such as `AutodocUserConfig`, `AutodocRepoConfig`, `FileSummary`, `FolderSummary`, and more. These types are used to configure and run the autodoc tool, allowing users to generate documentation for their code repositories using OpenAI's LLMs.\\n\\nThe `cli` subfolder contains the `spinner.ts` file, which manages a spinner for visual feedback during background processes. It exports functions like `updateSpinnerText`, `stopSpinner`, `spinnerError`, `spinnerSuccess`, and `spinnerInfo` for easy interaction with the spinner.\\n\\nThe `langchain` subfolder contains the `hnswlib.ts` file, which", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1119", {"page_content": "interaction with the spinner.\\n\\nThe `langchain` subfolder contains the `hnswlib.ts` file, which provides the `HNSWLib` class for efficient similarity search using the Hierarchical Navigable Small World (HNSW) algorithm. This class is used to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content. Example usage:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nIn summary, the code in this folder is responsible for the core functionality of the autodoc project, including user configuration management, CLI tool commands, type definitions, spinner management, and efficient", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1120", {"page_content": "configuration management, CLI tool commands, type definitions, spinner management, and efficient similarity search using the HNSW algorithm.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1121", {"page_content": "\"questions\": \"\",\n  \"checksum\": \"de4c7ea3f98620e42875dbf7fb0df9a9\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/src/summary.json"}, "type": "Document"}], ["1122", {"page_content": "{\n  \"fileName\": \"tsconfig.json\",\n  \"filePath\": \"tsconfig.json\",\n  \"url\": \"https://github.com/context-labs/autodoc/tsconfig.json\",", "metadata": {"source": "autodoc/.autodoc/docs/json/tsconfig.json"}, "type": "Document"}], ["1123", {"page_content": "\"summary\": \"The code provided is a configuration file for the TypeScript compiler in a project. It specifies various options that control how the TypeScript compiler should process the source code and generate the output JavaScript files. This configuration file is typically named `tsconfig.json` and is placed at the root of a TypeScript project.\\n\\nThe `compilerOptions` object contains several key-value pairs that define the behavior of the TypeScript compiler:\\n\\n- `rootDir`: Specifies the root directory of the source files. In this case, it is set to \\\"src\\\", meaning that the source files are located in the \\\"src\\\" folder.\\n- `outDir`: Specifies the output directory for the compiled JavaScript files. In this case, it is set to \\\"dist\\\", meaning that the compiled files will be placed in the \\\"dist\\\" folder.\\n- `strict`: Enables strict type checking, which helps catch potential issues in the code.\\n- `target`: Specifies the ECMAScript target version for the output JavaScript files.", "metadata": {"source": "autodoc/.autodoc/docs/json/tsconfig.json"}, "type": "Document"}], ["1124", {"page_content": "in the code.\\n- `target`: Specifies the ECMAScript target version for the output JavaScript files. In this case, it is set to \\\"es2020\\\", meaning that the output files will be compatible with ECMAScript 2020 features.\\n- `module`: Specifies the module system to be used. In this case, it is set to \\\"ES2020\\\", meaning that the output files will use the ECMAScript 2020 module system.\\n- `sourceMap`: Generates source map files, which help in debugging the compiled code by mapping it back to the original TypeScript source files.\\n- `esModuleInterop`: Enables compatibility with ECMAScript modules for importing CommonJS modules.\\n- `moduleResolution`: Specifies the module resolution strategy. In this case, it is set to \\\"node\\\", meaning that the Node.js module resolution algorithm will be used.\\n- `allowSyntheticDefaultImports`: Allows default imports from modules with no default export.\\n- `declaration`: Generates TypeScript declaration files (`.d.ts`) alongside the compiled JavaScript", "metadata": {"source": "autodoc/.autodoc/docs/json/tsconfig.json"}, "type": "Document"}], ["1125", {"page_content": "`declaration`: Generates TypeScript declaration files (`.d.ts`) alongside the compiled JavaScript files, which can be useful for other projects that depend on this one.\\n- `skipLibCheck`: Skips type checking of declaration files, which can speed up the compilation process.\\n\\nOverall, this configuration file helps ensure that the TypeScript compiler processes the source code according to the specified options, resulting in compiled JavaScript files that are compatible with the desired ECMAScript version and module system, while also providing useful features like source maps and strict type checking.\",", "metadata": {"source": "autodoc/.autodoc/docs/json/tsconfig.json"}, "type": "Document"}], ["1126", {"page_content": "\"questions\": \"1. **What is the purpose of the `rootDir` and `outDir` options in the configuration?**\\n\\n   The `rootDir` option specifies the root directory of the input files, while the `outDir` option specifies the output directory for the compiled files.\\n\\n2. **What does the `strict` option do in the configuration?**\\n\\n   The `strict` option enables a wide range of type checking behavior that results in stronger guarantees of program correctness.\\n\\n3. **What is the significance of the `target` and `module` options in the configuration?**\\n\\n   The `target` option specifies the ECMAScript target version for the output code, and the `module` option specifies the module system used in the output code. In this case, both are set to \\\"es2020\\\", which means the output code will be compatible with ECMAScript 2020 features and module system.\",\n  \"checksum\": \"e52c7d90cf341455e41e46229333e66d\"\n}", "metadata": {"source": "autodoc/.autodoc/docs/json/tsconfig.json"}, "type": "Document"}], ["1127", {"page_content": "{\"space\":\"cosine\",\"numDimensions\":1536}", "metadata": {"source": "autodoc/.autodoc/docs/data/args.json"}, "type": "Document"}], ["1128", {"page_content": "[[\"0\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\estimate\\\\index.ts)\\n\\nThe `estimate` function in this code is responsible for providing an estimated cost of processing a given repository using the Autodoc project. It takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function starts by constructing the path to the JSON output directory, which will be used to store the intermediate results of the processing. It then updates the spinner text to indicate that the cost estimation is in progress.\\n\\nNext, the `processRepository` function is called with the provided configuration options and a `true` flag to indicate that this is a dry run. This means that the repository will not actually be processed, but the function will return the details of what would", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1129", {"page_content": "repository will not actually be processed, but the function will return the details of what would happen if it were processed. This is used to calculate the estimated cost of processing the repository.\\n\\nOnce the dry run is complete, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is then calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in a red color. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl:", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1130", {"page_content": "{ estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\\n## Questions: \\n 1. **What is the purpose of the `estimate` function?**\\n\\n   The `estimate` function is used to perform a dry run of the `processRepository` command to get an estimated price for indexing the given repository. It then prints the model details and the total estimated cost.\\n\\n2. **What are the parameters passed to the `processRepository` function?**\\n\\n   The `processRepository` function is called with an object containing the following properties:", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1131", {"page_content": "The `processRepository` function is called with an object containing the following properties: `name`, `repositoryUrl`, `root`, `output`, `llms`, `ignore`, `filePrompt`, `folderPrompt`, `chatPrompt`, `contentType`, `targetAudience`, and `linkHosted`. Additionally, a second argument `true` is passed to indicate that it's a dry run.\\n\\n3. **How is the total estimated cost calculated and displayed?**\\n\\n   The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes an array of values from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for formatting, showing the cost with two decimal places and a note that the actual cost may vary.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\estimate\\\\index.md\"}}],[\"1\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\estimate)\\n\\nThe `estimate` function in `index.ts` is a", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1132", {"page_content": "`estimate` function in `index.ts` is a crucial part of the Autodoc project, as it provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input, containing various configuration options such as repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\\n\\nThe function begins by constructing the path to the JSON output directory, which stores intermediate results of the processing. It then updates the spinner text to indicate that cost estimation is in progress. The `processRepository` function is called with the provided configuration options and a `true` flag, signifying a dry run. This dry run returns the details of what would happen if the repository were processed, which is used to calculate the estimated cost.\\n\\nUpon completion of the dry run, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1133", {"page_content": "success, and the results are printed using the `printModelDetails` function. The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\\n\\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in red. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\\n\\nHere's an example of how the `estimate` function might be used in the larger project:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted:", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1134", {"page_content": "true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\nThis example would estimate the cost of processing the \\\"my-repo\\\" repository with the specified configuration options.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\estimate\\\\summary.md\"}}],[\"2\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.ts)\\n\\nThe `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\\n\\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1135", {"page_content": "as the project name, input and output directories, and other settings related to the documentation generation process.\\n\\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.\\n\\nNext, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\\n\\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1136", {"page_content": "to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\\n\\nExample usage:\\n\\n```javascript\\nconvertJsonToMarkdown({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.\\n## Questions: \\n 1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output,", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1137", {"page_content": "object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.\\n\\n2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\\n\\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1138", {"page_content": "created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\index\\\\convertJsonToMarkdown.md\"}}],[\"3\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\createVectorStore.ts)\\n\\nThe code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\\n\\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.\\n\\nThe `processDirectory` function is a recursive function that", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1139", {"page_content": "resolves to the created Document.\\n\\nThe `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\\n\\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.\\n\\nThe `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1140", {"page_content": "a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\\n\\nExample usage:\\n\\n```javascript\\nconst config = {\\n  root: './data/documents',\\n  output: './data/vector_store',\\n};\\n\\ncreateVectorStore(config).then(() => {\\n  console.log('Vector store created successfully');\\n});\\n```\\n## Questions: \\n 1. **Question:** What is the purpose of the `processFile` function and what does it return?\\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1141", {"page_content": "file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\\n\\n2. **Question:** How does the `processDirectory` function work and what does it return?\\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.\\n\\n3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1142", {"page_content": "splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\index\\\\createVectorStore.md\"}}],[\"4\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\index.ts)\\n\\nThe code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\\n\\nThe `index` function performs three main tasks:\\n\\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1143", {"page_content": "Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Processing repository...');\\n   await processRepository({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Creating markdown files...');\\n   await convertJsonToMarkdown({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore`", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1144", {"page_content": "files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\\n\\n   ```javascript\\n   updateSpinnerText('Create vector files...');\\n   await createVectorStore({ /* configuration options */ });\\n   spinnerSuccess();\\n   ```\\n\\nThroughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\\n\\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\\n## Questions: \\n 1. **What does the `index` function do in this code?**\\n\\n   The `index` function is the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1145", {"page_content": "\\n 1. **What does the `index` function do in this code?**\\n\\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\\n\\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**\\n\\n   The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\\n\\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\\n\\n   These prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1146", {"page_content": "used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\index\\\\index.md\"}}],[\"5\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\processRepository.ts)\\n\\nThe `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.\\n\\nThe function starts by initializing the encoding and rate limit for API", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1147", {"page_content": "calls and file writing.\\n\\nThe function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\\n\\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1148", {"page_content": "calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.\\n\\nThe main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\\n\\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or folder.\\n## Questions: \\n 1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1149", {"page_content": "an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.\\n\\n2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.\\n\\n3. **Question:** How does the `reindexCheck` function work and when is it used?\\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1150", {"page_content": "and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\index\\\\processRepository.md\"}}],[\"6\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\index\\\\prompts.ts)\\n\\nThis code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\\n\\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`,", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1151", {"page_content": "prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\\n```\\n\\n2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\\n\\nExample usage:\\n```javascript\\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;',", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1152", {"page_content": "prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\\n```\\n\\n3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\\n\\nExample usage:\\n```javascript\\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\\n```\\n\\nThese functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1153", {"page_content": "the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.\\n## Questions: \\n 1. **What is the purpose of the `createCodeFileSummary` function?**\\n\\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\\n\\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\\n\\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\\n\\n3. **What is the role of the `folderSummaryPrompt` function?**\\n\\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name,", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1154", {"page_content": "a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\index\\\\prompts.md\"}}],[\"7\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\index)\\n\\nThe code in this folder is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It consists of several functions and utilities that work together to automate the documentation generation process.\\n\\nThe main function, `index`, takes an `AutodocRepoConfig` object as input, which contains various configuration options for processing the repository. It performs three main tasks:\\n\\n1. **Process the repository**: It calls the `processRepository` function to traverse the repository, generate summaries and questions for code files and", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1155", {"page_content": "function to traverse the repository, generate summaries and questions for code files and folders using the LLMS (Language Learning Management System), and create JSON files with the results. These JSON files are stored in the `output/docs/json/` directory.\\n\\n2. **Create Markdown files**: It uses the `convertJsonToMarkdown` function to convert the generated JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\\n\\n3. **Create vector files**: It calls the `createVectorStore` function to create vector files from the generated Markdown files. These vector files are stored in the `output/docs/data/` directory.\\n\\nThroughout the execution of these tasks, the code provides visual feedback on the progress of the tasks using `updateSpinnerText` and `spinnerSuccess` functions.\\n\\nHere's an example of how this code might be used:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt:", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1156", {"page_content": "name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\nThis will process the repository located at `./input`, generate documentation in JSON, Markdown, and vector formats, and save the results in the `./output` directory.\\n\\nThe `prompts.ts` file contains utility functions that generate prompts for documentation experts. These functions create markdown formatted strings with specific instructions for the documentation expert, ensuring consistent formatting and instructions across different parts of the project.\\n\\nIn summary, the code in this folder automates the process of generating documentation for a given repository based on the provided configuration options. The generated documentation can be used for various purposes, such as displaying it on a website or analyzing the content for specific", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1157", {"page_content": "used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\index\\\\summary.md\"}}],[\"8\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\init\\\\index.ts)\\n\\nThis code is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1158", {"page_content": "with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1159", {"page_content": "message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n## Questions: \\n 1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc project. It takes an optional `config` parameter of type `AutodocRepoConfig` and returns a new configuration object with default values for various properties.\\n\\n2. **How does the `init` function work and when is it called?**\\n\\n   The `init` function is an asynchronous function that initializes the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1160", {"page_content": "the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It takes an optional `config` parameter of type `AutodocRepoConfig` and prompts the user for input to set the configuration values. It is called when the user wants to set up the Autodoc configuration for their project.\\n\\n3. **What is the purpose of the `inquirer.prompt` calls in the `init` function?**\\n\\n   The `inquirer.prompt` calls are used to interactively prompt the user for input to set the configuration values for the Autodoc project. The user is asked for the repository name, repository URL, and the LLMs they have access to. The input is then used to create a new configuration object and write it to the `autodoc.config.json` file.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\init\\\\index.md\"}}],[\"9\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init)\\n\\nThe `index.ts` file in the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1161", {"page_content": "`index.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\init` folder is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\\n\\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1162", {"page_content": "If the user chooses not to overwrite, the process exits.\\n\\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\\n\\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\\n\\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\\n\\nExample usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl:", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1163", {"page_content": "configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\nThis code is essential for setting up the Autodoc project, as it creates the necessary configuration file and gathers user input to customize the project. It works in conjunction with other parts of the project, such as the CLI and the documentation generation process, which rely on the configuration file to function correctly.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\init\\\\summary.md\"}}],[\"10\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\createChatChain.ts)\\n\\nThis code defines a function `makeChain` that creates a chatbot for answering questions about a software project called `projectName`. The chatbot is trained on the content of the project, which is located at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter.", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1164", {"page_content": "at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters:\\n\\n- `projectName`: The name of the software project.\\n- `repositoryUrl`: The URL of the project's repository.\\n- `contentType`: The type of content the chatbot is trained on.\\n- `chatPrompt`: Additional instructions for answering questions about the content type.\\n- `targetAudience`: The intended audience for the chatbot's answers.\\n- `vectorstore`: An instance of HNSWLib for efficient nearest neighbor search.\\n- `llms`: An array of LLMModels, which are language models used for generating answers.\\n- `onTokenStream`: An optional callback function that is called when a new token is generated by the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1165", {"page_content": "`onTokenStream`: An optional callback function that is called when a new token is generated by the language model.\\n\\nThe `makeChain` function first creates a question generator using the `LLMChain` class. This generator is responsible for rephrasing follow-up questions to be standalone questions. It uses the `CONDENSE_PROMPT` template, which is defined at the beginning of the code.\\n\\nNext, the function creates a `QA_PROMPT` template using the `makeQAPrompt` function. This template is used to generate answers to the questions in a conversational manner, with hyperlinks back to GitHub and code examples where appropriate.\\n\\nFinally, the function creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project. The chatbot uses the `vectorstore` for efficient nearest neighbor search and the `llms` language models for generating answers. If the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1166", {"page_content": "for efficient nearest neighbor search and the `llms` language models for generating answers. If the `onTokenStream` callback is provided, it will be called when a new token is generated by the language model.\\n## Questions: \\n 1. **Question:** What is the purpose of the `makeChain` function and what are its input parameters?\\n\\n   **Answer:** The `makeChain` function is used to create a `ChatVectorDBQAChain` instance, which is responsible for generating questions and answers based on the given input parameters. The input parameters include `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and an optional `onTokenStream` function.\\n\\n2. **Question:** What are the roles of `CONDENSE_PROMPT` and `QA_PROMPT` in this code?\\n\\n   **Answer:** `CONDENSE_PROMPT` is a template for generating standalone questions from a given chat history and follow-up question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1167", {"page_content": "question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to GitHub, based on the provided context and question. Both templates are used in the `LLMChain` and `loadQAChain` instances, respectively.\\n\\n3. **Question:** How does the `onTokenStream` function work and when is it used?\\n\\n   **Answer:** The `onTokenStream` function is an optional callback that can be provided to the `makeChain` function. It is used to handle the streaming of tokens generated by the OpenAIChat instance. If provided, it will be called with each new token generated during the chat process.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\query\\\\createChatChain.md\"}}],[\"11\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\query\\\\index.ts)\\n\\nThis code defines a chatbot interface for the Autodoc project, which allows users to ask questions related to a specific codebase and receive answers in a conversational", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1168", {"page_content": "users to ask questions related to a specific codebase and receive answers in a conversational manner. The chatbot uses a combination of the `inquirer` library for user input, `marked` and `marked-terminal` for rendering Markdown output, and the `langchain` library for handling natural language processing tasks.\\n\\nThe `query` function is the main entry point for the chatbot. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store using the `HNSWLib` and `OpenAIEmbeddings` classes, and creates a chat chain using the `makeChain` function.\\n\\nThe chatbot interface is displayed using the `displayWelcomeMessage` function, which prints a welcome message to the console. The `getQuestion` function is used to prompt the user for a question using the `inquirer` library. The chatbot then enters a loop, where it processes the user's question,", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1169", {"page_content": "the `inquirer` library. The chatbot then enters a loop, where it processes the user's question, generates a response using the chat chain, and displays the response as Markdown in the terminal.\\n\\nIf an error occurs during the processing of a question, the chatbot will display an error message and continue to prompt the user for a new question. The loop continues until the user types 'exit', at which point the chatbot terminates.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example would initialize the chatbot with the specified repository and user configurations, and start the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1170", {"page_content": "would initialize the chatbot with the specified repository and user configurations, and start the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\\n## Questions: \\n 1. **What is the purpose of the `query` function in this code?**\\n\\n   The `query` function is responsible for handling user interactions with the chatbot. It takes in an AutodocRepoConfig object and an AutodocUserConfig object, sets up the necessary data structures, and then enters a loop where it prompts the user for questions, processes them, and displays the results.\\n\\n2. **How does the code handle rendering Markdown text in the terminal?**\\n\\n   The code uses the `marked` library along with a custom `TerminalRenderer` to render Markdown text in the terminal. The `marked` library is configured with the custom renderer using `marked.setOptions({ renderer: new TerminalRenderer() });`.\\n\\n3. **What is the purpose of the `chatHistory` variable and how is it used?**\\n\\n   The `chatHistory`", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1171", {"page_content": "**What is the purpose of the `chatHistory` variable and how is it used?**\\n\\n   The `chatHistory` variable is an array that stores the history of questions and answers in the chat session. It is used to keep track of the conversation between the user and the chatbot. When a new question is asked, the chat history is passed to the `chain.call()` function, and the new question and its corresponding answer are added to the `chatHistory` array.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\query\\\\index.md\"}}],[\"12\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\query)\\n\\nThe `query` folder in the Autodoc project contains code for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot is trained on the content of the project and provides answers with hyperlinks back to GitHub, including code examples and links to the examples where", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1172", {"page_content": "answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate.\\n\\nThe main entry point for the chatbot is the `query` function in `index.ts`. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store and creates a chat chain using the `makeChain` function from `createChatChain.ts`.\\n\\nHere's an example of how the `query` function might be used:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\nThis example initializes the chatbot with the specified", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1173", {"page_content": "userConfig);\\n```\\n\\nThis example initializes the chatbot with the specified repository and user configurations and starts the chatbot interface for the user to ask questions about the \\\"MyProject\\\" codebase.\\n\\nThe `createChatChain.ts` file defines the `makeChain` function, which creates a chatbot for answering questions about a software project. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\\n\\nThe `makeChain` function takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and `onTokenStream`. It first creates a question generator using the `LLMChain` class, then creates a `QA_PROMPT` template using the `makeQAPrompt` function, and finally creates and returns a new instance of the `ChatVectorDBQAChain` class,", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1174", {"page_content": "function, and finally creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project.\\n\\nIn summary, the code in the `query` folder is responsible for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot uses a combination of natural language processing techniques and efficient nearest neighbor search to generate accurate and relevant answers for the user.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\query\\\\summary.md\"}}],[\"13\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands)\\n\\nThe code in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands` folder is responsible for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1175", {"page_content": "to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project. The folder contains several subfolders, each with a specific purpose.\\n\\n### estimate\\n\\nThe `estimate` function provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input and performs a dry run of the repository processing to calculate the estimated cost. Example usage:\\n\\n```javascript\\nimport { estimate } from './path/to/this/file';\\n\\nconst config = {\\n  name: 'my-repo',\\n  repositoryUrl: 'https://github.com/user/my-repo.git',\\n  root: './',\\n  output: './output',\\n  llms: ['en'],\\n  ignore: ['.git', 'node_modules'],\\n  filePrompt: true,\\n  folderPrompt: true,\\n  chatPrompt: true,\\n  contentType: 'code',\\n  targetAudience: 'developers',\\n  linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\n### index\\n\\nThe code in this folder processes a", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1176", {"page_content": "linkHosted: true,\\n};\\n\\nestimate(config);\\n```\\n\\n### index\\n\\nThe code in this folder processes a given repository and generates documentation in JSON, Markdown, and vector formats. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository, creating Markdown files, and creating vector files. Example usage:\\n\\n```javascript\\nindex({\\n  name: \\\"myProject\\\",\\n  root: \\\"./input\\\",\\n  output: \\\"./output\\\",\\n  filePrompt: true,\\n  folderPrompt: true,\\n  contentType: \\\"code\\\",\\n  targetAudience: \\\"developers\\\",\\n  linkHosted: \\\"https://github.com/user/myProject\\\",\\n});\\n```\\n\\n### init\\n\\nThe `init` function initializes the configuration of the Autodoc project. It prompts the user to input necessary information to set up the project and creates the `autodoc.config.json` file in the project root. Example usage:\\n\\n```javascript\\nimport { init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1177", {"page_content": "{ init } from './path/to/this/file';\\n\\n// Initialize the configuration with default values\\nawait init();\\n\\n// Initialize the configuration with custom values\\nawait init({\\n  name: 'My Custom Repository',\\n  repositoryUrl: 'https://github.com/user/repo',\\n});\\n```\\n\\n### query\\n\\nThe `query` folder contains code for creating a chatbot that can answer questions about a specific software project. The main entry point is the `query` function, which takes an `AutodocRepoConfig` object and an `AutodocUserConfig` object as input. Example usage:\\n\\n```javascript\\nimport { query } from './autodoc';\\n\\nconst repoConfig = {\\n  name: 'MyProject',\\n  repositoryUrl: 'https://github.com/user/myproject',\\n  output: 'path/to/output',\\n  contentType: 'code',\\n  chatPrompt: 'Ask me anything about MyProject',\\n  targetAudience: 'developers',\\n};\\n\\nconst userConfig = {\\n  llms: 'path/to/llms',\\n};\\n\\nquery(repoConfig, userConfig);\\n```\\n\\n### user\\n\\nThe `user` folder manages the user configuration", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1178", {"page_content": "userConfig);\\n```\\n\\n### user\\n\\nThe `user` folder manages the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs). Example usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the code in this folder is essential for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\summary.md\"}}],[\"14\",{\"pageContent\":\"[View code on", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1179", {"page_content": "code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\commands\\\\user\\\\index.ts)\\n\\nThis code is responsible for managing the user configuration for the Autodoc project. It provides a way to create, update, and save the user configuration file, which stores information about the user's access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function is used to create a default configuration object with the provided `config` parameter or with GPT-3 as the default LLM. This function is used to generate a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1180", {"page_content": "If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1181", {"page_content": "} from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n## Questions: \\n 1. **What is the purpose of the `makeConfigTemplate` function?**\\n\\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc user. It takes an optional `config` parameter and returns an object with a `llms` property, which is an array of LLM models.\\n\\n2. **How does the `user` function handle existing user configuration files?**\\n\\n   The `user` function checks if a user configuration file already exists using `fsSync.existsSync`. If it does, the user is prompted with a confirmation message to overwrite the existing configuration. If the user chooses not to overwrite, the process exits with a status code of 0.\\n\\n3. **What are the available choices for LLM models in the `user` function?**\\n\\n", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1182", {"page_content": "code of 0.\\n\\n3. **What are the available choices for LLM models in the `user` function?**\\n\\n   The available choices for LLM models are GPT-3.5 Turbo, GPT-3.5 Turbo and GPT-4 8K (Early Access), and GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected value is stored in the `llms` property of the new configuration object.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\user\\\\index.md\"}}],[\"15\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\commands\\\\user)\\n\\nThe `index.ts` file in the `user` folder is responsible for managing the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function creates a default", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1183", {"page_content": "(LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\\n\\nThe `makeConfigTemplate` function creates a default configuration object with either the provided `config` parameter or GPT-3 as the default LLM. This function is useful for generating a new configuration object when needed.\\n\\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\\n\\nIf the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\\n\\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1184", {"page_content": "access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\\n\\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\\n\\nThis code is essential for the Autodoc project as it allows users to manage their access to different LLMs and store their preferences in a configuration file. This configuration file can then be used by other parts of the project to determine which LLMs the user has access to and tailor the querying process accordingly.\\n\\nExample usage:\\n\\n```javascript\\nimport { user } from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1185", {"page_content": "} from './path/to/this/file';\\n\\n// Create a new user configuration with default settings\\nawait user();\\n\\n// Update the user configuration with a custom config object\\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\\n```\\n\\nIn summary, the `index.ts` file in the `user` folder is a crucial part of the Autodoc project, allowing users to manage their LLM access and preferences. This configuration is then used by other parts of the project to provide a tailored experience based on the user's access to different LLMs.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\commands\\\\user\\\\summary.md\"}}],[\"16\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\spinner.ts)\\n\\nThis code is responsible for managing a spinner, which is a visual element that indicates a process is running in the background. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1186", {"page_content": "the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\\n\\nThe code starts by importing the `ora` library and creating a singleton spinner instance with the 'dots' style. This ensures that there will only be one spinner active at any given time.\\n\\nThere are several functions exported by this module to interact with the spinner:\\n\\n1. `updateSpinnerText(message: string)`: This function updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\\n\\n   Example usage:\\n   ```javascript\\n   updateSpinnerText('Loading data...');\\n   ```\\n\\n2. `stopSpinner()`: This function stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   stopSpinner();\\n   ```\\n\\n3. `spinnerError(message?: string)`: This function stops the spinner and marks it as failed with an optional error message. It only takes", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1187", {"page_content": "function stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerError('Failed to load data');\\n   ```\\n\\n4. `spinnerSuccess(message?: string)`: This function stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerSuccess('Data loaded successfully');\\n   ```\\n\\n5. `spinnerInfo(message: string)`: This function displays an informational message without affecting the spinner's state.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerInfo('Connecting to server...');\\n   ```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1188", {"page_content": "server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\\n## Questions: \\n 1. **What is the purpose of the `ora` package in this code?**\\n\\n   The `ora` package is used to create a spinner in the command line interface, providing a visual indication of a running process. In this code, it is used to create a singleton spinner with the 'dots' style.\\n\\n2. **How does the `updateSpinnerText` function work?**\\n\\n   The `updateSpinnerText` function takes a message as an input and updates the spinner's text with the given message. If the spinner is already spinning, it updates the text directly; otherwise, it starts the spinner with the new message.\\n\\n3. **What are the differences between `spinnerError`, `spinnerSuccess`, and `spinnerInfo` functions?**\\n\\n   These functions are used to update the spinner's state and message based", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1189", {"page_content": "functions?**\\n\\n   These functions are used to update the spinner's state and message based on the outcome of a process. `spinnerError` is called when there is an error, and it stops the spinner with a failure message. `spinnerSuccess` is called when the process is successful, and it stops the spinner with a success message. `spinnerInfo` is used to display an informational message without stopping the spinner.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\spinner.md\"}}],[\"17\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli)\\n\\nThe code in the `spinner.ts` file, located in the `.autodoc\\\\docs\\\\json\\\\src\\\\cli` folder, is responsible for managing a spinner, a visual element that indicates a background process is running. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\\n\\nThe module exports several functions to interact", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1190", {"page_content": "to create spinners for command-line interfaces.\\n\\nThe module exports several functions to interact with the spinner:\\n\\n1. `updateSpinnerText(message: string)`: Updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\\n\\n   Example usage:\\n   ```javascript\\n   updateSpinnerText('Loading data...');\\n   ```\\n\\n2. `stopSpinner()`: Stops the spinner if it is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   stopSpinner();\\n   ```\\n\\n3. `spinnerError(message?: string)`: Stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerError('Failed to load data');\\n   ```\\n\\n4. `spinnerSuccess(message?: string)`: Stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1191", {"page_content": "it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerSuccess('Data loaded successfully');\\n   ```\\n\\n5. `spinnerInfo(message: string)`: Displays an informational message without affecting the spinner's state.\\n\\n   Example usage:\\n   ```javascript\\n   spinnerInfo('Connecting to server...');\\n   ```\\n\\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\summary.md\"}}],[\"18\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\APIRateLimit.ts)\\n\\nThe", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1192", {"page_content": "code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\APIRateLimit.ts)\\n\\nThe `APIRateLimit` class in this code snippet is designed to manage and limit the number of concurrent API calls made by the application. This is useful in situations where the API being called has a rate limit or when the application needs to prevent overwhelming the server with too many requests at once.\\n\\nThe class constructor takes an optional parameter `maxConcurrentCalls`, which defaults to 50, to set the maximum number of concurrent API calls allowed. It maintains a queue of API calls and keeps track of the number of calls in progress.\\n\\nThe main method of this class is `callApi<T>(apiFunction: () => Promise<T>): Promise<T>`. It takes a function `apiFunction` that returns a promise and wraps it in a new promise. The purpose of this wrapping is to control the execution of the API calls and ensure that they do not exceed the specified rate limit.\\n\\nWhen `callApi` is called, the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1193", {"page_content": "calls and ensure that they do not exceed the specified rate limit.\\n\\nWhen `callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is triggered if there are available slots for concurrent calls. The `dequeueAndExecute` method checks if there are any API calls in the queue and if the number of in-progress calls is below the maximum limit. If both conditions are met, it dequeues the next API call and executes it.\\n\\nThe `executeCall` function inside `callApi` is responsible for actually calling the API function, resolving or rejecting the promise based on the result, and updating the number of in-progress calls. Once an API call is completed, the `dequeueAndExecute` method is called again to process any remaining calls in the queue.\\n\\nHere's an example of how this class can be used in the larger project:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\n\\nasync function fetchSomeData(id) {\\n", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1194", {"page_content": "= new APIRateLimit(10); // Limit to 10 concurrent calls\\n\\nasync function fetchSomeData(id) {\\n  // Call the API using the rate limiter\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls to the `fetch` function, ensuring that no more than 10 calls are made at once.\\n## Questions: \\n 1. **What is the purpose of the `APIRateLimit` class?**\\n\\n   The `APIRateLimit` class is designed to manage and limit the number of concurrent API calls to a specified maximum, preventing the application from overwhelming the API with too many requests at once.\\n\\n2. **How does the `callApi` method work and what is its return type?**\\n\\n   The `callApi` method takes an `apiFunction` as an argument, which is a function that returns a Promise. It adds the API call to a queue and executes it when there are available slots for concurrent calls.", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1195", {"page_content": "adds the API call to a queue and executes it when there are available slots for concurrent calls. The method returns a Promise of type `T`, where `T` is the expected return type of the `apiFunction`.\\n\\n3. **How can the maximum number of concurrent calls be configured?**\\n\\n   The maximum number of concurrent calls can be configured by passing a value to the `maxConcurrentCalls` parameter in the constructor of the `APIRateLimit` class. If no value is provided, the default value is set to 50.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\utils\\\\APIRateLimit.md\"}}],[\"19\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\FileUtil.ts)\\n\\nThis code provides utility functions for handling file and folder paths in the autodoc project. The main purpose of these functions is to generate file names and GitHub URLs for documentation files.\\n\\n1. `getFileName(input, delimiter, extension)`: This function takes an input string, an optional", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1196", {"page_content": "`getFileName(input, delimiter, extension)`: This function takes an input string, an optional delimiter (default is '.'), and an optional extension (default is '.md'). It returns a new string with the given extension. If the delimiter is found in the input string, the function removes the part of the string after the last occurrence of the delimiter and appends the extension. If the delimiter is not found, the function simply appends the extension to the input string. This function can be used to generate file names for documentation files with the desired extension.\\n\\n   Example usage:\\n\\n   ```\\n   getFileName('example.txt'); // returns 'example.md'\\n   getFileName('example', '_', '.html'); // returns 'example.html'\\n   ```\\n\\n2. `githubFileUrl(githubRoot, inputRoot, filePath, linkHosted)`: This function generates a GitHub URL for a file. It takes the GitHub repository root URL, the input root folder path, the file path, and a boolean flag indicating whether the URL should be for", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1197", {"page_content": "input root folder path, the file path, and a boolean flag indicating whether the URL should be for the hosted version of the file or the source code. It returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true);\\n   // returns 'https://github.com/user/repo/example.md'\\n   ```\\n\\n3. `githubFolderUrl(githubRoot, inputRoot, folderPath, linkHosted)`: This function is similar to `githubFileUrl`, but it generates a GitHub URL for a folder instead of a file. It takes the same arguments as `githubFileUrl` and returns a string with the generated URL.\\n\\n   Example usage:\\n\\n   ```\\n   githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\\n   // returns 'https://github.com/user/repo/folder'\\n   ```\\n\\nThese utility functions can be used throughout the autodoc project to generate file names and GitHub URLs for documentation files and folders, ensuring consistent naming", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1198", {"page_content": "generate file names and GitHub URLs for documentation files and folders, ensuring consistent naming and URL generation across the project.\\n## Questions: \\n 1. **What is the purpose of the `getFileName` function?**\\n\\n   The `getFileName` function takes an input string, an optional delimiter, and an optional extension, and returns a new string with the given extension. If the delimiter is not found in the input string, the extension is simply appended to the input string. If the delimiter is found, the input string is sliced up to the last delimiter index and the extension is appended.\\n\\n2. **What are the differences between the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   Both functions take the same parameters: `githubRoot`, `inputRoot`, a path (either `filePath` or `folderPath`), and a `linkHosted` boolean. The main difference is in the returned URL: `githubFileUrl` returns a URL pointing to a file in the GitHub repository, while `githubFolderUrl` returns a URL", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1199", {"page_content": "returns a URL pointing to a file in the GitHub repository, while `githubFolderUrl` returns a URL pointing to a folder in the GitHub repository. The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for folders.\\n\\n3. **What is the purpose of the `linkHosted` parameter in the `githubFileUrl` and `githubFolderUrl` functions?**\\n\\n   The `linkHosted` parameter is a boolean that determines whether the returned URL should point to the hosted version of the file or folder on GitHub Pages (if `true`) or to the file or folder within the GitHub repository itself (if `false`). Depending on the value of `linkHosted`, the functions will return different URL structures.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\utils\\\\FileUtil.md\"}}],[\"20\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\LLMUtil.ts)\\n\\nThis code defines and manages different language models (LLMs) and their associated costs for a", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1200", {"page_content": "code defines and manages different language models (LLMs) and their associated costs for a project that utilizes OpenAI's GPT models. It imports the `OpenAIChat` class from the `langchain/llms` module and the `LLMModelDetails` and `LLMModels` types from the `../../types.js` file.\\n\\nThe `models` object contains three LLMs: GPT3, GPT4, and GPT432k. Each model has its own properties, such as `name`, `inputCostPer1KTokens`, `outputCostPer1KTokens`, `maxLength`, and an instance of the `OpenAIChat` class with the respective model name and API key. Additionally, each model has counters for input tokens, output tokens, succeeded, failed, and total files processed.\\n\\nThe `printModelDetails` function takes an array of `LLMModelDetails` and prints a summary table to the console. It calculates the total cost for each model based on the input and output tokens and their respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens, and cost across all", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1201", {"page_content": "tokens. It also calculates the total file count, succeeded, failed, tokens, and cost across all models.\\n\\nThe `totalIndexCostEstimate` function calculates the total cost of indexing all models in the input array. It uses the same cost calculation as in `printModelDetails` but returns the total cost as a number.\\n\\nThese functions can be used in the larger project to manage and analyze the usage and costs of different LLMs. For example, the `printModelDetails` function can be called to display a summary of the models' usage and costs:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nprintModelDetails(Object.values(models));\\n```\\n\\nAnd the `totalIndexCostEstimate` function can be used to estimate the total cost of indexing all models:\\n\\n```javascript\\nimport { models, totalIndexCostEstimate } from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models'", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1202", {"page_content": "} from './path/to/this/file';\\n\\n// Process files with models...\\n// Update models' properties...\\n\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\\n## Questions: \\n 1. **Question:** What is the purpose of the `models` object and how are the different GPT models being used?\\n   **Answer:** The `models` object is a record that maps different GPT models (GPT3, GPT4, and GPT432k) to their respective details, such as cost per tokens, maximum length, and an instance of `OpenAIChat` with the corresponding model configuration.\\n\\n2. **Question:** How does the `printModelDetails` function work and what information does it display?\\n   **Answer:** The `printModelDetails` function takes an array of `LLMModelDetails` as input, processes the information for each model, and then prints a summary table to the console. The table includes the model name, file count, succeeded and failed counts, total tokens, and cost.\\n\\n3.", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1203", {"page_content": "includes the model name, file count, succeeded and failed counts, total tokens, and cost.\\n\\n3. **Question:** What is the purpose of the `totalIndexCostEstimate` function and how is it calculating the total cost?\\n   **Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the given models by iterating through the input `models` array and summing up the costs based on the input and output tokens and their respective costs per 1K tokens.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\utils\\\\LLMUtil.md\"}}],[\"21\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils)\\n\\nThe `.autodoc\\\\docs\\\\json\\\\src\\\\cli\\\\utils` folder contains utility functions and classes that assist in managing API rate limits, handling file and folder paths, managing language models, traversing file systems, and controlling asynchronous operations. These utilities can be used throughout the autodoc project to", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1204", {"page_content": "controlling asynchronous operations. These utilities can be used throughout the autodoc project to ensure consistent behavior and improve code organization.\\n\\n`APIRateLimit.ts` provides the `APIRateLimit` class, which manages and limits the number of concurrent API calls made by the application. This is useful when working with rate-limited APIs or preventing server overload. Example usage:\\n\\n```javascript\\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\\nasync function fetchSomeData(id) {\\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\\n  return result;\\n}\\n```\\n\\n`FileUtil.ts` offers utility functions for generating file names and GitHub URLs for documentation files. These functions ensure consistent naming and URL generation across the project. Example usage:\\n\\n```javascript\\ngetFileName('example.txt'); // returns 'example.md'\\ngithubFileUrl('https://github.com/user/repo', '/input',", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1205", {"page_content": "// returns 'example.md'\\ngithubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true); // returns 'https://github.com/user/repo/example.md'\\n```\\n\\n`LLMUtil.ts` defines and manages different language models (LLMs) and their associated costs for a project utilizing OpenAI's GPT models. Functions like `printModelDetails` and `totalIndexCostEstimate` can be used to manage and analyze the usage and costs of different LLMs. Example usage:\\n\\n```javascript\\nimport { models, printModelDetails } from './path/to/this/file';\\nprintModelDetails(Object.values(models));\\nconst totalCost = totalIndexCostEstimate(Object.values(models));\\nconsole.log(`Total cost: ${totalCost}`);\\n```\\n\\n`traverseFileSystem.ts` contains the `traverseFileSystem` function, which recursively traverses a given file system, processing files and folders based on provided parameters. This is useful for generating documentation or performing tasks that require processing files and folders in a directory", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1206", {"page_content": "documentation or performing tasks that require processing files and folders in a directory structure. Example usage:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => { /* Process file logic */ },\\n  processFolder: (params) => { /* Process folder logic */ },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\\n\\n`WaitUtil.ts` provides two utility functions, `wait` and `forTrue`, which help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used to control the flow of asynchronous code execution. Example usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n```\\n\\nIn summary, the utilities in", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1207", {"page_content": "=> condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n```\\n\\nIn summary, the utilities in this folder enhance the autodoc project by providing consistent behavior, improving code organization, and managing various aspects of the project, such as API rate limits, file and folder paths, language models, file system traversal, and asynchronous operations.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\utils\\\\summary.md\"}}],[\"22\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\traverseFileSystem.ts)\\n\\nThe `traverseFileSystem` function in this code is an asynchronous function that recursively traverses a given file system, processing files and folders based on the provided parameters. It is designed to be used in the larger project for generating documentation or performing other tasks that require processing files and folders in a directory structure.\\n\\nThe function takes an object of type `TraverseFileSystemParams` as its", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1208", {"page_content": "in a directory structure.\\n\\nThe function takes an object of type `TraverseFileSystemParams` as its input, which contains various properties to control the traversal and processing behavior. These properties include:\\n\\n- `inputPath`: The root path to start the traversal from.\\n- `projectName`: The name of the project being processed.\\n- `processFile`: An optional callback function to process a file.\\n- `processFolder`: An optional callback function to process a folder.\\n- `ignore`: An array of patterns to ignore during traversal.\\n- `filePrompt`, `folderPrompt`: Optional prompts for user interaction.\\n- `contentType`, `targetAudience`, `linkHosted`: Additional metadata for processing.\\n\\nThe function first checks if the provided `inputPath` exists using `fs.access`. If the path does not exist, it logs an error message and returns. It then defines a helper function `shouldIgnore` that checks if a given file or folder should be ignored based on the `ignore` patterns.\\n\\nThe main logic", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1209", {"page_content": "if a given file or folder should be ignored based on the `ignore` patterns.\\n\\nThe main logic of the function is implemented in the `dfs` (depth-first search) function, which is called recursively to traverse the file system. It reads the contents of the current directory using `fs.readdir`, filters out ignored items, and processes the remaining items.\\n\\nFor each item, if it is a directory, the `dfs` function is called recursively, and the `processFolder` callback is invoked if provided. If it is a file and its content is text (checked using `isText`), the `processFile` callback is invoked if provided.\\n\\nThe traversal is performed using `Promise.all` to process items concurrently, improving performance. If an error occurs during traversal, it is logged and rethrown.\\n\\nHere's an example of how this function might be used in the larger project:\\n\\n```javascript\\nawait traverseFileSystem({\\n  inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => {\\n    //", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1210", {"page_content": "inputPath: './src',\\n  projectName: 'myProject',\\n  processFile: (params) => {\\n    // Process file logic here\\n  },\\n  processFolder: (params) => {\\n    // Process folder logic here\\n  },\\n  ignore: ['node_modules/**', '.git/**'],\\n});\\n```\\n## Questions: \\n 1. **What is the purpose of the `traverseFileSystem` function?**\\n\\n   The `traverseFileSystem` function is an asynchronous function that traverses a given file system, processes folders and files based on the provided parameters, and ignores files and folders based on the given ignore patterns.\\n\\n2. **How does the `shouldIgnore` function work?**\\n\\n   The `shouldIgnore` function takes a file name as input and returns a boolean value indicating whether the file should be ignored or not. It checks if the file name matches any of the ignore patterns provided in the `ignore` parameter using the `minimatch` library.\\n\\n3. **What is the role of the `dfs` function inside `traverseFileSystem`?**\\n\\n   The `dfs` function is an", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1211", {"page_content": "is the role of the `dfs` function inside `traverseFileSystem`?**\\n\\n   The `dfs` function is an asynchronous function that performs a depth-first search on the file system starting from the given `currentPath`. It processes folders and files based on the provided parameters and recursively calls itself for each subdirectory found.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\utils\\\\traverseFileSystem.md\"}}],[\"23\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\cli\\\\utils\\\\WaitUtil.ts)\\n\\nThe code in this file provides two utility functions, `wait` and `forTrue`, which are designed to help manage asynchronous operations in the larger project. Both functions return a `Promise`, making them suitable for use with `async/await` syntax.\\n\\n### wait\\n\\nThe `wait` function takes two arguments: `timeoutMs`, a number representing the desired waiting time in milliseconds, and an optional `value` that defaults to `null`. It returns a `Promise` that", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1212", {"page_content": "time in milliseconds, and an optional `value` that defaults to `null`. It returns a `Promise` that resolves with the provided `value` after the specified `timeoutMs` has elapsed. This function can be used to introduce a delay in the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nasync function delayedEcho() {\\n  console.log(\\\"Start\\\");\\n  await wait(1000, \\\"Hello\\\");\\n  console.log(\\\"End\\\");\\n}\\n\\ndelayedEcho(); // Output: Start -> (1 second delay) -> End\\n```\\n\\n### forTrue\\n\\nThe `forTrue` function takes a single argument, `fn`, which is a function that returns a boolean value. It returns a `Promise` that resolves with `true` when the provided function `fn` returns `true`. The function `fn` is checked every 50 milliseconds, up to a maximum of 200 times (i.e., 10 seconds). If `fn` does not return `true` within this time, the `Promise` is rejected.\\n\\nThis function can be used to wait for a specific condition to be met before continuing the execution of", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1213", {"page_content": "function can be used to wait for a specific condition to be met before continuing the execution of asynchronous code.\\n\\nExample usage:\\n\\n```javascript\\nlet condition = false;\\n\\nsetTimeout(() => {\\n  condition = true;\\n}, 3000);\\n\\nasync function waitForCondition() {\\n  console.log(\\\"Waiting for condition...\\\");\\n  await forTrue(() => condition);\\n  console.log(\\\"Condition met!\\\");\\n}\\n\\nwaitForCondition(); // Output: Waiting for condition... -> (3 second delay) -> Condition met!\\n```\\n\\nIn summary, this file provides two utility functions that help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used in the larger project to control the flow of asynchronous code execution.\\n## Questions: \\n 1. **What is the purpose of the `wait` function?**\\n\\n   The `wait` function is an asynchronous utility function that resolves a promise after a specified timeout in milliseconds, optionally returning a value when the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1214", {"page_content": "resolves a promise after a specified timeout in milliseconds, optionally returning a value when the promise is resolved.\\n\\n2. **How does the `forTrue` function work?**\\n\\n   The `forTrue` function takes a function `fn` as an argument, which should return a boolean value. It checks the result of `fn` every 50 milliseconds and resolves the promise when `fn` returns `true`. If `fn` does not return `true` after 200 attempts, the promise is rejected.\\n\\n3. **What is the use case for the `forTrue` function?**\\n\\n   The `forTrue` function can be used to wait for a certain condition to be met before proceeding with the execution of the code. This can be useful in situations where you need to wait for an asynchronous operation to complete or a specific state to be reached before continuing.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\cli\\\\utils\\\\WaitUtil.md\"}}],[\"24\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\const.ts)\\n\\nThe code in this file", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1215", {"page_content": "code on GitHub](https://github.com/context-labs/autodoc/src\\\\const.ts)\\n\\nThe code in this file is responsible for managing the user configuration file for the autodoc project. It imports two Node.js built-in modules, `path` and `os`, which are used to handle file paths and operating system-related utility functions, respectively.\\n\\nThe `userConfigFileName` constant is defined as `'autodoc.user.json'`, which represents the name of the user configuration file. This file is expected to store user-specific settings for the autodoc project in JSON format.\\n\\nThe `userConfigFilePath` constant is created using the `path.resolve()` function, which combines the provided arguments into an absolute file path. The `os.homedir()` function is used to get the current user's home directory, and `./.config/autodoc/` is appended to it as the folder where the user configuration file should be stored. Finally, the `userConfigFileName` constant is appended to the path, resulting in the complete file", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1216", {"page_content": "Finally, the `userConfigFileName` constant is appended to the path, resulting in the complete file path for the user configuration file.\\n\\nBy exporting both `userConfigFileName` and `userConfigFilePath`, other parts of the autodoc project can easily access and use these constants to read or write user-specific settings. For example, when the autodoc application starts, it can read the user configuration file from the specified path, and apply the settings accordingly.\\n\\nHere's a code example of how these constants might be used in another part of the autodoc project:\\n\\n```javascript\\nimport { userConfigFilePath } from './path/to/this/file';\\n\\n// Read user configuration from the file\\nconst userConfig = JSON.parse(fs.readFileSync(userConfigFilePath, 'utf-8'));\\n\\n// Apply user settings\\napplyUserSettings(userConfig);\\n```\\n\\nIn summary, this code is responsible for defining the name and file path of the user configuration file for the autodoc project, allowing other parts of the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1217", {"page_content": "and file path of the user configuration file for the autodoc project, allowing other parts of the project to easily access and manage user-specific settings.\\n## Questions: \\n 1. **What is the purpose of the `userConfigFileName` and `userConfigFilePath` constants?**\\n\\n   The `userConfigFileName` constant defines the name of the user configuration file for the autodoc project, while the `userConfigFilePath` constant defines the absolute path to this file, which is located in the user's home directory under the `.config/autodoc/` folder.\\n\\n2. **Why are the `node:path` and `node:os` modules being imported?**\\n\\n   The `node:path` module is imported to provide utilities for working with file and directory paths, such as resolving the absolute path to the user configuration file. The `node:os` module is imported to provide operating system-related utility methods, such as getting the user's home directory.\\n\\n3. **Is this code compatible with different operating systems?**\\n\\n   Yes,", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1218", {"page_content": "home directory.\\n\\n3. **Is this code compatible with different operating systems?**\\n\\n   Yes, this code is compatible with different operating systems. The `os.homedir()` method returns the home directory of the current user, which is platform-specific, and the `path.resolve()` method takes care of handling the correct path separators for the current operating system.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\const.md\"}}],[\"25\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\index.ts)\\n\\nThis code is the main entry point for the Autodoc CLI tool, which provides a set of commands to help developers automatically generate documentation for their codebase. The tool uses the `commander` library to define and handle commands, and `inquirer` for interactive prompts.\\n\\nThe available commands are:\\n\\n1. `init`: Initializes the repository by creating an `autodoc.config.json` file in the current directory. If the file already exists, it uses the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1219", {"page_content": "an `autodoc.config.json` file in the current directory. If the file already exists, it uses the existing configuration.\\n   ```bash\\n   autodoc init\\n   ```\\n\\n2. `estimate`: Estimates the cost of running the `index` command on the repository. It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc estimate\\n   ```\\n\\n3. `index`: Traverses the codebase, writes documentation using LLM, and creates a locally stored index. Before starting the indexing process, it prompts the user for confirmation. It requires the `autodoc.config.json` file to be present.\\n   ```bash\\n   autodoc index\\n   ```\\n\\n4. `user`: Sets the Autodoc user configuration. If a user configuration file exists, it uses the existing configuration.\\n   ```bash\\n   autodoc user\\n   ```\\n\\n5. `q`: Queries an Autodoc index. It requires both the `autodoc.config.json` and user configuration files to be present.\\n   ```bash\\n   autodoc q\\n   ```\\n\\nThe code also listens for unhandled promise rejections", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1220", {"page_content": "```bash\\n   autodoc q\\n   ```\\n\\nThe code also listens for unhandled promise rejections and handles them gracefully by showing an error spinner, stopping the spinner, and exiting with an error code.\\n\\nIn the larger project, this CLI tool serves as the primary interface for users to interact with Autodoc, allowing them to easily generate and manage documentation for their codebase.\\n## Questions: \\n 1. **What is the purpose of the Autodoc CLI Tool?**\\n\\n   The Autodoc CLI Tool is designed to help developers automatically generate documentation for their codebase by traversing the code, writing docs via LLM, and creating a locally stored index.\\n\\n2. **How does the `estimate` command work and what does it return?**\\n\\n   The `estimate` command reads the `autodoc.config.json` file and estimates the cost of running the `index` command on the repository. It provides an estimation of the resources required to generate the documentation.\\n\\n3. **What is the role of the `user` command and", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1221", {"page_content": "required to generate the documentation.\\n\\n3. **What is the role of the `user` command and how does it interact with the user configuration file?**\\n\\n   The `user` command is responsible for setting the Autodoc user configuration. It reads the user configuration file (if it exists) and allows the user to update or create a new configuration. This configuration is then used in other commands, such as the `query` command, to interact with the Autodoc index.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\index.md\"}}],[\"26\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\langchain\\\\hnswlib.ts)\\n\\nThe `HNSWLib` class in this code is a specialized vector store that uses the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. It is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. The main purpose of this class is to store and search for documents based on their embeddings, which", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1222", {"page_content": "main purpose of this class is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\\n\\nThe constructor of the `HNSWLib` class takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is used to convert documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.\\n\\nThe `addDocuments` method takes an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\\n\\nThe `save` and `load` methods allow for persisting the HNSW index, document store, and configuration options to disk and loading them back", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1223", {"page_content": "persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\\n\\nHere's an example of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nIn the larger project, the `HNSWLib` class can be used to efficiently store and search for documents based on their content similarity, which can be useful for tasks such as document clustering, recommendation systems, or information retrieval.\\n## Questions: \\n 1. **Question**: What", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1224", {"page_content": "recommendation systems, or information retrieval.\\n## Questions: \\n 1. **Question**: What is the purpose of the `HNSWLib` class and how does it relate to the `SaveableVectorStore` class?\\n   **Answer**: The `HNSWLib` class is an implementation of a vector store using the Hierarchical Navigable Small World (HNSW) algorithm from the `hnswlib-node` library. It extends the `SaveableVectorStore` class, which provides a base class for vector stores that can be saved and loaded from disk.\\n\\n2. **Question**: How does the `addDocuments` method work and what is its purpose?\\n   **Answer**: The `addDocuments` method takes an array of `Document` objects, extracts their `pageContent`, and embeds them using the provided `Embeddings` instance. It then adds the resulting vectors and documents to the HNSW index and the `InMemoryDocstore`, respectively.\\n\\n3. **Question**: How does the `similaritySearchVectorWithScore` method work and what does it return?\\n   **Answer**: The", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1225", {"page_content": "does the `similaritySearchVectorWithScore` method work and what does it return?\\n   **Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a number `k` as input, and searches for the `k` most similar vectors in the HNSW index. It returns an array of tuples, where each tuple contains a `Document` object and its corresponding similarity score to the query vector.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\langchain\\\\hnswlib.md\"}}],[\"27\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src\\\\langchain)\\n\\nThe `hnswlib.ts` file in the `.autodoc\\\\docs\\\\json\\\\src\\\\langchain` folder contains the `HNSWLib` class, which is a specialized vector store utilizing the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. This class is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. Its primary purpose is to store and search for documents", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1226", {"page_content": "extends the `SaveableVectorStore` class. Its primary purpose is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\\n\\nThe `HNSWLib` class constructor takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is responsible for converting documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.\\n\\nThe `addDocuments` method accepts an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\\n\\nThe `save` and `load` methods enable persisting the HNSW index, document store, and configuration", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1227", {"page_content": "`save` and `load` methods enable persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\\n\\nIn the larger project, the `HNSWLib` class can be employed to efficiently store and search for documents based on their content similarity, which can be beneficial for tasks such as document clustering, recommendation systems, or information retrieval.\\n\\nHere's an example of how to use the `HNSWLib` class:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector,", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1228", {"page_content": "... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nThis code snippet demonstrates how to create an `HNSWLib` instance, add documents to the index, and perform a similarity search. The results can then be used for various purposes, such as finding related documents or generating recommendations based on content similarity.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\langchain\\\\summary.md\"}}],[\"28\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\\\docs\\\\json\\\\src)\\n\\nThe `.autodoc\\\\docs\\\\json\\\\src` folder contains the core components of the autodoc project, which is designed to automatically generate documentation for a given code repository using OpenAI's language models (LLMs). The folder consists of three main files: `const.ts`, `index.ts`, and `types.ts`, as well as two subfolders: `cli` and `langchain`.\\n\\n`const.ts` defines the name and file path of the user configuration", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1229", {"page_content": "`cli` and `langchain`.\\n\\n`const.ts` defines the name and file path of the user configuration file for the autodoc project. This file stores user-specific settings in JSON format. Other parts of the project can easily access and use these constants to read or write user-specific settings. For example:\\n\\n```javascript\\nimport { userConfigFilePath } from './path/to/this/file';\\n\\n// Read user configuration from the file\\nconst userConfig = JSON.parse(fs.readFileSync(userConfigFilePath, 'utf-8'));\\n\\n// Apply user settings\\napplyUserSettings(userConfig);\\n```\\n\\n`index.ts` serves as the main entry point for the Autodoc CLI tool, providing a set of commands for developers to generate and manage documentation for their codebase. The available commands include `init`, `estimate`, `index`, `user`, and `q`. The CLI tool uses the `commander` library for command handling and `inquirer` for interactive prompts.\\n\\n`types.ts` defines the types and interfaces for the autodoc project, such as", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1230", {"page_content": "prompts.\\n\\n`types.ts` defines the types and interfaces for the autodoc project, such as `AutodocUserConfig`, `AutodocRepoConfig`, `FileSummary`, `FolderSummary`, and more. These types are used to configure and run the autodoc tool, allowing users to generate documentation for their code repositories using OpenAI's LLMs.\\n\\nThe `cli` subfolder contains the `spinner.ts` file, which manages a spinner for visual feedback during background processes. It exports functions like `updateSpinnerText`, `stopSpinner`, `spinnerError`, `spinnerSuccess`, and `spinnerInfo` for easy interaction with the spinner.\\n\\nThe `langchain` subfolder contains the `hnswlib.ts` file, which provides the `HNSWLib` class for efficient similarity search using the Hierarchical Navigable Small World (HNSW) algorithm. This class is used to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content. Example usage:\\n\\n```javascript\\nconst embeddings =", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1231", {"page_content": "vectors representing the documents' content. Example usage:\\n\\n```javascript\\nconst embeddings = new Embeddings(/* ... */);\\nconst args = { space: 'cosine' };\\nconst hnswLib = new HNSWLib(embeddings, args);\\n\\n// Add documents to the index\\nawait hnswLib.addDocuments(documents);\\n\\n// Perform a similarity search\\nconst queryVector = /* ... */;\\nconst k = 10;\\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\\n```\\n\\nIn summary, the code in this folder is responsible for the core functionality of the autodoc project, including user configuration management, CLI tool commands, type definitions, spinner management, and efficient similarity search using the HNSW algorithm.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\summary.md\"}}],[\"29\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/src\\\\types.ts)\\n\\nThis code defines the types and interfaces for the `autodoc` project, which aims to automatically generate documentation", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1232", {"page_content": "types and interfaces for the `autodoc` project, which aims to automatically generate documentation for a given code repository. The project uses OpenAI's language models (LLMs) to process and generate summaries, questions, and other relevant information for files and folders in the repository.\\n\\nThe `AutodocUserConfig` and `AutodocRepoConfig` types define the configuration options for the user and repository, respectively. These include settings such as the LLM models to use, repository URL, output directory, and content type.\\n\\n`FileSummary` and `FolderSummary` types represent the generated summaries for files and folders, including their paths, URLs, and checksums. The `ProcessFileParams` and `ProcessFolderParams` types define the parameters required for processing files and folders, such as the file or folder name, path, and content type.\\n\\n`ProcessFile` and `ProcessFolder` are function types that take the respective parameters and return a promise. These functions are", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1233", {"page_content": "are function types that take the respective parameters and return a promise. These functions are responsible for processing the files and folders, generating summaries, and updating the documentation.\\n\\n`TraverseFileSystemParams` type defines the parameters for traversing the file system, including the input path, project name, and optional `processFile` and `processFolder` functions. It also includes settings for ignoring certain files or folders and content type preferences.\\n\\nThe `LLMModels` enum lists the available language models, such as GPT-3.5 Turbo, GPT-4, and GPT-4 32k. The `LLMModelDetails` type provides information about each model, including the cost per 1K tokens, maximum length, and success/failure statistics.\\n\\nIn the larger project, these types and interfaces would be used to configure and run the `autodoc` tool, allowing users to automatically generate documentation for their code repositories using OpenAI's language models. For example, a user could provide an", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1234", {"page_content": "for their code repositories using OpenAI's language models. For example, a user could provide an `AutodocRepoConfig` object to configure the tool, and then use the `TraverseFileSystem` function to process the repository and generate the documentation.\\n## Questions: \\n 1. **What is the purpose of the `AutodocUserConfig` and `AutodocRepoConfig` types?**\\n\\n   The `AutodocUserConfig` type is used to define the user configuration for the autodoc project, which includes an array of LLMModels. The `AutodocRepoConfig` type is used to define the repository configuration for the autodoc project, which includes various properties such as name, repository URL, root, output, LLMModels, and more.\\n\\n2. **What are the different LLMModels available in the `LLMModels` enum?**\\n\\n   The `LLMModels` enum lists the available language models for the autodoc project. Currently, there are three models: GPT3 (gpt-3.5-turbo), GPT4 (gpt-4), and GPT432k (gpt-4-32k).\\n\\n3. **What is the purpose of the", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1235", {"page_content": "GPT3 (gpt-3.5-turbo), GPT4 (gpt-4), and GPT432k (gpt-4-32k).\\n\\n3. **What is the purpose of the `ProcessFile` and `ProcessFolder` types?**\\n\\n   The `ProcessFile` type is a function type that takes a `ProcessFileParams` object as input and returns a Promise. It is used to process a single file in the autodoc project. The `ProcessFolder` type is a function type that takes a `ProcessFolderParams` object as input and returns a Promise. It is used to process a folder in the autodoc project.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\src\\\\types.md\"}}],[\"30\",{\"pageContent\":\"[View code on GitHub](https://github.com/context-labs/autodoc/tsconfig.json)\\n\\nThe code provided is a configuration file for the TypeScript compiler in a project. It specifies various options that control how the TypeScript compiler should process the source code and generate the output JavaScript files. This configuration file is typically named `tsconfig.json` and is placed at the root of a TypeScript", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1236", {"page_content": "configuration file is typically named `tsconfig.json` and is placed at the root of a TypeScript project.\\n\\nThe `compilerOptions` object contains several key-value pairs that define the behavior of the TypeScript compiler:\\n\\n- `rootDir`: Specifies the root directory of the source files. In this case, it is set to \\\"src\\\", meaning that the source files are located in the \\\"src\\\" folder.\\n- `outDir`: Specifies the output directory for the compiled JavaScript files. In this case, it is set to \\\"dist\\\", meaning that the compiled files will be placed in the \\\"dist\\\" folder.\\n- `strict`: Enables strict type checking, which helps catch potential issues in the code.\\n- `target`: Specifies the ECMAScript target version for the output JavaScript files. In this case, it is set to \\\"es2020\\\", meaning that the output files will be compatible with ECMAScript 2020 features.\\n- `module`: Specifies the module system to be used. In this case, it is set to \\\"ES2020\\\", meaning that the output files will", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1237", {"page_content": "module system to be used. In this case, it is set to \\\"ES2020\\\", meaning that the output files will use the ECMAScript 2020 module system.\\n- `sourceMap`: Generates source map files, which help in debugging the compiled code by mapping it back to the original TypeScript source files.\\n- `esModuleInterop`: Enables compatibility with ECMAScript modules for importing CommonJS modules.\\n- `moduleResolution`: Specifies the module resolution strategy. In this case, it is set to \\\"node\\\", meaning that the Node.js module resolution algorithm will be used.\\n- `allowSyntheticDefaultImports`: Allows default imports from modules with no default export.\\n- `declaration`: Generates TypeScript declaration files (`.d.ts`) alongside the compiled JavaScript files, which can be useful for other projects that depend on this one.\\n- `skipLibCheck`: Skips type checking of declaration files, which can speed up the compilation process.\\n\\nOverall, this configuration file helps ensure that the TypeScript", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1238", {"page_content": "up the compilation process.\\n\\nOverall, this configuration file helps ensure that the TypeScript compiler processes the source code according to the specified options, resulting in compiled JavaScript files that are compatible with the desired ECMAScript version and module system, while also providing useful features like source maps and strict type checking.\\n## Questions: \\n 1. **What is the purpose of the `rootDir` and `outDir` options in the configuration?**\\n\\n   The `rootDir` option specifies the root directory of the input files, while the `outDir` option specifies the output directory for the compiled files.\\n\\n2. **What does the `strict` option do in the configuration?**\\n\\n   The `strict` option enables a wide range of type checking behavior that results in stronger guarantees of program correctness.\\n\\n3. **What is the significance of the `target` and `module` options in the configuration?**\\n\\n   The `target` option specifies the ECMAScript target version for the output", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1239", {"page_content": "configuration?**\\n\\n   The `target` option specifies the ECMAScript target version for the output code, and the `module` option specifies the module system used in the output code. In this case, both are set to \\\"es2020\\\", which means the output code will be compatible with ECMAScript 2020 features and module system.\",\"metadata\":{\"source\":\".autodoc\\\\docs\\\\markdown\\\\tsconfig.md\"}}]]", "metadata": {"source": "autodoc/.autodoc/docs/data/docstore.json"}, "type": "Document"}], ["1240", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src)\n\nThe `.autodoc\\docs\\json\\src` folder contains the core components of the autodoc project, which is designed to automatically generate documentation for a given code repository using OpenAI's language models (LLMs). The folder consists of three main files: `const.ts`, `index.ts`, and `types.ts`, as well as two subfolders: `cli` and `langchain`.\n\n`const.ts` defines the name and file path of the user configuration file for the autodoc project. This file stores user-specific settings in JSON format. Other parts of the project can easily access and use these constants to read or write user-specific settings. For example:\n\n```javascript\nimport { userConfigFilePath } from './path/to/this/file';\n\n// Read user configuration from the file\nconst userConfig = JSON.parse(fs.readFileSync(userConfigFilePath, 'utf-8'));\n\n// Apply user settings\napplyUserSettings(userConfig);\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/summary.md"}, "type": "Document"}], ["1241", {"page_content": "// Apply user settings\napplyUserSettings(userConfig);\n```\n\n`index.ts` serves as the main entry point for the Autodoc CLI tool, providing a set of commands for developers to generate and manage documentation for their codebase. The available commands include `init`, `estimate`, `index`, `user`, and `q`. The CLI tool uses the `commander` library for command handling and `inquirer` for interactive prompts.\n\n`types.ts` defines the types and interfaces for the autodoc project, such as `AutodocUserConfig`, `AutodocRepoConfig`, `FileSummary`, `FolderSummary`, and more. These types are used to configure and run the autodoc tool, allowing users to generate documentation for their code repositories using OpenAI's LLMs.\n\nThe `cli` subfolder contains the `spinner.ts` file, which manages a spinner for visual feedback during background processes. It exports functions like `updateSpinnerText`, `stopSpinner`, `spinnerError`, `spinnerSuccess`, and `spinnerInfo` for easy interaction with the spinner.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/summary.md"}, "type": "Document"}], ["1242", {"page_content": "The `langchain` subfolder contains the `hnswlib.ts` file, which provides the `HNSWLib` class for efficient similarity search using the Hierarchical Navigable Small World (HNSW) algorithm. This class is used to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content. Example usage:\n\n```javascript\nconst embeddings = new Embeddings(/* ... */);\nconst args = { space: 'cosine' };\nconst hnswLib = new HNSWLib(embeddings, args);\n\n// Add documents to the index\nawait hnswLib.addDocuments(documents);\n\n// Perform a similarity search\nconst queryVector = /* ... */;\nconst k = 10;\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\n```\n\nIn summary, the code in this folder is responsible for the core functionality of the autodoc project, including user configuration management, CLI tool commands, type definitions, spinner management, and efficient similarity search using the HNSW algorithm.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/summary.md"}, "type": "Document"}], ["1243", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\types.ts)\n\nThis code defines the types and interfaces for the `autodoc` project, which aims to automatically generate documentation for a given code repository. The project uses OpenAI's language models (LLMs) to process and generate summaries, questions, and other relevant information for files and folders in the repository.\n\nThe `AutodocUserConfig` and `AutodocRepoConfig` types define the configuration options for the user and repository, respectively. These include settings such as the LLM models to use, repository URL, output directory, and content type.\n\n`FileSummary` and `FolderSummary` types represent the generated summaries for files and folders, including their paths, URLs, and checksums. The `ProcessFileParams` and `ProcessFolderParams` types define the parameters required for processing files and folders, such as the file or folder name, path, and content type.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/types.md"}, "type": "Document"}], ["1244", {"page_content": "`ProcessFile` and `ProcessFolder` are function types that take the respective parameters and return a promise. These functions are responsible for processing the files and folders, generating summaries, and updating the documentation.\n\n`TraverseFileSystemParams` type defines the parameters for traversing the file system, including the input path, project name, and optional `processFile` and `processFolder` functions. It also includes settings for ignoring certain files or folders and content type preferences.\n\nThe `LLMModels` enum lists the available language models, such as GPT-3.5 Turbo, GPT-4, and GPT-4 32k. The `LLMModelDetails` type provides information about each model, including the cost per 1K tokens, maximum length, and success/failure statistics.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/types.md"}, "type": "Document"}], ["1245", {"page_content": "In the larger project, these types and interfaces would be used to configure and run the `autodoc` tool, allowing users to automatically generate documentation for their code repositories using OpenAI's language models. For example, a user could provide an `AutodocRepoConfig` object to configure the tool, and then use the `TraverseFileSystem` function to process the repository and generate the documentation.\n## Questions: \n 1. **What is the purpose of the `AutodocUserConfig` and `AutodocRepoConfig` types?**\n\n   The `AutodocUserConfig` type is used to define the user configuration for the autodoc project, which includes an array of LLMModels. The `AutodocRepoConfig` type is used to define the repository configuration for the autodoc project, which includes various properties such as name, repository URL, root, output, LLMModels, and more.\n\n2. **What are the different LLMModels available in the `LLMModels` enum?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/types.md"}, "type": "Document"}], ["1246", {"page_content": "2. **What are the different LLMModels available in the `LLMModels` enum?**\n\n   The `LLMModels` enum lists the available language models for the autodoc project. Currently, there are three models: GPT3 (gpt-3.5-turbo), GPT4 (gpt-4), and GPT432k (gpt-4-32k).\n\n3. **What is the purpose of the `ProcessFile` and `ProcessFolder` types?**\n\n   The `ProcessFile` type is a function type that takes a `ProcessFileParams` object as input and returns a Promise. It is used to process a single file in the autodoc project. The `ProcessFolder` type is a function type that takes a `ProcessFolderParams` object as input and returns a Promise. It is used to process a folder in the autodoc project.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/types.md"}, "type": "Document"}], ["1247", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli)\n\nThe code in the `spinner.ts` file, located in the `.autodoc\\docs\\json\\src\\cli` folder, is responsible for managing a spinner, a visual element that indicates a background process is running. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\n\nThe module exports several functions to interact with the spinner:\n\n1. `updateSpinnerText(message: string)`: Updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\n\n   Example usage:\n   ```javascript\n   updateSpinnerText('Loading data...');\n   ```\n\n2. `stopSpinner()`: Stops the spinner if it is currently spinning.\n\n   Example usage:\n   ```javascript\n   stopSpinner();\n   ```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/summary.md"}, "type": "Document"}], ["1248", {"page_content": "Example usage:\n   ```javascript\n   stopSpinner();\n   ```\n\n3. `spinnerError(message?: string)`: Stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\n\n   Example usage:\n   ```javascript\n   spinnerError('Failed to load data');\n   ```\n\n4. `spinnerSuccess(message?: string)`: Stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\n\n   Example usage:\n   ```javascript\n   spinnerSuccess('Data loaded successfully');\n   ```\n\n5. `spinnerInfo(message: string)`: Displays an informational message without affecting the spinner's state.\n\n   Example usage:\n   ```javascript\n   spinnerInfo('Connecting to server...');\n   ```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/summary.md"}, "type": "Document"}], ["1249", {"page_content": "Example usage:\n   ```javascript\n   spinnerInfo('Connecting to server...');\n   ```\n\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/summary.md"}, "type": "Document"}], ["1250", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\spinner.ts)\n\nThis code is responsible for managing a spinner, which is a visual element that indicates a process is running in the background. The spinner is created using the `ora` library, which provides a simple and customizable way to create spinners for command-line interfaces.\n\nThe code starts by importing the `ora` library and creating a singleton spinner instance with the 'dots' style. This ensures that there will only be one spinner active at any given time.\n\nThere are several functions exported by this module to interact with the spinner:\n\n1. `updateSpinnerText(message: string)`: This function updates the spinner's text with the provided message. If the spinner is already spinning, it simply updates the text; otherwise, it starts the spinner with the new message.\n\n   Example usage:\n   ```javascript\n   updateSpinnerText('Loading data...');\n   ```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/spinner.md"}, "type": "Document"}], ["1251", {"page_content": "Example usage:\n   ```javascript\n   updateSpinnerText('Loading data...');\n   ```\n\n2. `stopSpinner()`: This function stops the spinner if it is currently spinning.\n\n   Example usage:\n   ```javascript\n   stopSpinner();\n   ```\n\n3. `spinnerError(message?: string)`: This function stops the spinner and marks it as failed with an optional error message. It only takes effect if the spinner is currently spinning.\n\n   Example usage:\n   ```javascript\n   spinnerError('Failed to load data');\n   ```\n\n4. `spinnerSuccess(message?: string)`: This function stops the spinner and marks it as successful with an optional success message. It only takes effect if the spinner is currently spinning.\n\n   Example usage:\n   ```javascript\n   spinnerSuccess('Data loaded successfully');\n   ```\n\n5. `spinnerInfo(message: string)`: This function displays an informational message without affecting the spinner's state.\n\n   Example usage:\n   ```javascript\n   spinnerInfo('Connecting to server...');\n   ```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/spinner.md"}, "type": "Document"}], ["1252", {"page_content": "Example usage:\n   ```javascript\n   spinnerInfo('Connecting to server...');\n   ```\n\nIn the larger project, this module can be used to provide visual feedback to users when a background process is running, such as loading data, connecting to a server, or performing a complex calculation. By using the exported functions, developers can easily update the spinner's text, stop it, or change its state to indicate success, failure, or display informational messages.\n## Questions: \n 1. **What is the purpose of the `ora` package in this code?**\n\n   The `ora` package is used to create a spinner in the command line interface, providing a visual indication of a running process. In this code, it is used to create a singleton spinner with the 'dots' style.\n\n2. **How does the `updateSpinnerText` function work?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/spinner.md"}, "type": "Document"}], ["1253", {"page_content": "2. **How does the `updateSpinnerText` function work?**\n\n   The `updateSpinnerText` function takes a message as an input and updates the spinner's text with the given message. If the spinner is already spinning, it updates the text directly; otherwise, it starts the spinner with the new message.\n\n3. **What are the differences between `spinnerError`, `spinnerSuccess`, and `spinnerInfo` functions?**\n\n   These functions are used to update the spinner's state and message based on the outcome of a process. `spinnerError` is called when there is an error, and it stops the spinner with a failure message. `spinnerSuccess` is called when the process is successful, and it stops the spinner with a success message. `spinnerInfo` is used to display an informational message without stopping the spinner.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/spinner.md"}, "type": "Document"}], ["1254", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\utils\\APIRateLimit.ts)\n\nThe `APIRateLimit` class in this code snippet is designed to manage and limit the number of concurrent API calls made by the application. This is useful in situations where the API being called has a rate limit or when the application needs to prevent overwhelming the server with too many requests at once.\n\nThe class constructor takes an optional parameter `maxConcurrentCalls`, which defaults to 50, to set the maximum number of concurrent API calls allowed. It maintains a queue of API calls and keeps track of the number of calls in progress.\n\nThe main method of this class is `callApi<T>(apiFunction: () => Promise<T>): Promise<T>`. It takes a function `apiFunction` that returns a promise and wraps it in a new promise. The purpose of this wrapping is to control the execution of the API calls and ensure that they do not exceed the specified rate limit.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/APIRateLimit.md"}, "type": "Document"}], ["1255", {"page_content": "When `callApi` is called, the provided `apiFunction` is added to the queue and the `dequeueAndExecute` method is triggered if there are available slots for concurrent calls. The `dequeueAndExecute` method checks if there are any API calls in the queue and if the number of in-progress calls is below the maximum limit. If both conditions are met, it dequeues the next API call and executes it.\n\nThe `executeCall` function inside `callApi` is responsible for actually calling the API function, resolving or rejecting the promise based on the result, and updating the number of in-progress calls. Once an API call is completed, the `dequeueAndExecute` method is called again to process any remaining calls in the queue.\n\nHere's an example of how this class can be used in the larger project:\n\n```javascript\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/APIRateLimit.md"}, "type": "Document"}], ["1256", {"page_content": "```javascript\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\n\nasync function fetchSomeData(id) {\n  // Call the API using the rate limiter\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\n  return result;\n}\n```\n\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls to the `fetch` function, ensuring that no more than 10 calls are made at once.\n## Questions: \n 1. **What is the purpose of the `APIRateLimit` class?**\n\n   The `APIRateLimit` class is designed to manage and limit the number of concurrent API calls to a specified maximum, preventing the application from overwhelming the API with too many requests at once.\n\n2. **How does the `callApi` method work and what is its return type?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/APIRateLimit.md"}, "type": "Document"}], ["1257", {"page_content": "2. **How does the `callApi` method work and what is its return type?**\n\n   The `callApi` method takes an `apiFunction` as an argument, which is a function that returns a Promise. It adds the API call to a queue and executes it when there are available slots for concurrent calls. The method returns a Promise of type `T`, where `T` is the expected return type of the `apiFunction`.\n\n3. **How can the maximum number of concurrent calls be configured?**\n\n   The maximum number of concurrent calls can be configured by passing a value to the `maxConcurrentCalls` parameter in the constructor of the `APIRateLimit` class. If no value is provided, the default value is set to 50.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/APIRateLimit.md"}, "type": "Document"}], ["1258", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\utils\\LLMUtil.ts)\n\nThis code defines and manages different language models (LLMs) and their associated costs for a project that utilizes OpenAI's GPT models. It imports the `OpenAIChat` class from the `langchain/llms` module and the `LLMModelDetails` and `LLMModels` types from the `../../types.js` file.\n\nThe `models` object contains three LLMs: GPT3, GPT4, and GPT432k. Each model has its own properties, such as `name`, `inputCostPer1KTokens`, `outputCostPer1KTokens`, `maxLength`, and an instance of the `OpenAIChat` class with the respective model name and API key. Additionally, each model has counters for input tokens, output tokens, succeeded, failed, and total files processed.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/LLMUtil.md"}, "type": "Document"}], ["1259", {"page_content": "The `printModelDetails` function takes an array of `LLMModelDetails` and prints a summary table to the console. It calculates the total cost for each model based on the input and output tokens and their respective costs per 1,000 tokens. It also calculates the total file count, succeeded, failed, tokens, and cost across all models.\n\nThe `totalIndexCostEstimate` function calculates the total cost of indexing all models in the input array. It uses the same cost calculation as in `printModelDetails` but returns the total cost as a number.\n\nThese functions can be used in the larger project to manage and analyze the usage and costs of different LLMs. For example, the `printModelDetails` function can be called to display a summary of the models' usage and costs:\n\n```javascript\nimport { models, printModelDetails } from './path/to/this/file';\n\n// Process files with models...\n// Update models' properties...\n\nprintModelDetails(Object.values(models));\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/LLMUtil.md"}, "type": "Document"}], ["1260", {"page_content": "printModelDetails(Object.values(models));\n```\n\nAnd the `totalIndexCostEstimate` function can be used to estimate the total cost of indexing all models:\n\n```javascript\nimport { models, totalIndexCostEstimate } from './path/to/this/file';\n\n// Process files with models...\n// Update models' properties...\n\nconst totalCost = totalIndexCostEstimate(Object.values(models));\nconsole.log(`Total cost: ${totalCost}`);\n```\n## Questions: \n 1. **Question:** What is the purpose of the `models` object and how are the different GPT models being used?\n   **Answer:** The `models` object is a record that maps different GPT models (GPT3, GPT4, and GPT432k) to their respective details, such as cost per tokens, maximum length, and an instance of `OpenAIChat` with the corresponding model configuration.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/LLMUtil.md"}, "type": "Document"}], ["1261", {"page_content": "2. **Question:** How does the `printModelDetails` function work and what information does it display?\n   **Answer:** The `printModelDetails` function takes an array of `LLMModelDetails` as input, processes the information for each model, and then prints a summary table to the console. The table includes the model name, file count, succeeded and failed counts, total tokens, and cost.\n\n3. **Question:** What is the purpose of the `totalIndexCostEstimate` function and how is it calculating the total cost?\n   **Answer:** The `totalIndexCostEstimate` function calculates the total cost of processing the given models by iterating through the input `models` array and summing up the costs based on the input and output tokens and their respective costs per 1K tokens.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/LLMUtil.md"}, "type": "Document"}], ["1262", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\utils)\n\nThe `.autodoc\\docs\\json\\src\\cli\\utils` folder contains utility functions and classes that assist in managing API rate limits, handling file and folder paths, managing language models, traversing file systems, and controlling asynchronous operations. These utilities can be used throughout the autodoc project to ensure consistent behavior and improve code organization.\n\n`APIRateLimit.ts` provides the `APIRateLimit` class, which manages and limits the number of concurrent API calls made by the application. This is useful when working with rate-limited APIs or preventing server overload. Example usage:\n\n```javascript\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\nasync function fetchSomeData(id) {\n  const result = await apiRateLimiter.callApi(() => fetch(`https://api.example.com/data/${id}`));\n  return result;\n}\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/summary.md"}, "type": "Document"}], ["1263", {"page_content": "`FileUtil.ts` offers utility functions for generating file names and GitHub URLs for documentation files. These functions ensure consistent naming and URL generation across the project. Example usage:\n\n```javascript\ngetFileName('example.txt'); // returns 'example.md'\ngithubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true); // returns 'https://github.com/user/repo/example.md'\n```\n\n`LLMUtil.ts` defines and manages different language models (LLMs) and their associated costs for a project utilizing OpenAI's GPT models. Functions like `printModelDetails` and `totalIndexCostEstimate` can be used to manage and analyze the usage and costs of different LLMs. Example usage:\n\n```javascript\nimport { models, printModelDetails } from './path/to/this/file';\nprintModelDetails(Object.values(models));\nconst totalCost = totalIndexCostEstimate(Object.values(models));\nconsole.log(`Total cost: ${totalCost}`);\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/summary.md"}, "type": "Document"}], ["1264", {"page_content": "`traverseFileSystem.ts` contains the `traverseFileSystem` function, which recursively traverses a given file system, processing files and folders based on provided parameters. This is useful for generating documentation or performing tasks that require processing files and folders in a directory structure. Example usage:\n\n```javascript\nawait traverseFileSystem({\n  inputPath: './src',\n  projectName: 'myProject',\n  processFile: (params) => { /* Process file logic */ },\n  processFolder: (params) => { /* Process folder logic */ },\n  ignore: ['node_modules/**', '.git/**'],\n});\n```\n\n`WaitUtil.ts` provides two utility functions, `wait` and `forTrue`, which help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used to control the flow of asynchronous code execution. Example usage:\n\n```javascript\nasync function delayedEcho() {\n  console.log(\"Start\");\n  await wait(1000, \"Hello\");\n  console.log(\"End\");\n}", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/summary.md"}, "type": "Document"}], ["1265", {"page_content": "async function waitForCondition() {\n  console.log(\"Waiting for condition...\");\n  await forTrue(() => condition);\n  console.log(\"Condition met!\");\n}\n```\n\nIn summary, the utilities in this folder enhance the autodoc project by providing consistent behavior, improving code organization, and managing various aspects of the project, such as API rate limits, file and folder paths, language models, file system traversal, and asynchronous operations.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/summary.md"}, "type": "Document"}], ["1266", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\utils\\traverseFileSystem.ts)\n\nThe `traverseFileSystem` function in this code is an asynchronous function that recursively traverses a given file system, processing files and folders based on the provided parameters. It is designed to be used in the larger project for generating documentation or performing other tasks that require processing files and folders in a directory structure.\n\nThe function takes an object of type `TraverseFileSystemParams` as its input, which contains various properties to control the traversal and processing behavior. These properties include:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/traverseFileSystem.md"}, "type": "Document"}], ["1267", {"page_content": "- `inputPath`: The root path to start the traversal from.\n- `projectName`: The name of the project being processed.\n- `processFile`: An optional callback function to process a file.\n- `processFolder`: An optional callback function to process a folder.\n- `ignore`: An array of patterns to ignore during traversal.\n- `filePrompt`, `folderPrompt`: Optional prompts for user interaction.\n- `contentType`, `targetAudience`, `linkHosted`: Additional metadata for processing.\n\nThe function first checks if the provided `inputPath` exists using `fs.access`. If the path does not exist, it logs an error message and returns. It then defines a helper function `shouldIgnore` that checks if a given file or folder should be ignored based on the `ignore` patterns.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/traverseFileSystem.md"}, "type": "Document"}], ["1268", {"page_content": "The main logic of the function is implemented in the `dfs` (depth-first search) function, which is called recursively to traverse the file system. It reads the contents of the current directory using `fs.readdir`, filters out ignored items, and processes the remaining items.\n\nFor each item, if it is a directory, the `dfs` function is called recursively, and the `processFolder` callback is invoked if provided. If it is a file and its content is text (checked using `isText`), the `processFile` callback is invoked if provided.\n\nThe traversal is performed using `Promise.all` to process items concurrently, improving performance. If an error occurs during traversal, it is logged and rethrown.\n\nHere's an example of how this function might be used in the larger project:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/traverseFileSystem.md"}, "type": "Document"}], ["1269", {"page_content": "Here's an example of how this function might be used in the larger project:\n\n```javascript\nawait traverseFileSystem({\n  inputPath: './src',\n  projectName: 'myProject',\n  processFile: (params) => {\n    // Process file logic here\n  },\n  processFolder: (params) => {\n    // Process folder logic here\n  },\n  ignore: ['node_modules/**', '.git/**'],\n});\n```\n## Questions: \n 1. **What is the purpose of the `traverseFileSystem` function?**\n\n   The `traverseFileSystem` function is an asynchronous function that traverses a given file system, processes folders and files based on the provided parameters, and ignores files and folders based on the given ignore patterns.\n\n2. **How does the `shouldIgnore` function work?**\n\n   The `shouldIgnore` function takes a file name as input and returns a boolean value indicating whether the file should be ignored or not. It checks if the file name matches any of the ignore patterns provided in the `ignore` parameter using the `minimatch` library.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/traverseFileSystem.md"}, "type": "Document"}], ["1270", {"page_content": "3. **What is the role of the `dfs` function inside `traverseFileSystem`?**\n\n   The `dfs` function is an asynchronous function that performs a depth-first search on the file system starting from the given `currentPath`. It processes folders and files based on the provided parameters and recursively calls itself for each subdirectory found.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/traverseFileSystem.md"}, "type": "Document"}], ["1271", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\utils\\WaitUtil.ts)\n\nThe code in this file provides two utility functions, `wait` and `forTrue`, which are designed to help manage asynchronous operations in the larger project. Both functions return a `Promise`, making them suitable for use with `async/await` syntax.\n\n### wait\n\nThe `wait` function takes two arguments: `timeoutMs`, a number representing the desired waiting time in milliseconds, and an optional `value` that defaults to `null`. It returns a `Promise` that resolves with the provided `value` after the specified `timeoutMs` has elapsed. This function can be used to introduce a delay in the execution of asynchronous code.\n\nExample usage:\n\n```javascript\nasync function delayedEcho() {\n  console.log(\"Start\");\n  await wait(1000, \"Hello\");\n  console.log(\"End\");\n}\n\ndelayedEcho(); // Output: Start -> (1 second delay) -> End\n```\n\n### forTrue", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/WaitUtil.md"}, "type": "Document"}], ["1272", {"page_content": "delayedEcho(); // Output: Start -> (1 second delay) -> End\n```\n\n### forTrue\n\nThe `forTrue` function takes a single argument, `fn`, which is a function that returns a boolean value. It returns a `Promise` that resolves with `true` when the provided function `fn` returns `true`. The function `fn` is checked every 50 milliseconds, up to a maximum of 200 times (i.e., 10 seconds). If `fn` does not return `true` within this time, the `Promise` is rejected.\n\nThis function can be used to wait for a specific condition to be met before continuing the execution of asynchronous code.\n\nExample usage:\n\n```javascript\nlet condition = false;\n\nsetTimeout(() => {\n  condition = true;\n}, 3000);\n\nasync function waitForCondition() {\n  console.log(\"Waiting for condition...\");\n  await forTrue(() => condition);\n  console.log(\"Condition met!\");\n}\n\nwaitForCondition(); // Output: Waiting for condition... -> (3 second delay) -> Condition met!\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/WaitUtil.md"}, "type": "Document"}], ["1273", {"page_content": "waitForCondition(); // Output: Waiting for condition... -> (3 second delay) -> Condition met!\n```\n\nIn summary, this file provides two utility functions that help manage asynchronous operations by introducing delays and waiting for specific conditions to be met. These functions can be used in the larger project to control the flow of asynchronous code execution.\n## Questions: \n 1. **What is the purpose of the `wait` function?**\n\n   The `wait` function is an asynchronous utility function that resolves a promise after a specified timeout in milliseconds, optionally returning a value when the promise is resolved.\n\n2. **How does the `forTrue` function work?**\n\n   The `forTrue` function takes a function `fn` as an argument, which should return a boolean value. It checks the result of `fn` every 50 milliseconds and resolves the promise when `fn` returns `true`. If `fn` does not return `true` after 200 attempts, the promise is rejected.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/WaitUtil.md"}, "type": "Document"}], ["1274", {"page_content": "3. **What is the use case for the `forTrue` function?**\n\n   The `forTrue` function can be used to wait for a certain condition to be met before proceeding with the execution of the code. This can be useful in situations where you need to wait for an asynchronous operation to complete or a specific state to be reached before continuing.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/WaitUtil.md"}, "type": "Document"}], ["1275", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\utils\\FileUtil.ts)\n\nThis code provides utility functions for handling file and folder paths in the autodoc project. The main purpose of these functions is to generate file names and GitHub URLs for documentation files.\n\n1. `getFileName(input, delimiter, extension)`: This function takes an input string, an optional delimiter (default is '.'), and an optional extension (default is '.md'). It returns a new string with the given extension. If the delimiter is found in the input string, the function removes the part of the string after the last occurrence of the delimiter and appends the extension. If the delimiter is not found, the function simply appends the extension to the input string. This function can be used to generate file names for documentation files with the desired extension.\n\n   Example usage:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/FileUtil.md"}, "type": "Document"}], ["1276", {"page_content": "Example usage:\n\n   ```\n   getFileName('example.txt'); // returns 'example.md'\n   getFileName('example', '_', '.html'); // returns 'example.html'\n   ```\n\n2. `githubFileUrl(githubRoot, inputRoot, filePath, linkHosted)`: This function generates a GitHub URL for a file. It takes the GitHub repository root URL, the input root folder path, the file path, and a boolean flag indicating whether the URL should be for the hosted version of the file or the source code. It returns a string with the generated URL.\n\n   Example usage:\n\n   ```\n   githubFileUrl('https://github.com/user/repo', '/input', '/input/example.md', true);\n   // returns 'https://github.com/user/repo/example.md'\n   ```\n\n3. `githubFolderUrl(githubRoot, inputRoot, folderPath, linkHosted)`: This function is similar to `githubFileUrl`, but it generates a GitHub URL for a folder instead of a file. It takes the same arguments as `githubFileUrl` and returns a string with the generated URL.\n\n   Example usage:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/FileUtil.md"}, "type": "Document"}], ["1277", {"page_content": "Example usage:\n\n   ```\n   githubFolderUrl('https://github.com/user/repo', '/input', '/input/folder', true);\n   // returns 'https://github.com/user/repo/folder'\n   ```\n\nThese utility functions can be used throughout the autodoc project to generate file names and GitHub URLs for documentation files and folders, ensuring consistent naming and URL generation across the project.\n## Questions: \n 1. **What is the purpose of the `getFileName` function?**\n\n   The `getFileName` function takes an input string, an optional delimiter, and an optional extension, and returns a new string with the given extension. If the delimiter is not found in the input string, the extension is simply appended to the input string. If the delimiter is found, the input string is sliced up to the last delimiter index and the extension is appended.\n\n2. **What are the differences between the `githubFileUrl` and `githubFolderUrl` functions?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/FileUtil.md"}, "type": "Document"}], ["1278", {"page_content": "2. **What are the differences between the `githubFileUrl` and `githubFolderUrl` functions?**\n\n   Both functions take the same parameters: `githubRoot`, `inputRoot`, a path (either `filePath` or `folderPath`), and a `linkHosted` boolean. The main difference is in the returned URL: `githubFileUrl` returns a URL pointing to a file in the GitHub repository, while `githubFolderUrl` returns a URL pointing to a folder in the GitHub repository. The URL structure differs slightly, with `/blob/master/` for files and `/tree/master/` for folders.\n\n3. **What is the purpose of the `linkHosted` parameter in the `githubFileUrl` and `githubFolderUrl` functions?**\n\n   The `linkHosted` parameter is a boolean that determines whether the returned URL should point to the hosted version of the file or folder on GitHub Pages (if `true`) or to the file or folder within the GitHub repository itself (if `false`). Depending on the value of `linkHosted`, the functions will return different URL structures.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/utils/FileUtil.md"}, "type": "Document"}], ["1279", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\commands\\init)\n\nThe `index.ts` file in the `.autodoc\\docs\\json\\src\\cli\\commands\\init` folder is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\n\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/init/summary.md"}, "type": "Document"}], ["1280", {"page_content": "The `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.\n\nNext, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\n\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\n\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\n\nExample usage:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/init/summary.md"}, "type": "Document"}], ["1281", {"page_content": "Example usage:\n\n```javascript\nimport { init } from './path/to/this/file';\n\n// Initialize the configuration with default values\nawait init();\n\n// Initialize the configuration with custom values\nawait init({\n  name: 'My Custom Repository',\n  repositoryUrl: 'https://github.com/user/repo',\n});\n```\n\nThis code is essential for setting up the Autodoc project, as it creates the necessary configuration file and gathers user input to customize the project. It works in conjunction with other parts of the project, such as the CLI and the documentation generation process, which rely on the configuration file to function correctly.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/init/summary.md"}, "type": "Document"}], ["1282", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\init\\index.ts)\n\nThis code is responsible for initializing the configuration of the Autodoc project. It provides a template for the configuration and prompts the user to input necessary information to set up the project. The main functionality is exposed through the `init` function, which is an asynchronous function that takes an optional `AutodocRepoConfig` object as an argument.\n\nThe `makeConfigTemplate` function creates a default configuration object with pre-defined values for various properties. It takes an optional `config` parameter and returns a new `AutodocRepoConfig` object with the provided values or default values if not provided.\n\nThe `init` function first checks if an `autodoc.config.json` file already exists in the project root. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/init/index.md"}, "type": "Document"}], ["1283", {"page_content": "Next, the user is prompted to enter the name of their repository, the GitHub URL of their repository, and the LLMs they have access to. The LLMs are language models used for generating documentation. The user can choose between GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access).\n\nAfter the user provides the necessary information, a new configuration object is created using the `makeConfigTemplate` function with the user's input. The new configuration is then written to the `autodoc.config.json` file in the project root.\n\nFinally, a success message is displayed, instructing the user to run `doc index` to get started with the Autodoc project.\n\nExample usage:\n\n```javascript\nimport { init } from './path/to/this/file';\n\n// Initialize the configuration with default values\nawait init();", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/init/index.md"}, "type": "Document"}], ["1284", {"page_content": "// Initialize the configuration with default values\nawait init();\n\n// Initialize the configuration with custom values\nawait init({\n  name: 'My Custom Repository',\n  repositoryUrl: 'https://github.com/user/repo',\n});\n```\n## Questions: \n 1. **What is the purpose of the `makeConfigTemplate` function?**\n\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc project. It takes an optional `config` parameter of type `AutodocRepoConfig` and returns a new configuration object with default values for various properties.\n\n2. **How does the `init` function work and when is it called?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/init/index.md"}, "type": "Document"}], ["1285", {"page_content": "2. **How does the `init` function work and when is it called?**\n\n   The `init` function is an asynchronous function that initializes the Autodoc configuration by creating an `autodoc.config.json` file in the specified location. It takes an optional `config` parameter of type `AutodocRepoConfig` and prompts the user for input to set the configuration values. It is called when the user wants to set up the Autodoc configuration for their project.\n\n3. **What is the purpose of the `inquirer.prompt` calls in the `init` function?**\n\n   The `inquirer.prompt` calls are used to interactively prompt the user for input to set the configuration values for the Autodoc project. The user is asked for the repository name, repository URL, and the LLMs they have access to. The input is then used to create a new configuration object and write it to the `autodoc.config.json` file.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/init/index.md"}, "type": "Document"}], ["1286", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\commands)\n\nThe code in the `.autodoc\\docs\\json\\src\\cli\\commands` folder is responsible for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project. The folder contains several subfolders, each with a specific purpose.\n\n### estimate\n\nThe `estimate` function provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input and performs a dry run of the repository processing to calculate the estimated cost. Example usage:\n\n```javascript\nimport { estimate } from './path/to/this/file';", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/summary.md"}, "type": "Document"}], ["1287", {"page_content": "```javascript\nimport { estimate } from './path/to/this/file';\n\nconst config = {\n  name: 'my-repo',\n  repositoryUrl: 'https://github.com/user/my-repo.git',\n  root: './',\n  output: './output',\n  llms: ['en'],\n  ignore: ['.git', 'node_modules'],\n  filePrompt: true,\n  folderPrompt: true,\n  chatPrompt: true,\n  contentType: 'code',\n  targetAudience: 'developers',\n  linkHosted: true,\n};\n\nestimate(config);\n```\n\n### index\n\nThe code in this folder processes a given repository and generates documentation in JSON, Markdown, and vector formats. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository, creating Markdown files, and creating vector files. Example usage:\n\n```javascript\nindex({\n  name: \"myProject\",\n  root: \"./input\",\n  output: \"./output\",\n  filePrompt: true,\n  folderPrompt: true,\n  contentType: \"code\",\n  targetAudience: \"developers\",\n  linkHosted: \"https://github.com/user/myProject\",\n});\n```\n\n### init", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/summary.md"}, "type": "Document"}], ["1288", {"page_content": "### init\n\nThe `init` function initializes the configuration of the Autodoc project. It prompts the user to input necessary information to set up the project and creates the `autodoc.config.json` file in the project root. Example usage:\n\n```javascript\nimport { init } from './path/to/this/file';\n\n// Initialize the configuration with default values\nawait init();\n\n// Initialize the configuration with custom values\nawait init({\n  name: 'My Custom Repository',\n  repositoryUrl: 'https://github.com/user/repo',\n});\n```\n\n### query\n\nThe `query` folder contains code for creating a chatbot that can answer questions about a specific software project. The main entry point is the `query` function, which takes an `AutodocRepoConfig` object and an `AutodocUserConfig` object as input. Example usage:\n\n```javascript\nimport { query } from './autodoc';", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/summary.md"}, "type": "Document"}], ["1289", {"page_content": "```javascript\nimport { query } from './autodoc';\n\nconst repoConfig = {\n  name: 'MyProject',\n  repositoryUrl: 'https://github.com/user/myproject',\n  output: 'path/to/output',\n  contentType: 'code',\n  chatPrompt: 'Ask me anything about MyProject',\n  targetAudience: 'developers',\n};\n\nconst userConfig = {\n  llms: 'path/to/llms',\n};\n\nquery(repoConfig, userConfig);\n```\n\n### user\n\nThe `user` folder manages the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs). Example usage:\n\n```javascript\nimport { user } from './path/to/this/file';\n\n// Create a new user configuration with default settings\nawait user();\n\n// Update the user configuration with a custom config object\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/summary.md"}, "type": "Document"}], ["1290", {"page_content": "In summary, the code in this folder is essential for various tasks related to the Autodoc project, such as initializing the configuration, processing repositories, generating documentation, and creating a chatbot for answering questions about a specific software project.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/summary.md"}, "type": "Document"}], ["1291", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\commands\\query)\n\nThe `query` folder in the Autodoc project contains code for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot is trained on the content of the project and provides answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate.\n\nThe main entry point for the chatbot is the `query` function in `index.ts`. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store and creates a chat chain using the `makeChain` function from `createChatChain.ts`.\n\nHere's an example of how the `query` function might be used:\n\n```javascript\nimport { query } from './autodoc';", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/summary.md"}, "type": "Document"}], ["1292", {"page_content": "```javascript\nimport { query } from './autodoc';\n\nconst repoConfig = {\n  name: 'MyProject',\n  repositoryUrl: 'https://github.com/user/myproject',\n  output: 'path/to/output',\n  contentType: 'code',\n  chatPrompt: 'Ask me anything about MyProject',\n  targetAudience: 'developers',\n};\n\nconst userConfig = {\n  llms: 'path/to/llms',\n};\n\nquery(repoConfig, userConfig);\n```\n\nThis example initializes the chatbot with the specified repository and user configurations and starts the chatbot interface for the user to ask questions about the \"MyProject\" codebase.\n\nThe `createChatChain.ts` file defines the `makeChain` function, which creates a chatbot for answering questions about a software project. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/summary.md"}, "type": "Document"}], ["1293", {"page_content": "The `makeChain` function takes several parameters, such as `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and `onTokenStream`. It first creates a question generator using the `LLMChain` class, then creates a `QA_PROMPT` template using the `makeQAPrompt` function, and finally creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project.\n\nIn summary, the code in the `query` folder is responsible for creating a chatbot that can answer questions about a specific software project in a conversational manner. The chatbot uses a combination of natural language processing techniques and efficient nearest neighbor search to generate accurate and relevant answers for the user.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/summary.md"}, "type": "Document"}], ["1294", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\query\\createChatChain.ts)\n\nThis code defines a function `makeChain` that creates a chatbot for answering questions about a software project called `projectName`. The chatbot is trained on the content of the project, which is located at `repositoryUrl`. The content type of the project is specified by the `contentType` parameter. The chatbot is designed to provide conversational answers with hyperlinks back to GitHub, including code examples and links to the examples where appropriate. The target audience for the chatbot is specified by the `targetAudience` parameter.\n\nThe `makeChain` function takes several parameters:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/createChatChain.md"}, "type": "Document"}], ["1295", {"page_content": "The `makeChain` function takes several parameters:\n\n- `projectName`: The name of the software project.\n- `repositoryUrl`: The URL of the project's repository.\n- `contentType`: The type of content the chatbot is trained on.\n- `chatPrompt`: Additional instructions for answering questions about the content type.\n- `targetAudience`: The intended audience for the chatbot's answers.\n- `vectorstore`: An instance of HNSWLib for efficient nearest neighbor search.\n- `llms`: An array of LLMModels, which are language models used for generating answers.\n- `onTokenStream`: An optional callback function that is called when a new token is generated by the language model.\n\nThe `makeChain` function first creates a question generator using the `LLMChain` class. This generator is responsible for rephrasing follow-up questions to be standalone questions. It uses the `CONDENSE_PROMPT` template, which is defined at the beginning of the code.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/createChatChain.md"}, "type": "Document"}], ["1296", {"page_content": "Next, the function creates a `QA_PROMPT` template using the `makeQAPrompt` function. This template is used to generate answers to the questions in a conversational manner, with hyperlinks back to GitHub and code examples where appropriate.\n\nFinally, the function creates and returns a new instance of the `ChatVectorDBQAChain` class, which combines the question generator and the document chain to create a chatbot that can answer questions about the software project. The chatbot uses the `vectorstore` for efficient nearest neighbor search and the `llms` language models for generating answers. If the `onTokenStream` callback is provided, it will be called when a new token is generated by the language model.\n## Questions: \n 1. **Question:** What is the purpose of the `makeChain` function and what are its input parameters?", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/createChatChain.md"}, "type": "Document"}], ["1297", {"page_content": "**Answer:** The `makeChain` function is used to create a `ChatVectorDBQAChain` instance, which is responsible for generating questions and answers based on the given input parameters. The input parameters include `projectName`, `repositoryUrl`, `contentType`, `chatPrompt`, `targetAudience`, `vectorstore`, `llms`, and an optional `onTokenStream` function.\n\n2. **Question:** What are the roles of `CONDENSE_PROMPT` and `QA_PROMPT` in this code?\n\n   **Answer:** `CONDENSE_PROMPT` is a template for generating standalone questions from a given chat history and follow-up question. `QA_PROMPT` is a template for generating conversational answers with hyperlinks to GitHub, based on the provided context and question. Both templates are used in the `LLMChain` and `loadQAChain` instances, respectively.\n\n3. **Question:** How does the `onTokenStream` function work and when is it used?", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/createChatChain.md"}, "type": "Document"}], ["1298", {"page_content": "3. **Question:** How does the `onTokenStream` function work and when is it used?\n\n   **Answer:** The `onTokenStream` function is an optional callback that can be provided to the `makeChain` function. It is used to handle the streaming of tokens generated by the OpenAIChat instance. If provided, it will be called with each new token generated during the chat process.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/createChatChain.md"}, "type": "Document"}], ["1299", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\query\\index.ts)\n\nThis code defines a chatbot interface for the Autodoc project, which allows users to ask questions related to a specific codebase and receive answers in a conversational manner. The chatbot uses a combination of the `inquirer` library for user input, `marked` and `marked-terminal` for rendering Markdown output, and the `langchain` library for handling natural language processing tasks.\n\nThe `query` function is the main entry point for the chatbot. It takes two arguments: an `AutodocRepoConfig` object containing information about the code repository, and an `AutodocUserConfig` object containing user-specific settings. The function initializes a vector store using the `HNSWLib` and `OpenAIEmbeddings` classes, and creates a chat chain using the `makeChain` function.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/index.md"}, "type": "Document"}], ["1300", {"page_content": "The chatbot interface is displayed using the `displayWelcomeMessage` function, which prints a welcome message to the console. The `getQuestion` function is used to prompt the user for a question using the `inquirer` library. The chatbot then enters a loop, where it processes the user's question, generates a response using the chat chain, and displays the response as Markdown in the terminal.\n\nIf an error occurs during the processing of a question, the chatbot will display an error message and continue to prompt the user for a new question. The loop continues until the user types 'exit', at which point the chatbot terminates.\n\nHere's an example of how the `query` function might be used:\n\n```javascript\nimport { query } from './autodoc';\n\nconst repoConfig = {\n  name: 'MyProject',\n  repositoryUrl: 'https://github.com/user/myproject',\n  output: 'path/to/output',\n  contentType: 'code',\n  chatPrompt: 'Ask me anything about MyProject',\n  targetAudience: 'developers',\n};", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/index.md"}, "type": "Document"}], ["1301", {"page_content": "const userConfig = {\n  llms: 'path/to/llms',\n};\n\nquery(repoConfig, userConfig);\n```\n\nThis example would initialize the chatbot with the specified repository and user configurations, and start the chatbot interface for the user to ask questions about the \"MyProject\" codebase.\n## Questions: \n 1. **What is the purpose of the `query` function in this code?**\n\n   The `query` function is responsible for handling user interactions with the chatbot. It takes in an AutodocRepoConfig object and an AutodocUserConfig object, sets up the necessary data structures, and then enters a loop where it prompts the user for questions, processes them, and displays the results.\n\n2. **How does the code handle rendering Markdown text in the terminal?**\n\n   The code uses the `marked` library along with a custom `TerminalRenderer` to render Markdown text in the terminal. The `marked` library is configured with the custom renderer using `marked.setOptions({ renderer: new TerminalRenderer() });`.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/index.md"}, "type": "Document"}], ["1302", {"page_content": "3. **What is the purpose of the `chatHistory` variable and how is it used?**\n\n   The `chatHistory` variable is an array that stores the history of questions and answers in the chat session. It is used to keep track of the conversation between the user and the chatbot. When a new question is asked, the chat history is passed to the `chain.call()` function, and the new question and its corresponding answer are added to the `chatHistory` array.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/query/index.md"}, "type": "Document"}], ["1303", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\createVectorStore.ts)\n\nThe code in this file is responsible for processing a directory of text files, splitting the text into chunks, and creating a vector store using the HNSWLib library and OpenAIEmbeddings. This vector store can be used for efficient similarity search and retrieval of documents in the larger project.\n\nThe `processFile` function reads a file's content and creates a `Document` object with the content and metadata (source file path). It returns a Promise that resolves to the created Document.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/createVectorStore.md"}, "type": "Document"}], ["1304", {"page_content": "The `processDirectory` function is a recursive function that processes a directory and its subdirectories. It reads the files in the directory, and for each file, it checks if it's a directory or a regular file. If it's a directory, the function calls itself with the new directory path. If it's a file, it calls the `processFile` function to create a Document object. The function returns an array of Document objects.\n\nThe `RepoLoader` class extends the `BaseDocumentLoader` class and has a constructor that takes a file path as an argument. It has a `load` method that calls the `processDirectory` function with the given file path and returns the array of Document objects.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/createVectorStore.md"}, "type": "Document"}], ["1305", {"page_content": "The `createVectorStore` function is an async function that takes an `AutodocRepoConfig` object as an argument, which contains the root directory and output file path. It creates a `RepoLoader` instance with the root directory and loads the documents using the `load` method. It then creates a `RecursiveCharacterTextSplitter` instance with a specified chunk size and chunk overlap and splits the documents into chunks. Finally, it creates a vector store using the HNSWLib library and OpenAIEmbeddings with the processed documents and saves the vector store to the output file path.\n\nExample usage:\n\n```javascript\nconst config = {\n  root: './data/documents',\n  output: './data/vector_store',\n};", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/createVectorStore.md"}, "type": "Document"}], ["1306", {"page_content": "```javascript\nconst config = {\n  root: './data/documents',\n  output: './data/vector_store',\n};\n\ncreateVectorStore(config).then(() => {\n  console.log('Vector store created successfully');\n});\n```\n## Questions: \n 1. **Question:** What is the purpose of the `processFile` function and what does it return?\n   **Answer:** The `processFile` function is an asynchronous function that reads the content of a file given its file path, creates a `Document` object with the file contents and metadata (source file path), and returns a Promise that resolves to the created `Document` object.\n\n2. **Question:** How does the `processDirectory` function work and what does it return?\n   **Answer:** The `processDirectory` function is an asynchronous function that takes a directory path as input, reads all the files and subdirectories within it, and processes them recursively. It returns a Promise that resolves to an array of `Document` objects created from the files in the directory and its subdirectories.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/createVectorStore.md"}, "type": "Document"}], ["1307", {"page_content": "3. **Question:** What is the purpose of the `createVectorStore` function and how does it work?\n   **Answer:** The `createVectorStore` function is an asynchronous function that takes an `AutodocRepoConfig` object as input, which contains the root directory path and output file path. The function loads all the documents from the root directory using the `RepoLoader`, splits the text into chunks using the `RecursiveCharacterTextSplitter`, creates a vector store from the documents using the `HNSWLib` and `OpenAIEmbeddings`, and saves the vector store to the specified output file.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/createVectorStore.md"}, "type": "Document"}], ["1308", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\prompts.ts)\n\nThis code defines three utility functions that generate prompts for documentation experts working on a project. These functions are used to create documentation for code files and folders within a project. The generated prompts are in markdown format and include specific instructions for the documentation expert.\n\n1. `createCodeFileSummary`: This function generates a prompt for creating a summary of a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `filePrompt`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert.\n\nExample usage:\n```javascript\nconst prompt = createCodeFileSummary('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'Write a detailed technical explanation of this code.');\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/prompts.md"}, "type": "Document"}], ["1309", {"page_content": "2. `createCodeQuestions`: This function generates a prompt for creating a list of questions and answers about a code file. It takes five parameters: `filePath`, `projectName`, `fileContents`, `contentType`, and `targetAudience`. The function returns a markdown formatted string that includes the file's content and a custom prompt for the documentation expert to provide questions and answers.\n\nExample usage:\n```javascript\nconst prompt = createCodeQuestions('path/to/file.js', 'MyProject', 'const x = 10;', 'JavaScript', 'beginner');\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/prompts.md"}, "type": "Document"}], ["1310", {"page_content": "3. `folderSummaryPrompt`: This function generates a prompt for creating a summary of a folder containing code files and subfolders. It takes six parameters: `folderPath`, `projectName`, `files`, `folders`, `contentType`, and `folderPrompt`. The `files` parameter is an array of `FileSummary` objects, and the `folders` parameter is an array of `FolderSummary` objects. The function returns a markdown formatted string that includes a list of files and folders with their summaries and a custom prompt for the documentation expert.\n\nExample usage:\n```javascript\nconst prompt = folderSummaryPrompt('path/to/folder', 'MyProject', fileSummaries, folderSummaries, 'JavaScript', 'Write a detailed technical explanation of this folder structure.');\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/prompts.md"}, "type": "Document"}], ["1311", {"page_content": "These functions can be used in the larger project to generate documentation tasks for experts, ensuring consistent formatting and instructions across different parts of the project.\n## Questions: \n 1. **What is the purpose of the `createCodeFileSummary` function?**\n\n   The `createCodeFileSummary` function generates a string template for a code file summary prompt, which includes the file path, project name, file contents, content type, and a file prompt.\n\n2. **How does the `createCodeQuestions` function differ from the `createCodeFileSummary` function?**\n\n   The `createCodeQuestions` function generates a string template for a code documentation prompt that asks for 3 questions and their answers, while the `createCodeFileSummary` function generates a string template for a code file summary prompt.\n\n3. **What is the role of the `folderSummaryPrompt` function?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/prompts.md"}, "type": "Document"}], ["1312", {"page_content": "3. **What is the role of the `folderSummaryPrompt` function?**\n\n   The `folderSummaryPrompt` function generates a string template for a folder summary prompt, which includes the folder path, project name, lists of files and folders with their summaries, content type, and a folder prompt.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/prompts.md"}, "type": "Document"}], ["1313", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\processRepository.ts)\n\nThe `processRepository` function in this code is responsible for generating summaries and questions for code files and folders in a given repository. It takes an `AutodocRepoConfig` object as input, which contains information about the project, repository URL, input and output paths, language models, and other configurations. An optional `dryRun` parameter can be provided to skip actual API calls and file writing.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/processRepository.md"}, "type": "Document"}], ["1314", {"page_content": "The function starts by initializing the encoding and rate limit for API calls. It then defines two main helper functions: `processFile` and `processFolder`. The `processFile` function is responsible for processing individual code files. It reads the file content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it creates prompts for summaries and questions, selects the appropriate language model based on the input length, and calls the language model API to generate the summaries and questions. The results are then saved to a JSON file in the output directory.\n\nThe `processFolder` function is responsible for processing folders. It reads the folder content, calculates a checksum, and checks if reindexing is needed. If reindexing is required, it reads the summaries and questions of all files and subfolders in the folder, calls the language model API to generate a summary for the folder, and saves the result to a `summary.json` file in the folder.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/processRepository.md"}, "type": "Document"}], ["1315", {"page_content": "The main function then counts the number of files and folders in the project and processes them using the `traverseFileSystem` utility function. It processes all files first, followed by all folders. Finally, it returns the language model usage statistics.\n\nThe `calculateChecksum` function calculates the checksum of a list of file contents, while the `reindexCheck` function checks if reindexing is needed by comparing the new and old checksums of a file or folder.\n## Questions: \n 1. **Question:** What is the purpose of the `processRepository` function and what are its inputs and outputs?\n   **Answer:** The `processRepository` function processes a given code repository, generating summaries and questions for each file and folder within the repository. It takes an `AutodocRepoConfig` object and an optional `dryRun` boolean as inputs. The function returns a `Promise` that resolves to an object containing the models used during processing.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/processRepository.md"}, "type": "Document"}], ["1316", {"page_content": "2. **Question:** How does the `calculateChecksum` function work and what is its purpose?\n   **Answer:** The `calculateChecksum` function takes an array of file contents as input and calculates a checksum for each file using the MD5 hashing algorithm. It then concatenates all the checksums and calculates a final checksum using MD5 again. The purpose of this function is to generate a unique identifier for the contents of the files, which can be used to determine if the files have changed and need to be reprocessed.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/processRepository.md"}, "type": "Document"}], ["1317", {"page_content": "3. **Question:** How does the `reindexCheck` function work and when is it used?\n   **Answer:** The `reindexCheck` function checks if a summary.json file exists in the given file or folder path and compares the stored checksum with the new checksum to determine if the file or folder needs to be reindexed. It is used in the `processFile` and `processFolder` functions to decide whether to regenerate summaries and questions for a file or folder based on changes in their contents.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/processRepository.md"}, "type": "Document"}], ["1318", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\commands\\index)\n\nThe code in this folder is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It consists of several functions and utilities that work together to automate the documentation generation process.\n\nThe main function, `index`, takes an `AutodocRepoConfig` object as input, which contains various configuration options for processing the repository. It performs three main tasks:\n\n1. **Process the repository**: It calls the `processRepository` function to traverse the repository, generate summaries and questions for code files and folders using the LLMS (Language Learning Management System), and create JSON files with the results. These JSON files are stored in the `output/docs/json/` directory.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/summary.md"}, "type": "Document"}], ["1319", {"page_content": "2. **Create Markdown files**: It uses the `convertJsonToMarkdown` function to convert the generated JSON files into Markdown files. These Markdown files are stored in the `output/docs/markdown/` directory.\n\n3. **Create vector files**: It calls the `createVectorStore` function to create vector files from the generated Markdown files. These vector files are stored in the `output/docs/data/` directory.\n\nThroughout the execution of these tasks, the code provides visual feedback on the progress of the tasks using `updateSpinnerText` and `spinnerSuccess` functions.\n\nHere's an example of how this code might be used:\n\n```javascript\nindex({\n  name: \"myProject\",\n  root: \"./input\",\n  output: \"./output\",\n  filePrompt: true,\n  folderPrompt: true,\n  contentType: \"code\",\n  targetAudience: \"developers\",\n  linkHosted: \"https://github.com/user/myProject\",\n});\n```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/summary.md"}, "type": "Document"}], ["1320", {"page_content": "This will process the repository located at `./input`, generate documentation in JSON, Markdown, and vector formats, and save the results in the `./output` directory.\n\nThe `prompts.ts` file contains utility functions that generate prompts for documentation experts. These functions create markdown formatted strings with specific instructions for the documentation expert, ensuring consistent formatting and instructions across different parts of the project.\n\nIn summary, the code in this folder automates the process of generating documentation for a given repository based on the provided configuration options. The generated documentation can be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/summary.md"}, "type": "Document"}], ["1321", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\index.ts)\n\nThe code in this file is responsible for processing a given repository and generating documentation in JSON, Markdown, and vector formats. It exports a single function `index` that takes an `AutodocRepoConfig` object as its argument, which contains various configuration options for processing the repository.\n\nThe `index` function performs three main tasks:\n\n1. **Process the repository**: It traverses the repository, calls the LLMS (Language Learning Management System) for each file, and creates JSON files with the results. This is done using the `processRepository` function, which takes the same configuration options as the `index` function. The JSON files are stored in the `output/docs/json/` directory.\n\n   ```javascript\n   updateSpinnerText('Processing repository...');\n   await processRepository({ /* configuration options */ });\n   spinnerSuccess();\n   ```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/index.md"}, "type": "Document"}], ["1322", {"page_content": "2. **Create Markdown files**: It converts the generated JSON files into Markdown files using the `convertJsonToMarkdown` function. This function also takes the same configuration options as the `index` function. The Markdown files are stored in the `output/docs/markdown/` directory.\n\n   ```javascript\n   updateSpinnerText('Creating markdown files...');\n   await convertJsonToMarkdown({ /* configuration options */ });\n   spinnerSuccess();\n   ```\n\n3. **Create vector files**: It creates vector files from the generated Markdown files using the `createVectorStore` function. This function also takes the same configuration options as the `index` function. The vector files are stored in the `output/docs/data/` directory.\n\n   ```javascript\n   updateSpinnerText('Create vector files...');\n   await createVectorStore({ /* configuration options */ });\n   spinnerSuccess();\n   ```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/index.md"}, "type": "Document"}], ["1323", {"page_content": "Throughout the execution of these tasks, the code uses `updateSpinnerText` and `spinnerSuccess` functions to provide visual feedback on the progress of the tasks.\n\nIn the larger project, this code would be used to automatically generate documentation for a given repository based on the provided configuration options. The generated documentation can then be used for various purposes, such as displaying it on a website or analyzing the content for specific insights.\n## Questions: \n 1. **What does the `index` function do in this code?**\n\n   The `index` function is the main entry point for the autodoc project. It takes an `AutodocRepoConfig` object as input and performs three main tasks: processing the repository and creating JSON files, converting JSON files to markdown files, and creating vector files.\n\n2. **What is the purpose of the `processRepository`, `convertJsonToMarkdown`, and `createVectorStore` functions?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/index.md"}, "type": "Document"}], ["1324", {"page_content": "The `processRepository` function traverses the repository, calls LLMS for each file, and creates JSON files with the results. The `convertJsonToMarkdown` function creates markdown files from the generated JSON files. The `createVectorStore` function creates vector files from the markdown files.\n\n3. **What are the different types of prompts (`filePrompt`, `folderPrompt`, `chatPrompt`) used for in this code?**\n\n   These prompts are likely used to interact with the user during the processing of the repository. The `filePrompt` might be used to ask the user for input regarding specific files, the `folderPrompt` for input regarding folders, and the `chatPrompt` for general input or feedback during the processing.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/index.md"}, "type": "Document"}], ["1325", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\index\\convertJsonToMarkdown.ts)\n\nThe `convertJsonToMarkdown` function in this code is responsible for converting JSON files containing documentation information into Markdown files. This function is part of the larger Autodoc project, which aims to automate the process of generating documentation for code repositories.\n\nThe function takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the project name, input and output directories, and other settings related to the documentation generation process.\n\nThe code first counts the number of files in the project by traversing the file system using the `traverseFileSystem` utility function. This is done to provide a progress update to the user via the `updateSpinnerText` function.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/convertJsonToMarkdown.md"}, "type": "Document"}], ["1326", {"page_content": "Next, the `processFile` function is defined, which is responsible for reading the content of each JSON file, parsing it, and converting it into a Markdown format. The function checks if the file has a summary, and if so, it generates the Markdown content with a link to the code on GitHub, the summary, and any questions if present. The output Markdown file is then saved in the specified output directory.\n\nFinally, the `traverseFileSystem` function is called again, this time with the `processFile` function as an argument. This allows the code to process each JSON file in the project and convert it into a Markdown file. Once the process is complete, a success message is displayed to the user using the `spinnerSuccess` function.\n\nExample usage:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/convertJsonToMarkdown.md"}, "type": "Document"}], ["1327", {"page_content": "Example usage:\n\n```javascript\nconvertJsonToMarkdown({\n  name: \"myProject\",\n  root: \"./input\",\n  output: \"./output\",\n  filePrompt: true,\n  folderPrompt: true,\n  contentType: \"code\",\n  targetAudience: \"developers\",\n  linkHosted: \"https://github.com/user/myProject\",\n});\n```\n\nThis will convert all JSON files in the `./input` directory into Markdown files and save them in the `./output` directory.\n## Questions: \n 1. **Question:** What is the purpose of the `convertJsonToMarkdown` function and what are the expected inputs?\n   **Answer:** The `convertJsonToMarkdown` function is used to convert JSON files to Markdown files for each code file in the project. It takes an `AutodocRepoConfig` object as input, which contains various properties like projectName, root, output, filePrompt, folderPrompt, contentType, targetAudience, and linkHosted.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/convertJsonToMarkdown.md"}, "type": "Document"}], ["1328", {"page_content": "2. **Question:** How does the `traverseFileSystem` function work and what is its role in this code?\n   **Answer:** The `traverseFileSystem` function is a utility function that recursively traverses the file system, starting from the inputPath, and processes each file using the provided `processFile` function. In this code, it is used twice: first to count the number of files in the project, and then to create Markdown files for each code file in the project.\n\n3. **Question:** How are the output directories and Markdown files created, and what is the structure of the generated Markdown content?\n   **Answer:** The output directories are created using the `fs.mkdir` function with the `recursive: true` option. The Markdown files are created using the `fs.writeFile` function. The structure of the generated Markdown content includes a link to view the code on GitHub, the summary, and optionally, a list of questions if they exist.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/index/convertJsonToMarkdown.md"}, "type": "Document"}], ["1329", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\commands\\user)\n\nThe `index.ts` file in the `user` folder is responsible for managing the user configuration for the Autodoc project. It allows users to create, update, and save their configuration file, which stores information about their access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\n\nThe `makeConfigTemplate` function creates a default configuration object with either the provided `config` parameter or GPT-3 as the default LLM. This function is useful for generating a new configuration object when needed.\n\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/user/summary.md"}, "type": "Document"}], ["1330", {"page_content": "If the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\n\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\n\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/user/summary.md"}, "type": "Document"}], ["1331", {"page_content": "This code is essential for the Autodoc project as it allows users to manage their access to different LLMs and store their preferences in a configuration file. This configuration file can then be used by other parts of the project to determine which LLMs the user has access to and tailor the querying process accordingly.\n\nExample usage:\n\n```javascript\nimport { user } from './path/to/this/file';\n\n// Create a new user configuration with default settings\nawait user();\n\n// Update the user configuration with a custom config object\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\n```\n\nIn summary, the `index.ts` file in the `user` folder is a crucial part of the Autodoc project, allowing users to manage their LLM access and preferences. This configuration is then used by other parts of the project to provide a tailored experience based on the user's access to different LLMs.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/user/summary.md"}, "type": "Document"}], ["1332", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\user\\index.ts)\n\nThis code is responsible for managing the user configuration for the Autodoc project. It provides a way to create, update, and save the user configuration file, which stores information about the user's access to different Language Learning Models (LLMs) such as GPT-3, GPT-4, and GPT-4 32K.\n\nThe `makeConfigTemplate` function is used to create a default configuration object with the provided `config` parameter or with GPT-3 as the default LLM. This function is used to generate a new configuration object when needed.\n\nThe main function, `user`, is an asynchronous function that takes an optional `config` parameter. It first checks if a user configuration file already exists at the `userConfigFilePath`. If it does, the user is prompted to confirm whether they want to overwrite the existing configuration. If the user chooses not to overwrite, the process exits.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/user/index.md"}, "type": "Document"}], ["1333", {"page_content": "If the user configuration file does not exist, the code attempts to create the necessary directories for the file. If there's an error during this process, it logs the error and exits with a non-zero status code.\n\nNext, the user is prompted to select which LLMs they have access to. The available options are GPT-3.5 Turbo, GPT-3.5 Turbo with GPT-4 8K (Early Access), and GPT-3.5 Turbo with GPT-4 8K and GPT-4 32K (Early Access). The user's selection is then used to create a new configuration object using the `makeConfigTemplate` function.\n\nFinally, the new configuration object is written to the user configuration file in JSON format. A success message is displayed to the user, indicating that the configuration has been saved and they can start querying using the `doc q` command.\n\nExample usage:\n\n```javascript\nimport { user } from './path/to/this/file';\n\n// Create a new user configuration with default settings\nawait user();", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/user/index.md"}, "type": "Document"}], ["1334", {"page_content": "// Create a new user configuration with default settings\nawait user();\n\n// Update the user configuration with a custom config object\nawait user({ llms: [LLMModels.GPT3, LLMModels.GPT4] });\n```\n## Questions: \n 1. **What is the purpose of the `makeConfigTemplate` function?**\n\n   The `makeConfigTemplate` function is used to create a default configuration object for the Autodoc user. It takes an optional `config` parameter and returns an object with a `llms` property, which is an array of LLM models.\n\n2. **How does the `user` function handle existing user configuration files?**\n\n   The `user` function checks if a user configuration file already exists using `fsSync.existsSync`. If it does, the user is prompted with a confirmation message to overwrite the existing configuration. If the user chooses not to overwrite, the process exits with a status code of 0.\n\n3. **What are the available choices for LLM models in the `user` function?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/user/index.md"}, "type": "Document"}], ["1335", {"page_content": "3. **What are the available choices for LLM models in the `user` function?**\n\n   The available choices for LLM models are GPT-3.5 Turbo, GPT-3.5 Turbo and GPT-4 8K (Early Access), and GPT-3.5 Turbo, GPT-4 8K (Early Access), and GPT-4 32K (Early Access). The user can select one of these options, and the selected value is stored in the `llms` property of the new configuration object.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/user/index.md"}, "type": "Document"}], ["1336", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\cli\\commands\\estimate)\n\nThe `estimate` function in `index.ts` is a crucial part of the Autodoc project, as it provides an estimated cost of processing a given repository. It takes an `AutodocRepoConfig` object as input, containing various configuration options such as repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\n\nThe function begins by constructing the path to the JSON output directory, which stores intermediate results of the processing. It then updates the spinner text to indicate that cost estimation is in progress. The `processRepository` function is called with the provided configuration options and a `true` flag, signifying a dry run. This dry run returns the details of what would happen if the repository were processed, which is used to calculate the estimated cost.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/estimate/summary.md"}, "type": "Document"}], ["1337", {"page_content": "Upon completion of the dry run, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\n\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in red. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.\n\nHere's an example of how the `estimate` function might be used in the larger project:\n\n```javascript\nimport { estimate } from './path/to/this/file';", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/estimate/summary.md"}, "type": "Document"}], ["1338", {"page_content": "```javascript\nimport { estimate } from './path/to/this/file';\n\nconst config = {\n  name: 'my-repo',\n  repositoryUrl: 'https://github.com/user/my-repo.git',\n  root: './',\n  output: './output',\n  llms: ['en'],\n  ignore: ['.git', 'node_modules'],\n  filePrompt: true,\n  folderPrompt: true,\n  chatPrompt: true,\n  contentType: 'code',\n  targetAudience: 'developers',\n  linkHosted: true,\n};\n\nestimate(config);\n```\n\nThis example would estimate the cost of processing the \"my-repo\" repository with the specified configuration options.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/estimate/summary.md"}, "type": "Document"}], ["1339", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\cli\\commands\\estimate\\index.ts)\n\nThe `estimate` function in this code is responsible for providing an estimated cost of processing a given repository using the Autodoc project. It takes an `AutodocRepoConfig` object as input, which contains various configuration options such as the repository name, URL, root directory, output directory, and other settings related to the processing of the repository.\n\nThe function starts by constructing the path to the JSON output directory, which will be used to store the intermediate results of the processing. It then updates the spinner text to indicate that the cost estimation is in progress.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/estimate/index.md"}, "type": "Document"}], ["1340", {"page_content": "Next, the `processRepository` function is called with the provided configuration options and a `true` flag to indicate that this is a dry run. This means that the repository will not actually be processed, but the function will return the details of what would happen if it were processed. This is used to calculate the estimated cost of processing the repository.\n\nOnce the dry run is complete, the spinner is updated to show success, and the results are printed using the `printModelDetails` function. The total estimated cost is then calculated using the `totalIndexCostEstimate` function, which takes the values of the `runDetails` object as input.\n\nFinally, the estimated cost is displayed in the console using the `chalk.redBright` function to format the text in a red color. The message also includes a disclaimer that the actual cost may vary and recommends setting a limit in the user's OpenAI account to prevent unexpected charges.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/estimate/index.md"}, "type": "Document"}], ["1341", {"page_content": "Here's an example of how the `estimate` function might be used in the larger project:\n\n```javascript\nimport { estimate } from './path/to/this/file';\n\nconst config = {\n  name: 'my-repo',\n  repositoryUrl: 'https://github.com/user/my-repo.git',\n  root: './',\n  output: './output',\n  llms: ['en'],\n  ignore: ['.git', 'node_modules'],\n  filePrompt: true,\n  folderPrompt: true,\n  chatPrompt: true,\n  contentType: 'code',\n  targetAudience: 'developers',\n  linkHosted: true,\n};\n\nestimate(config);\n```\n\nThis example would estimate the cost of processing the \"my-repo\" repository with the specified configuration options.\n## Questions: \n 1. **What is the purpose of the `estimate` function?**\n\n   The `estimate` function is used to perform a dry run of the `processRepository` command to get an estimated price for indexing the given repository. It then prints the model details and the total estimated cost.\n\n2. **What are the parameters passed to the `processRepository` function?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/estimate/index.md"}, "type": "Document"}], ["1342", {"page_content": "2. **What are the parameters passed to the `processRepository` function?**\n\n   The `processRepository` function is called with an object containing the following properties: `name`, `repositoryUrl`, `root`, `output`, `llms`, `ignore`, `filePrompt`, `folderPrompt`, `chatPrompt`, `contentType`, `targetAudience`, and `linkHosted`. Additionally, a second argument `true` is passed to indicate that it's a dry run.\n\n3. **How is the total estimated cost calculated and displayed?**\n\n   The total estimated cost is calculated using the `totalIndexCostEstimate` function, which takes an array of values from the `runDetails` object. The cost is then displayed using `console.log` with `chalk.redBright` for formatting, showing the cost with two decimal places and a note that the actual cost may vary.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/cli/commands/estimate/index.md"}, "type": "Document"}], ["1343", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/.autodoc\\docs\\json\\src\\langchain)\n\nThe `hnswlib.ts` file in the `.autodoc\\docs\\json\\src\\langchain` folder contains the `HNSWLib` class, which is a specialized vector store utilizing the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. This class is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. Its primary purpose is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\n\nThe `HNSWLib` class constructor takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is responsible for converting documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/langchain/summary.md"}, "type": "Document"}], ["1344", {"page_content": "The `addDocuments` method accepts an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\n\nThe `save` and `load` methods enable persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\n\nIn the larger project, the `HNSWLib` class can be employed to efficiently store and search for documents based on their content similarity, which can be beneficial for tasks such as document clustering, recommendation systems, or information retrieval.\n\nHere's an example of how to use the `HNSWLib` class:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/langchain/summary.md"}, "type": "Document"}], ["1345", {"page_content": "Here's an example of how to use the `HNSWLib` class:\n\n```javascript\nconst embeddings = new Embeddings(/* ... */);\nconst args = { space: 'cosine' };\nconst hnswLib = new HNSWLib(embeddings, args);\n\n// Add documents to the index\nawait hnswLib.addDocuments(documents);\n\n// Perform a similarity search\nconst queryVector = /* ... */;\nconst k = 10;\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\n```\n\nThis code snippet demonstrates how to create an `HNSWLib` instance, add documents to the index, and perform a similarity search. The results can then be used for various purposes, such as finding related documents or generating recommendations based on content similarity.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/langchain/summary.md"}, "type": "Document"}], ["1346", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\langchain\\hnswlib.ts)\n\nThe `HNSWLib` class in this code is a specialized vector store that uses the Hierarchical Navigable Small World (HNSW) algorithm for efficient similarity search. It is built on top of the `hnswlib-node` library and extends the `SaveableVectorStore` class. The main purpose of this class is to store and search for documents based on their embeddings, which are high-dimensional vectors representing the documents' content.\n\nThe constructor of the `HNSWLib` class takes an `Embeddings` object and an `HNSWLibArgs` object as arguments. The `Embeddings` object is used to convert documents into their corresponding vector representations, while the `HNSWLibArgs` object contains configuration options for the HNSW index and an optional `InMemoryDocstore` object for storing the documents.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/langchain/hnswlib.md"}, "type": "Document"}], ["1347", {"page_content": "The `addDocuments` method takes an array of `Document` objects, converts them into embeddings using the `Embeddings` object, and adds them to the HNSW index. The `similaritySearchVectorWithScore` method takes a query vector and a number `k`, and returns the top `k` most similar documents along with their similarity scores.\n\nThe `save` and `load` methods allow for persisting the HNSW index, document store, and configuration options to disk and loading them back into memory. The `fromTexts` and `fromDocuments` static methods provide convenient ways to create an `HNSWLib` instance from an array of texts or documents, respectively.\n\nHere's an example of how to use the `HNSWLib` class:\n\n```javascript\nconst embeddings = new Embeddings(/* ... */);\nconst args = { space: 'cosine' };\nconst hnswLib = new HNSWLib(embeddings, args);\n\n// Add documents to the index\nawait hnswLib.addDocuments(documents);", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/langchain/hnswlib.md"}, "type": "Document"}], ["1348", {"page_content": "// Add documents to the index\nawait hnswLib.addDocuments(documents);\n\n// Perform a similarity search\nconst queryVector = /* ... */;\nconst k = 10;\nconst results = await hnswLib.similaritySearchVectorWithScore(queryVector, k);\n```\n\nIn the larger project, the `HNSWLib` class can be used to efficiently store and search for documents based on their content similarity, which can be useful for tasks such as document clustering, recommendation systems, or information retrieval.\n## Questions: \n 1. **Question**: What is the purpose of the `HNSWLib` class and how does it relate to the `SaveableVectorStore` class?\n   **Answer**: The `HNSWLib` class is an implementation of a vector store using the Hierarchical Navigable Small World (HNSW) algorithm from the `hnswlib-node` library. It extends the `SaveableVectorStore` class, which provides a base class for vector stores that can be saved and loaded from disk.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/langchain/hnswlib.md"}, "type": "Document"}], ["1349", {"page_content": "2. **Question**: How does the `addDocuments` method work and what is its purpose?\n   **Answer**: The `addDocuments` method takes an array of `Document` objects, extracts their `pageContent`, and embeds them using the provided `Embeddings` instance. It then adds the resulting vectors and documents to the HNSW index and the `InMemoryDocstore`, respectively.\n\n3. **Question**: How does the `similaritySearchVectorWithScore` method work and what does it return?\n   **Answer**: The `similaritySearchVectorWithScore` method takes a query vector and a number `k` as input, and searches for the `k` most similar vectors in the HNSW index. It returns an array of tuples, where each tuple contains a `Document` object and its corresponding similarity score to the query vector.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/langchain/hnswlib.md"}, "type": "Document"}], ["1350", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\const.ts)\n\nThe code in this file is responsible for managing the user configuration file for the autodoc project. It imports two Node.js built-in modules, `path` and `os`, which are used to handle file paths and operating system-related utility functions, respectively.\n\nThe `userConfigFileName` constant is defined as `'autodoc.user.json'`, which represents the name of the user configuration file. This file is expected to store user-specific settings for the autodoc project in JSON format.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/const.md"}, "type": "Document"}], ["1351", {"page_content": "The `userConfigFilePath` constant is created using the `path.resolve()` function, which combines the provided arguments into an absolute file path. The `os.homedir()` function is used to get the current user's home directory, and `./.config/autodoc/` is appended to it as the folder where the user configuration file should be stored. Finally, the `userConfigFileName` constant is appended to the path, resulting in the complete file path for the user configuration file.\n\nBy exporting both `userConfigFileName` and `userConfigFilePath`, other parts of the autodoc project can easily access and use these constants to read or write user-specific settings. For example, when the autodoc application starts, it can read the user configuration file from the specified path, and apply the settings accordingly.\n\nHere's a code example of how these constants might be used in another part of the autodoc project:\n\n```javascript\nimport { userConfigFilePath } from './path/to/this/file';", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/const.md"}, "type": "Document"}], ["1352", {"page_content": "```javascript\nimport { userConfigFilePath } from './path/to/this/file';\n\n// Read user configuration from the file\nconst userConfig = JSON.parse(fs.readFileSync(userConfigFilePath, 'utf-8'));\n\n// Apply user settings\napplyUserSettings(userConfig);\n```\n\nIn summary, this code is responsible for defining the name and file path of the user configuration file for the autodoc project, allowing other parts of the project to easily access and manage user-specific settings.\n## Questions: \n 1. **What is the purpose of the `userConfigFileName` and `userConfigFilePath` constants?**\n\n   The `userConfigFileName` constant defines the name of the user configuration file for the autodoc project, while the `userConfigFilePath` constant defines the absolute path to this file, which is located in the user's home directory under the `.config/autodoc/` folder.\n\n2. **Why are the `node:path` and `node:os` modules being imported?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/const.md"}, "type": "Document"}], ["1353", {"page_content": "2. **Why are the `node:path` and `node:os` modules being imported?**\n\n   The `node:path` module is imported to provide utilities for working with file and directory paths, such as resolving the absolute path to the user configuration file. The `node:os` module is imported to provide operating system-related utility methods, such as getting the user's home directory.\n\n3. **Is this code compatible with different operating systems?**\n\n   Yes, this code is compatible with different operating systems. The `os.homedir()` method returns the home directory of the current user, which is platform-specific, and the `path.resolve()` method takes care of handling the correct path separators for the current operating system.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/const.md"}, "type": "Document"}], ["1354", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/src\\index.ts)\n\nThis code is the main entry point for the Autodoc CLI tool, which provides a set of commands to help developers automatically generate documentation for their codebase. The tool uses the `commander` library to define and handle commands, and `inquirer` for interactive prompts.\n\nThe available commands are:\n\n1. `init`: Initializes the repository by creating an `autodoc.config.json` file in the current directory. If the file already exists, it uses the existing configuration.\n   ```bash\n   autodoc init\n   ```\n\n2. `estimate`: Estimates the cost of running the `index` command on the repository. It requires the `autodoc.config.json` file to be present.\n   ```bash\n   autodoc estimate\n   ```", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/index.md"}, "type": "Document"}], ["1355", {"page_content": "3. `index`: Traverses the codebase, writes documentation using LLM, and creates a locally stored index. Before starting the indexing process, it prompts the user for confirmation. It requires the `autodoc.config.json` file to be present.\n   ```bash\n   autodoc index\n   ```\n\n4. `user`: Sets the Autodoc user configuration. If a user configuration file exists, it uses the existing configuration.\n   ```bash\n   autodoc user\n   ```\n\n5. `q`: Queries an Autodoc index. It requires both the `autodoc.config.json` and user configuration files to be present.\n   ```bash\n   autodoc q\n   ```\n\nThe code also listens for unhandled promise rejections and handles them gracefully by showing an error spinner, stopping the spinner, and exiting with an error code.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/index.md"}, "type": "Document"}], ["1356", {"page_content": "In the larger project, this CLI tool serves as the primary interface for users to interact with Autodoc, allowing them to easily generate and manage documentation for their codebase.\n## Questions: \n 1. **What is the purpose of the Autodoc CLI Tool?**\n\n   The Autodoc CLI Tool is designed to help developers automatically generate documentation for their codebase by traversing the code, writing docs via LLM, and creating a locally stored index.\n\n2. **How does the `estimate` command work and what does it return?**\n\n   The `estimate` command reads the `autodoc.config.json` file and estimates the cost of running the `index` command on the repository. It provides an estimation of the resources required to generate the documentation.\n\n3. **What is the role of the `user` command and how does it interact with the user configuration file?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/index.md"}, "type": "Document"}], ["1357", {"page_content": "The `user` command is responsible for setting the Autodoc user configuration. It reads the user configuration file (if it exists) and allows the user to update or create a new configuration. This configuration is then used in other commands, such as the `query` command, to interact with the Autodoc index.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/src/index.md"}, "type": "Document"}], ["1358", {"page_content": "[View code on GitHub](https://github.com/context-labs/autodoc/tsconfig.json)\n\nThe code provided is a configuration file for the TypeScript compiler in a project. It specifies various options that control how the TypeScript compiler should process the source code and generate the output JavaScript files. This configuration file is typically named `tsconfig.json` and is placed at the root of a TypeScript project.\n\nThe `compilerOptions` object contains several key-value pairs that define the behavior of the TypeScript compiler:", "metadata": {"source": "autodoc/.autodoc/docs/markdown/tsconfig.md"}, "type": "Document"}], ["1359", {"page_content": "- `rootDir`: Specifies the root directory of the source files. In this case, it is set to \"src\", meaning that the source files are located in the \"src\" folder.\n- `outDir`: Specifies the output directory for the compiled JavaScript files. In this case, it is set to \"dist\", meaning that the compiled files will be placed in the \"dist\" folder.\n- `strict`: Enables strict type checking, which helps catch potential issues in the code.\n- `target`: Specifies the ECMAScript target version for the output JavaScript files. In this case, it is set to \"es2020\", meaning that the output files will be compatible with ECMAScript 2020 features.\n- `module`: Specifies the module system to be used. In this case, it is set to \"ES2020\", meaning that the output files will use the ECMAScript 2020 module system.\n- `sourceMap`: Generates source map files, which help in debugging the compiled code by mapping it back to the original TypeScript source files.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/tsconfig.md"}, "type": "Document"}], ["1360", {"page_content": "- `esModuleInterop`: Enables compatibility with ECMAScript modules for importing CommonJS modules.\n- `moduleResolution`: Specifies the module resolution strategy. In this case, it is set to \"node\", meaning that the Node.js module resolution algorithm will be used.\n- `allowSyntheticDefaultImports`: Allows default imports from modules with no default export.\n- `declaration`: Generates TypeScript declaration files (`.d.ts`) alongside the compiled JavaScript files, which can be useful for other projects that depend on this one.\n- `skipLibCheck`: Skips type checking of declaration files, which can speed up the compilation process.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/tsconfig.md"}, "type": "Document"}], ["1361", {"page_content": "Overall, this configuration file helps ensure that the TypeScript compiler processes the source code according to the specified options, resulting in compiled JavaScript files that are compatible with the desired ECMAScript version and module system, while also providing useful features like source maps and strict type checking.\n## Questions: \n 1. **What is the purpose of the `rootDir` and `outDir` options in the configuration?**\n\n   The `rootDir` option specifies the root directory of the input files, while the `outDir` option specifies the output directory for the compiled files.\n\n2. **What does the `strict` option do in the configuration?**\n\n   The `strict` option enables a wide range of type checking behavior that results in stronger guarantees of program correctness.\n\n3. **What is the significance of the `target` and `module` options in the configuration?**", "metadata": {"source": "autodoc/.autodoc/docs/markdown/tsconfig.md"}, "type": "Document"}], ["1362", {"page_content": "3. **What is the significance of the `target` and `module` options in the configuration?**\n\n   The `target` option specifies the ECMAScript target version for the output code, and the `module` option specifies the module system used in the output code. In this case, both are set to \"es2020\", which means the output code will be compatible with ECMAScript 2020 features and module system.", "metadata": {"source": "autodoc/.autodoc/docs/markdown/tsconfig.md"}, "type": "Document"}]]